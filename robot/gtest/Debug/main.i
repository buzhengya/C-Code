#line 1 "d:\\c++code\\robot\\gtest\\main.cpp"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"





















































#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

  


















































































#line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
 #line 253 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 257 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"








#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















    
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    
    

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        


            
        #line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"













#pragma once







































































































































#line 151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































#line 194 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 197 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 199 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





#line 205 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 209 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 216 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








#line 237 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 238 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros




































































































































































































































































































































































































































































                                                




                                                

















































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1564 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






























#line 1595 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
























#line 1620 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"












#line 1633 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































#line 1672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


























































































































#line 1795 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































































































#line 1898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








































































































































































#line 2067 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





































































































#line 2169 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



















































































































































































































#line 2381 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
extern "C" {




#line 2387 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



































































































































































































































#line 2615 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2654 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









































































































































































































































#line 2888 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









#line 2898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


    
    
#line 2903 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2910 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2911 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2918 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2919 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 2931 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

































#line 2965 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






















}
#line 2989 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
















































































































































































































































#line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"



#line 269 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















































































#line 352 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


}
#line 356 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"

#line 358 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
#line 2991 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef unsigned int uintptr_t;
    #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    


#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"





#line 54 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
    
    
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"











#line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

    

    
    
    




































#line 116 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


} 
#line 120 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } 

    





#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

#pragma pack(pop)
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    



    





















#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


















    

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 113 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 115 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    #line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    





#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"







#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
    
#line 149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    


#line 167 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
        
    

#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"










    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#line 202 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



    
#line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 211 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 215 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    
        
    

#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 233 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 235 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
            
        
    }


#line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






#line 254 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    


        




    #line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 266 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
    


#line 278 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 279 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"









    void __cdecl __security_init_cookie(void);

    
        void __fastcall __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    


#line 297 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 298 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
extern uintptr_t __security_cookie;
 

    
    
    
#line 306 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

} __pragma(pack(pop))

#line 310 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {









    

#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

#line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
        
    #line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"




    
#line 36 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    

#line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

#line 43 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
        
    #line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 50 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"





#line 64 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



    


#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"













    


        
    #line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 96 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;


#line 137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










    
#line 149 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"











#line 161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 165 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









    











        
    #line 188 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 189 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 193 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
        
    

#line 200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 201 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
















     void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 225 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void __cdecl _invoke_watson(
      wchar_t const*,
      wchar_t const*,
      wchar_t const*,
            unsigned int,
            uintptr_t);


    
        

    













#line 256 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 257 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










#line 268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        


    #line 277 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 278 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









    






        
    #line 296 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 297 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        
    #line 304 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 305 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 309 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"













#line 323 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"




















    
#line 345 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 349 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    

#line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        


            
        #line 365 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    #line 366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 367 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 371 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"





#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        



    #line 387 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 388 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
        
    



#line 397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 407 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
              
        

#line 414 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    



#line 419 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
    



#line 427 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
    



#line 435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 440 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t; 

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 484 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 491 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 492 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



    
#line 497 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 678 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"












































































    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1753 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

        
        
        
        

        


        


        


        


        


        


        


        


        



        



        


        


        


        


        


        


        


        


        


        


        



        



        



        


        



        




        

        




        

        




        

        




        

        




        

        




        

        




        

        




        

    #line 1897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 1898 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))

#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"









    

#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        

#line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
            
        #line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        

#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
            
        #line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 52 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        

#line 62 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
            
        #line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 66 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma pack(push,8)



















 
  
  
 


#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
 #line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
  
 


#line 49 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
 #line 53 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




















#line 74 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 76 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

	







		
		
			
		

#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 94 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		




 
  
 #line 104 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"










































	
	






		
			
		

#line 159 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 160 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	




		
			
		

#line 172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	
		
	



#line 182 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





	
		#pragma detect_mismatch("_MSC_VER", "1900")
	#line 192 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	#line 196 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		

#line 201 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MTd_StaticDebug")
		



#line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 208 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 209 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"








	

#line 220 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
		
	#line 222 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 223 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 233 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 235 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 236 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"











#line 248 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
#line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
 

 









 









 









 

 









 









 




 





 













#line 334 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"











#line 346 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"













#pragma once








#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"











    
    



#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"



#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"
    

    

#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"
#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"



    
#line 56 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#pragma comment(lib, "libcpmt" "d" "")






#line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 67 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"
#line 348 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 352 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 356 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 















 
  

#line 378 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 380 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 381 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 386 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 388 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 389 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 394 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 396 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 397 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  





#line 407 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

   


#line 412 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
    
   #line 414 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  #line 416 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 417 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 

#line 421 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 426 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   


     
   #line 431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
  #line 432 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 433 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 


























  
   
  #line 464 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 465 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

 
  
  
  




  
  
  

  







   
   
   
  #line 492 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  
  
  
  

 












#line 512 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		






		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class  _Lockit
	{	
public:
 

  
















#line 578 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() noexcept;	
  #line 582 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

  











#line 611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 697 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

class  _Init_locks
	{	
public:
 
  










#line 714 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;
  #line 717 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 731 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 736 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





		

 void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;




 

 
 #pragma pack(pop)
#line 755 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 756 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  

 
 
extern "C" {
 #line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

		





		






void __cdecl _Feraise(int);

typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
 double __cdecl _Cosh(double, double);
 short __cdecl _Dtest(double *);
 double __cdecl _Sinh(double, double);

 short __cdecl _Exp(double *, double, short);
extern   _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
 float __cdecl _FCosh(float, float);
 short __cdecl _FDtest(float *);
 float __cdecl _FSinh(float, float);

 short __cdecl _FExp(float *, float, short);
extern   _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
 long double __cdecl _LCosh(long double, long double);
 short __cdecl _LDtest(long double *);
 long double __cdecl _LSinh(long double, long double);

 short __cdecl _LExp(long double *, long double, short);
extern   _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 #line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"

#pragma once




#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
    #line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"



















    
        
            
        

#line 54 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
    

#line 57 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"






















































































































































    





#line 215 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"











 unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


 void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


 errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


 unsigned int __cdecl _statusfp(void);


 void __cdecl _fpreset(void);



    
     void __cdecl _statusfp2(
          unsigned int* _X86Status,
          unsigned int* _SSE2Status
        );

#line 267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"





 unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );


    
     int __cdecl __control87_2(
               unsigned int  _NewValue,
               unsigned int  _Mask,
          unsigned int* _X86ControlWord,
          unsigned int* _Sse2ControlWord
        );
#line 286 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"


 
 int* __cdecl __fpecode(void);



 
 int __cdecl __fpe_flt_rounds(void);












   double __cdecl _copysign(  double _Number,   double _Sign);
   double __cdecl _chgsign(  double _X);
   double __cdecl _scalb(  double _X,   long _Y);
   double __cdecl _logb(  double _X);
   double __cdecl _nextafter(  double _X,   double _Y);
   int    __cdecl _finite(  double _X);
   int    __cdecl _isnan(  double _X);
   int    __cdecl _fpclass(  double _X);














    
    
    

    
     void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"

__pragma(pack(push, 8)) extern "C" {









    
    



#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"









































#line 71 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    


        
    #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    
        
    #line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#pragma once









 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"












__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 49 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
    #line 50 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 51 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

typedef float float_t;
typedef double double_t;













    
        extern double const _HUGE;
    

#line 72 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


    
#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


















































































void __cdecl _fperrraise(  int _Except);

   short __cdecl _dclass(  double _X);
   short __cdecl _ldclass(  long double _X);
   short __cdecl _fdclass(  float _X);

   int __cdecl _dsign(  double _X);
   int __cdecl _ldsign(  long double _X);
   int __cdecl _fdsign(  float _X);

   int __cdecl _dpcomp(  double _X,   double _Y);
   int __cdecl _ldpcomp(  long double _X,   long double _Y);
   int __cdecl _fdpcomp(  float _X,   float _Y);

   short __cdecl _dtest(  double* _Px);
   short __cdecl _ldtest(  long double* _Px);
   short __cdecl _fdtest(  float* _Px);

 short __cdecl _d_int(  double* _Px,   short _Xexp);
 short __cdecl _ld_int(  long double* _Px,   short _Xexp);
 short __cdecl _fd_int(  float* _Px,   short _Xexp);

 short __cdecl _dscale(  double* _Px,   long _Lexp);
 short __cdecl _ldscale(  long double* _Px,   long _Lexp);
 short __cdecl _fdscale(  float* _Px,   long _Lexp);

 short __cdecl _dunscale(  short* _Pex,   double* _Px);
 short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
 short __cdecl _fdunscale(  short* _Pex,   float* _Px);

   short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
   short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
   short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

   short __cdecl _dnorm(  unsigned short* _Ps);
   short __cdecl _fdnorm(  unsigned short* _Ps);

   double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
   long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
   float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

   double __cdecl _dlog(  double _X,   int _Baseflag);
   long double __cdecl _ldlog(  long double _X,   int _Baseflag);
   float __cdecl _fdlog(  float _X,   int _Baseflag);

   double __cdecl _dsin(  double _X,   unsigned int _Qoff);
   long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
   float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 449 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"





  int       __cdecl abs(  int _X);
  long      __cdecl labs(  long _X);
  long long __cdecl llabs(  long long _X);

  double __cdecl acos(  double _X);
  double __cdecl asin(  double _X);
  double __cdecl atan(  double _X);
  double __cdecl atan2(  double _Y,   double _X);

  double __cdecl cos(  double _X);
  double __cdecl cosh(  double _X);
  double __cdecl exp(  double _X);
   double __cdecl fabs(  double _X);
  double __cdecl fmod(  double _X,   double _Y);
  double __cdecl log(  double _X);
  double __cdecl log10(  double _X);
  double __cdecl pow(  double _X,   double _Y);
  double __cdecl sin(  double _X);
  double __cdecl sinh(  double _X);
   double __cdecl sqrt(  double _X);
  double __cdecl tan(  double _X);
  double __cdecl tanh(  double _X);

   double    __cdecl acosh(  double _X);
   double    __cdecl asinh(  double _X);
   double    __cdecl atanh(  double _X);
    double    __cdecl atof(  char const* _String);
    double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
   double    __cdecl _cabs(  struct _complex _Complex_value);
   double    __cdecl cbrt(  double _X);
   double    __cdecl ceil(  double _X);
   double    __cdecl _chgsign(  double _X);
   double    __cdecl copysign(  double _Number,   double _Sign);
   double    __cdecl _copysign(  double _Number,   double _Sign);
   double    __cdecl erf(  double _X);
   double    __cdecl erfc(  double _X);
   double    __cdecl exp2(  double _X);
   double    __cdecl expm1(  double _X);
   double    __cdecl fdim(  double _X,   double _Y);
   double    __cdecl floor(  double _X);
   double    __cdecl fma(  double _X,   double _Y,   double _Z);
   double    __cdecl fmax(  double _X,   double _Y);
   double    __cdecl fmin(  double _X,   double _Y);
   double    __cdecl frexp(  double _X,   int* _Y);
   double    __cdecl hypot(  double _X,   double _Y);
   double    __cdecl _hypot(  double _X,   double _Y);
   int       __cdecl ilogb(  double _X);
   double    __cdecl ldexp(  double _X,   int _Y);
   double    __cdecl lgamma(  double _X);
   long long __cdecl llrint(  double _X);
   long long __cdecl llround(  double _X);
   double    __cdecl log1p(  double _X);
   double    __cdecl log2(  double _X);
   double    __cdecl logb(  double _X);
   long      __cdecl lrint(  double _X);
   long      __cdecl lround(  double _X);

int __cdecl _matherr(  struct _exception* _Except);

   double __cdecl modf(  double _X,   double* _Y);
   double __cdecl nan(  char const*);
   double __cdecl nearbyint(  double _X);
   double __cdecl nextafter(  double _X,   double _Y);
   double __cdecl nexttoward(  double _X,   long double _Y);
   double __cdecl remainder(  double _X,   double _Y);
   double __cdecl remquo(  double _X,   double _Y,   int* _Z);
   double __cdecl rint(  double _X);
   double __cdecl round(  double _X);
   double __cdecl scalbln(  double _X,   long _Y);
   double __cdecl scalbn(  double _X,   int _Y);
   double __cdecl tgamma(  double _X);
   double __cdecl trunc(  double _X);
   double __cdecl _j0(  double _X );
   double __cdecl _j1(  double _X );
   double __cdecl _jn(int _X,   double _Y);
   double __cdecl _y0(  double _X);
   double __cdecl _y1(  double _X);
   double __cdecl _yn(  int _X,   double _Y);

   float     __cdecl acoshf(  float _X);
   float     __cdecl asinhf(  float _X);
   float     __cdecl atanhf(  float _X);
   float     __cdecl cbrtf(  float _X);
   float     __cdecl _chgsignf(  float _X);
   float     __cdecl copysignf(  float _Number,   float _Sign);
   float     __cdecl _copysignf(  float _Number,   float _Sign);
   float     __cdecl erff(  float _X);
   float     __cdecl erfcf(  float _X);
   float     __cdecl expm1f(  float _X);
   float     __cdecl exp2f(  float _X);
   float     __cdecl fdimf(  float _X,   float _Y);
   float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
   float     __cdecl fmaxf(  float _X,   float _Y);
   float     __cdecl fminf(  float _X,   float _Y);
   float     __cdecl _hypotf(  float _X,   float _Y);
   int       __cdecl ilogbf(  float _X);
   float     __cdecl lgammaf(  float _X);
   long long __cdecl llrintf(  float _X);
   long long __cdecl llroundf(  float _X);
   float     __cdecl log1pf(  float _X);
   float     __cdecl log2f(  float _X);
   float     __cdecl logbf(  float _X);
   long      __cdecl lrintf(  float _X);
   long      __cdecl lroundf(  float _X);
   float     __cdecl nanf(  char const*);
   float     __cdecl nearbyintf(  float _X);
   float     __cdecl nextafterf(  float _X,   float _Y);
   float     __cdecl nexttowardf(  float _X,   long double _Y);
   float     __cdecl remainderf(  float _X,   float _Y);
   float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
   float     __cdecl rintf(  float _X);
   float     __cdecl roundf(  float _X);
   float     __cdecl scalblnf(  float _X,   long _Y);
   float     __cdecl scalbnf(  float _X,   int _Y);
   float     __cdecl tgammaf(  float _X);
   float     __cdecl truncf(  float _X);



       int  __cdecl _set_SSE2_enable(  int _Flag);

















#line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"














#line 607 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl acosf(  float _X)
    {
        return (float)acos(_X);
    }

      __inline float __cdecl asinf(  float _X)
    {
        return (float)asin(_X);
    }

      __inline float __cdecl atan2f(  float _Y,   float _X)
    {
        return (float)atan2(_Y, _X);
    }

      __inline float __cdecl atanf(  float _X)
    {
        return (float)atan(_X);
    }

      __inline float __cdecl ceilf(  float _X)
    {
        return (float)ceil(_X);
    }

      __inline float __cdecl cosf(  float _X)
    {
        return (float)cos(_X);
    }

      __inline float __cdecl coshf(  float _X)
    {
        return (float)cosh(_X);
    }

      __inline float __cdecl expf(  float _X)
    {
        return (float)exp(_X);
    }

#line 649 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"





#line 655 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl fabsf(  float _X)
    {
        return (float)fabs(_X);
    }

#line 662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"






#line 669 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl floorf(  float _X)
    {
        return (float)floor(_X);
    }

      __inline float __cdecl fmodf(  float _X,   float _Y)
    {
        return (float)fmod(_X, _Y);
    }

#line 681 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

  __inline float __cdecl frexpf(  float _X,   int *_Y)
{
    return (float)frexp(_X, _Y);
}

  __inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

  __inline float __cdecl ldexpf(  float _X,   int _Y)
{
    return (float)ldexp(_X, _Y);
}













#line 710 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl log10f(  float _X)
    {
        return (float)log10(_X);
    }

      __inline float __cdecl logf(  float _X)
    {
        return (float)log(_X);
    }

      __inline float __cdecl modff(  float _X,   float* _Y)
    {
        double _F, _I;
        _F = modf(_X, &_I);
        *_Y = (float)_I;
        return (float)_F;
    }

      __inline float __cdecl powf(  float _X,   float _Y)
    {
        return (float)pow(_X, _Y);
    }

      __inline float __cdecl sinf(  float _X)
    {
        return (float)sin(_X);
    }

      __inline float __cdecl sinhf(  float _X)
    {
        return (float)sinh(_X);
    }

      __inline float __cdecl sqrtf(  float _X)
    {
        return (float)sqrt(_X);
    }

      __inline float __cdecl tanf(  float _X)
    {
        return (float)tan(_X);
    }

      __inline float __cdecl tanhf(  float _X)
    {
        return (float)tanh(_X);
    }

#line 760 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

   long double __cdecl acoshl(  long double _X);

  __inline long double __cdecl acosl(  long double _X)
{
    return acos((double)_X);
}

   long double __cdecl asinhl(  long double _X);

  __inline long double __cdecl asinl(  long double _X)
{
    return asin((double)_X);
}

  __inline long double __cdecl atan2l(  long double _Y,   long double _X)
{
    return atan2((double)_Y, (double)_X);
}

   long double __cdecl atanhl(  long double _X);

  __inline long double __cdecl atanl(  long double _X)
{
    return atan((double)_X);
}

   long double __cdecl cbrtl(  long double _X);

  __inline long double __cdecl ceill(  long double _X)
{
    return ceil((double)_X);
}

  __inline long double __cdecl _chgsignl(  long double _X)
{
    return _chgsign((double)_X);
}

   long double __cdecl copysignl(  long double _Number,   long double _Sign);

  __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign((double)_Number, (double)_Sign);
}

  __inline long double __cdecl coshl(  long double _X)
{
    return cosh((double)_X);
}

  __inline long double __cdecl cosl(  long double _X)
{
    return cos((double)_X);
}

   long double __cdecl erfl(  long double _X);
   long double __cdecl erfcl(  long double _X);

  __inline long double __cdecl expl(  long double _X)
{
    return exp((double)_X);
}

   long double __cdecl exp2l(  long double _X);
   long double __cdecl expm1l(  long double _X);

  __inline long double __cdecl fabsl(  long double _X)
{
    return fabs((double)_X);
}

   long double __cdecl fdiml(  long double _X,   long double _Y);

  __inline long double __cdecl floorl(  long double _X)
{
    return floor((double)_X);
}

   long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
   long double __cdecl fmaxl(  long double _X,   long double _Y);
   long double __cdecl fminl(  long double _X,   long double _Y);

  __inline long double __cdecl fmodl(  long double _X,   long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

  __inline long double __cdecl frexpl(  long double _X,   int *_Y)
{
    return frexp((double)_X, _Y);
}

   int __cdecl ilogbl(  long double _X);

  __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

  __inline long double __cdecl hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

  __inline long double __cdecl ldexpl(  long double _X,   int _Y)
{
    return ldexp((double)_X, _Y);
}

   long double __cdecl lgammal(  long double _X);
   long long __cdecl llrintl(  long double _X);
   long long __cdecl llroundl(  long double _X);

  __inline long double __cdecl logl(  long double _X)
{
    return log((double)_X);
}

  __inline long double __cdecl log10l(  long double _X)
{
    return log10((double)_X);
}

   long double __cdecl log1pl(  long double _X);
   long double __cdecl log2l(  long double _X);
   long double __cdecl logbl(  long double _X);
   long __cdecl lrintl(  long double _X);
   long __cdecl lroundl(  long double _X);

  __inline long double __cdecl modfl(  long double _X,   long double* _Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}

   long double __cdecl nanl(  char const*);
   long double __cdecl nearbyintl(  long double _X);
   long double __cdecl nextafterl(  long double _X,   long double _Y);
   long double __cdecl nexttowardl(  long double _X,   long double _Y);

  __inline long double __cdecl powl(  long double _X,   long double _Y)
{
    return pow((double)_X, (double)_Y);
}

   long double __cdecl remainderl(  long double _X,   long double _Y);
   long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
   long double __cdecl rintl(  long double _X);
   long double __cdecl roundl(  long double _X);
   long double __cdecl scalblnl(  long double _X,   long _Y);
   long double __cdecl scalbnl(  long double _X,   int _Y);

  __inline long double __cdecl sinhl(  long double _X)
{
    return sinh((double)_X);
}

  __inline long double __cdecl sinl(  long double _X)
{
    return sin((double)_X);
}

  __inline long double __cdecl sqrtl(  long double _X)
{
    return sqrt((double)_X);
}

  __inline long double __cdecl tanhl(  long double _X)
{
    return tanh((double)_X);
}

  __inline long double __cdecl tanl(  long double _X)
{
    return tan((double)_X);
}

   long double __cdecl tgammal(  long double _X);
   long double __cdecl truncl(  long double _X);





#line 948 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



    
    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 967 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))    double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))    double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))    double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))    double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))    double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))    double __cdecl yn(  int _X,   double _Y);
    #line 975 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 976 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



#pragma warning(pop)
#line 981 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


} __pragma(pack(pop))

#line 986 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"























#line 1010 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 

template<class _Ty>
	  inline _Ty _Pow_int(_Ty _Xx, int _Yx) noexcept
	{
	unsigned int _Nx;
	if (_Yx >= 0)
		_Nx = static_cast<unsigned int>(_Yx);
	else
		_Nx = static_cast<unsigned int>(-_Yx);

	for (_Ty _Zx = static_cast<_Ty>(1); ; _Xx *= _Xx)
		{
		if ((_Nx & 1) != 0)
			_Zx *= _Xx;
		if ((_Nx >>= 1) == 0)
			return (_Yx < 0 ? static_cast<_Ty>(1) / _Zx : _Zx);
		}
	}

  inline double abs(  double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

  inline double pow(  double _Xx,   int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline float abs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float acos(  float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

  inline float acosh(  float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

  inline float asin(  float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

  inline float asinh(  float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

  inline float atan(  float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

  inline float atanh(  float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

  inline float atan2(  float _Yx,   float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

  inline float cbrt(  float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

  inline float ceil(  float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

  inline float copysign(  float _Number,
	  float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

  inline float cos(  float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

  inline float cosh(  float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

  inline float erf(  float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

  inline float erfc(  float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

  inline float exp(  float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

  inline float exp2(  float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

  inline float expm1(  float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

  inline float fabs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float fdim(  float _Xx,   float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

  inline float floor(  float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

  inline float fma(  float _Xx,   float _Yx,
	  float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

  inline float fmax(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

  inline float fmin(  float _Xx,   float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

  inline float fmod(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

  inline float frexp(  float _Xx,   int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

  inline float hypot(  float _Xx,   float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

  inline int ilogb(  float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

  inline float ldexp(  float _Xx,   int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

  inline float lgamma(  float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

  inline long long llrint(  float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

  inline long long llround(  float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

  inline float log(  float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

  inline float log10(  float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

  inline float log1p(  float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

  inline float log2(  float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

  inline float logb(  float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

  inline long lrint(  float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

  inline long lround(  float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

  inline float modf(  float _Xx,   float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

  inline float nearbyint(  float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

  inline float nextafter(  float _Xx,   float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

  inline float nexttoward(  float _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,
	  float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,   int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline float remainder(  float _Xx,   float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

  inline float remquo(  float _Xx,   float _Yx,
	  int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

  inline float rint(  float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

  inline float round(  float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

  inline float scalbln(  float _Xx,   long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

  inline float scalbn(  float _Xx,   int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

  inline float sin(  float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

  inline float sinh(  float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

  inline float sqrt(  float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

  inline float tan(  float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

  inline float tanh(  float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

  inline float tgamma(  float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

  inline float trunc(  float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

  inline long double abs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double acos(  long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

  inline long double acosh(  long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

  inline long double asin(  long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

  inline long double asinh(  long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

  inline long double atan(  long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

  inline long double atanh(  long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

  inline long double atan2(  long double _Yx,
	  long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

  inline long double cbrt(  long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

  inline long double ceil(  long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

  inline long double copysign(  long double _Number,
	  long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

  inline long double cos(  long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

  inline long double cosh(  long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

  inline long double erf(  long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

  inline long double erfc(  long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

  inline long double exp(  long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

  inline long double exp2(  long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

  inline long double expm1(  long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

  inline long double fabs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double fdim(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

  inline long double floor(  long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

  inline long double fma(  long double _Xx,
	  long double _Yx,   long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

  inline long double fmax(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

  inline long double fmin(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

  inline long double fmod(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

  inline long double frexp(  long double _Xx,
	  int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

  inline long double hypot(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

  inline int ilogb(  long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

  inline long double ldexp(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

  inline long double lgamma(  long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

  inline long long llrint(  long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

  inline long long llround(  long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

  inline long double log(  long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

  inline long double log10(  long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

  inline long double log1p(  long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

  inline long double log2(  long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

  inline long double logb(  long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

  inline long lrint(  long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

  inline long lround(  long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

  inline long double modf(  long double _Xx,
	  long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

  inline long double nearbyint(  long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

  inline long double nextafter(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

  inline long double nexttoward(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  int _Yx) noexcept
	{
	return (_Pow_int(_Xx, _Yx));
	}

  inline long double remainder(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

  inline long double remquo(  long double _Xx,
	  long double _Yx,   int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

  inline long double rint(  long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

  inline long double round(  long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

  inline long double scalbln(  long double _Xx,
	  long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

  inline long double scalbn(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

  inline long double sin(  long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

  inline long double sinh(  long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

  inline long double sqrt(  long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

  inline long double tan(  long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

  inline long double tanh(  long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

  inline long double tgamma(  long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

  inline long double trunc(  long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}

 #line 650 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"






 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"


 
#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
  __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
 int __cdecl _callnewh(
      size_t _Size
    );

     
 __declspec(allocator)
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );


void __cdecl _free_base(
        void* _Block
    );


void __cdecl free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
 __declspec(allocator)  __declspec(restrict)
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 

size_t __cdecl _msize(
      void* _Block
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );


void __cdecl _aligned_free(
        void* _Block
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 

size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 211 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"










#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"




 int* __cdecl _errno(void);


 errno_t __cdecl _set_errno(  int _Value);
 errno_t __cdecl _get_errno(  int* _Value);



    
        
    

#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"


#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"

 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {





     
     void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                        void*       _Context
        );

     void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                             void*   _Context
        );

#line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"



 
 void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 
 void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void*, void const*, void const*), 
                                                       void*         _Context
    );

 
 void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 
 void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                             void*         _Context
    );

 
 void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

















































































#line 179 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
     void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
     void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

#line 203 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {
































 

 errno_t __cdecl _itow_s(
                              int      _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 61 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

 

 errno_t __cdecl _ltow_s(
                              long     _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 84 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"


 errno_t __cdecl _ultow_s(
                              unsigned long _Value,
      wchar_t*      _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

 
 double __cdecl wcstod(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
 double __cdecl _wcstod_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
 long __cdecl wcstol(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 long __cdecl _wcstol_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
 long long __cdecl wcstoll(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 long long __cdecl _wcstoll_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
 unsigned long __cdecl wcstoul(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 unsigned long __cdecl _wcstoul_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
 unsigned long long __cdecl wcstoull(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 unsigned long long __cdecl _wcstoull_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
 long double __cdecl wcstold(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
 long double __cdecl _wcstold_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
 float __cdecl wcstof(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
 float __cdecl _wcstof_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
 double __cdecl _wtof(
      wchar_t const* _String
    );

 
 double __cdecl _wtof_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
 int __cdecl _wtoi(
      wchar_t const* _String
    );

 
 int __cdecl _wtoi_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
 long __cdecl _wtol(
      wchar_t const* _String
    );

 
 long __cdecl _wtol_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
 long long __cdecl _wtoll(
      wchar_t const* _String
    );

 
 long long __cdecl _wtoll_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );


 errno_t __cdecl _i64tow_s(
                              __int64  _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _i64tow(
                        __int64  _Value,
        wchar_t* _Buffer,
                        int      _Radix
    );


 errno_t __cdecl _ui64tow_s(
                              unsigned __int64 _Value,
      wchar_t*         _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _ui64tow(
                        unsigned __int64 _Value,
        wchar_t*         _Buffer,
                        int              _Radix
    );

 
 __int64 __cdecl _wtoi64(
      wchar_t const* _String
    );

 
 __int64 __cdecl _wtoi64_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
 __int64 __cdecl _wcstoi64(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 __int64 __cdecl _wcstoi64_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
 unsigned __int64 __cdecl _wcstoui64(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
 unsigned __int64 __cdecl _wcstoui64_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );




 
 
 __declspec(allocator) wchar_t* __cdecl _wfullpath(
      wchar_t*       _Buffer,
                                wchar_t const* _Path,
                                  size_t         _BufferCount
    );




 errno_t __cdecl _wmakepath_s(
      wchar_t*       _Buffer,
                              size_t         _BufferCount,
                        wchar_t const* _Drive,
                        wchar_t const* _Dir,
                        wchar_t const* _Filename,
                        wchar_t const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 359 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 368 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

 void __cdecl _wperror(
      wchar_t const* _ErrMsg
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _wsplitpath(
                        wchar_t const* _FullPath,
        wchar_t*       _Drive,
        wchar_t*       _Dir,
        wchar_t*       _Filename,
        wchar_t*       _Ext
    );

 errno_t __cdecl _wsplitpath_s(
                                  wchar_t const* _FullPath,
         wchar_t*       _Drive,
                                    size_t         _DriveCount,
           wchar_t*       _Dir,
                                    size_t         _DirCount,
      wchar_t*       _Filename,
                                    size_t         _FilenameCount,
           wchar_t*       _Ext,
                                    size_t         _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"





    
    

    
     errno_t __cdecl _wdupenv_s(
            wchar_t**      _Buffer,
                                                                            size_t*        _BufferCount,
                                                                               wchar_t const* _VarName
        );

    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _wgetenv(
          wchar_t const* _VarName
        );

     
    
     errno_t __cdecl _wgetenv_s(
                                     size_t*        _RequiredCount,
          wchar_t*       _Buffer,
                                      size_t         _BufferCount,
                                    wchar_t const* _VarName
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

     
     int __cdecl _wputenv(
          wchar_t const* _EnvString
        );

    
     errno_t __cdecl _wputenv_s(
          wchar_t const* _Name,
          wchar_t const* _Value
        );
    
     errno_t __cdecl _wsearchenv_s(
                                wchar_t const* _Filename,
                                wchar_t const* _VarName,
          wchar_t*       _Buffer,
                                  size_t         _BufferCount
        );
    
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 461 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"
    
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

     int __cdecl _wsystem(
          wchar_t const* _Command
        );

#line 474 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {




    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"









 void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );












 __declspec(noreturn) void __cdecl exit(  int _Code);
 __declspec(noreturn) void __cdecl _exit(  int _Code);
 __declspec(noreturn) void __cdecl _Exit(  int _Code);
 __declspec(noreturn) void __cdecl quick_exit(  int _Code);
 __declspec(noreturn) void __cdecl abort(void);





 unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    typedef int (__cdecl* _onexit_t)(void);



#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"






    
    
#line 82 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 142 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*, 
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 185 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"












#line 198 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"









  int __cdecl _set_error_mode(  int _Mode);



 int* __cdecl _errno(void);


 errno_t __cdecl _set_errno(  int _Value);
 errno_t __cdecl _get_errno(  int* _Value);

 unsigned long* __cdecl __doserrno(void);


 errno_t __cdecl _set_doserrno(  unsigned long _Value);
 errno_t __cdecl _get_doserrno(  unsigned long * _Value);


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);


 __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);


 void __cdecl perror(  char const* _ErrMsg);




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  int*      __cdecl __p__fmode  (void);






    
    
    
#line 248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 
 errno_t __cdecl _get_pgmptr (  char**    _Value);

 
 errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

 errno_t __cdecl _set_fmode  (               int       _Mode );

 errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

   div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
   ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
   lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540) 

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)






 void __cdecl srand(  unsigned int _Seed);

   int __cdecl rand(void);



#line 348 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 375 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 405 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                      double    __cdecl atof   (  char const* _String);
    int       __cdecl atoi   (  char const* _String);
                      long      __cdecl atol   (  char const* _String);
                      long long __cdecl atoll  (  char const* _String);
                      __int64   __cdecl _atoi64(  char const* _String);

   double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
   int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
   long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
   long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
   __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

   int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
   int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
   int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
 int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
 int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
 int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
 float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
 float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
 double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
 long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
 long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
 unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
 unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

 errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 631 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 654 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 661 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 684 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

 errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

 errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

 errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 749 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

 errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 778 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
 errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 803 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 824 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
        
    #line 826 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    


        
    #line 832 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

     
     int __cdecl ___mb_cur_max_func(void);

     
     int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 839 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



 
 int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

  
 int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
 size_t __cdecl _mbstrlen_l(
        char const* _String, 
      _locale_t   _Locale
    );

 
 
 size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
 size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
 int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
 int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


 errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 914 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 921 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


 errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 940 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 949 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
     errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 977 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh, 
                              _locale_t _Locale);


 errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1002 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1009 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


 errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1028 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1037 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




















 
 
 __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




 errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1085 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1094 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


 errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }










    

    
     
     errno_t __cdecl getenv_s(
                                     size_t*     _RequiredCount,
          char*       _Buffer,
                                      rsize_t     _BufferCount,
                                    char const* _VarName
        );
    
    #line 1140 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




     int*       __cdecl __p___argc (void);
     char***    __cdecl __p___argv (void);
     wchar_t*** __cdecl __p___wargv(void);

    




        
        
        
    #line 1157 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
    
     char***    __cdecl __p__environ (void);
     wchar_t*** __cdecl __p__wenviron(void);

    
        
    #line 1164 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
    
    





        
        
    #line 1174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



    
    



      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) 
     char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1193 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    


#line 1198 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    
     errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

     int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning (push)
    #pragma warning (disable:6540)

     
     int __cdecl _putenv(
          char const* _EnvString
        );

    
     errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

     errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1245 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1271 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"










    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
     void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
         int __cdecl putenv(
              char const* _EnvString
            );

    #line 1354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1360 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

 
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 #line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
 #line 44 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
struct _Nil
	{	
	};

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static constexpr _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	constexpr operator value_type() const noexcept
		{	
		return (value);
		}

	constexpr value_type operator()() const noexcept
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

	
template<bool _Val>
	struct _Cat_base
		: integral_constant<bool, _Val>
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, size_t _Nx>
	struct remove_const<const _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, size_t _Nx>
	struct remove_volatile<volatile _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 193 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<__int64>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned __int64>
		: true_type
	{	
	};
 #line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};














}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"
#line 355 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}








































template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
		&& ::std:: is_arithmetic<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"    double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"    double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"    double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"    double __cdecl atan2(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C"    double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"    double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"    double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"    double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C"    double __cdecl fabs(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C"    double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"    double __cdecl fmod(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C"    double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C"    double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"    double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"    double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"    double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"    double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"    double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"    double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"    double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

		









		

inline float _Fma(float _Left, float _Middle, float _Right)
	{	
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C"    double __cdecl acosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C"    double __cdecl asinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C"    double __cdecl atanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C"    double __cdecl cbrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C"    double __cdecl copysign(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C"    double __cdecl erf(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C"    double __cdecl erfc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C"    double __cdecl expm1(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C"    double __cdecl exp2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C"    double __cdecl fdim(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C"    double __cdecl fmax(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C"    double __cdecl fmin(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C"    double __cdecl hypot(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C"    int __cdecl ilogb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C"    double __cdecl lgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C"    long long __cdecl llrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C"    long long __cdecl llround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C"    double __cdecl log1p(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C"    double __cdecl log2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C"    double __cdecl logb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C"    long __cdecl lrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C"    long __cdecl lround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C"    double __cdecl nearbyint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C"    double __cdecl nextafter(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C"    double __cdecl nexttoward(  double,   long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C"    double __cdecl remainder(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C"    double __cdecl rint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C"    double __cdecl round(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C"    double __cdecl scalbln(  double,   long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C"    double __cdecl scalbn(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C"    double __cdecl tgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C"    double __cdecl trunc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 218 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
#line 219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
 #line 220 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"





#line 657 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 658 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 
namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
 #line 740 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#line 742 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"









#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {



 extern int* __cdecl _errno(void);


 errno_t __cdecl _set_errno(  int _Value);
 errno_t __cdecl _get_errno(  int* _Value);



 unsigned long* __cdecl __doserrno(void);


 errno_t __cdecl _set_doserrno(  unsigned long _Value);
 errno_t __cdecl _get_doserrno(  unsigned long * _Value);










































    
    
    
    
    
#line 78 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 126 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"



__pragma(pack(push, 8)) extern "C" {



 
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

 
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

 
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

 
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

   
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

 

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

 
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

   

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 85 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"








#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {





#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
    
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"


    




#line 31 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"























#line 55 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"




#line 60 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"


    


        #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
    #line 67 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
#line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"



   
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}



   
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}



















} __pragma(pack(pop))

#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

__pragma(pack(push, 8)) extern "C" {









    
     
     errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
     int __cdecl _cputws(
          wchar_t const* _Buffer
        );

           wint_t __cdecl _getwch  (void);
           wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  (  wchar_t _Character);
      wint_t __cdecl _ungetwch(  wint_t  _Character);

           wint_t __cdecl _getwch_nolock  (void);
           wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
     int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
     int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
     int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

#line 428 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 16 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {











    

#line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"

     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"
#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"





















   int __cdecl iswalnum  (  wint_t _C);
   int __cdecl iswalpha  (  wint_t _C);
   int __cdecl iswascii  (  wint_t _C);
   int __cdecl iswblank  (  wint_t _C);
   int __cdecl iswcntrl  (  wint_t _C);


   int __cdecl iswdigit  (  wint_t _C);

   int __cdecl iswgraph  (  wint_t _C);
   int __cdecl iswlower  (  wint_t _C);
   int __cdecl iswprint  (  wint_t _C);
   int __cdecl iswpunct  (  wint_t _C);
   int __cdecl iswspace  (  wint_t _C);
   int __cdecl iswupper  (  wint_t _C);
   int __cdecl iswxdigit (  wint_t _C);
   int __cdecl __iswcsymf(  wint_t _C);
   int __cdecl __iswcsym (  wint_t _C);

   int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


   wint_t __cdecl towupper(  wint_t _C);
   wint_t __cdecl towlower(  wint_t _C);
   int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

   wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
   int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



       int __cdecl isleadbyte(  int _C);
       int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"


















































































#line 196 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 17 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
 __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
 __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
 int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
 int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 18 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"








#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_share.h"








#pragma once












    
    
    
    
#line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_share.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"











    
    
#line 35 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 96 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
 int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


 errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
 int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
 intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
 int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

 int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
 int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

 errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 160 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
 
 intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
 intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
 int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
 int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
 int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


 errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

 errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"



#pragma warning(pop)
#line 275 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"


} __pragma(pack(pop))
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


    


     intptr_t __cdecl _wexecl(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexecle(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexeclp(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexeclpe(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wexecv(
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wexecve(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

     intptr_t __cdecl _wexecvp(
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wexecvpe(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

     intptr_t __cdecl _wspawnl(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnle(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnlp(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnlpe(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

     intptr_t __cdecl _wspawnv(
            int                   _Mode,
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wspawnve(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

     intptr_t __cdecl _wspawnvp(
            int                   _Mode,
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

     intptr_t __cdecl _wspawnvpe(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

     int __cdecl _wsystem(
          wchar_t const* _Command
        );

#line 116 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









#pragma once




__pragma(pack(push, 8)) extern "C" {








    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 FILE* __cdecl __acrt_iob_func(unsigned);















 wint_t __cdecl fgetwc(
      FILE* _Stream
    );


 wint_t __cdecl _fgetwchar(void);


 wint_t __cdecl fputwc(
         wchar_t _Character,
      FILE*   _Stream);


 wint_t __cdecl _fputwchar(
      wchar_t _Character
    );

 
 wint_t __cdecl getwc(
      FILE* _Stream
    );

 
 wint_t __cdecl getwchar(void);



 
 wchar_t* __cdecl fgetws(
      wchar_t* _Buffer,
                              int      _BufferCount,
                           FILE*    _Stream
    );


 int __cdecl fputws(
       wchar_t const* _Buffer,
      FILE*          _Stream
    );


 
 wchar_t* __cdecl _getws_s(
      wchar_t* _Buffer,
                              size_t   _BufferCount
    );

extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s(  wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 99 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


 wint_t __cdecl putwc(
         wchar_t _Character,
      FILE*   _Stream
    );


 wint_t __cdecl putwchar(
      wchar_t _Character
    );


 int __cdecl _putws(
      wchar_t const* _Buffer
    );


 wint_t __cdecl ungetwc(
         wint_t _Character,
      FILE*  _Stream
    );

 
 FILE * __cdecl _wfdopen(
        int            _FileHandle,
      wchar_t const* _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl _wfopen(
      wchar_t const* _FileName,
      wchar_t const* _Mode
    );


 errno_t __cdecl _wfopen_s(
      FILE**         _Stream,
                         wchar_t const* _FileName,
                         wchar_t const* _Mode
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl _wfreopen(
       wchar_t const* _FileName,
       wchar_t const* _Mode,
      FILE*          _OldStream
    );


 errno_t __cdecl _wfreopen_s(
      FILE**         _Stream,
                         wchar_t const* _FileName,
                         wchar_t const* _Mode,
                        FILE*          _OldStream
    );

 
 FILE* __cdecl _wfsopen(
      wchar_t const* _FileName,
      wchar_t const* _Mode,
        int            _ShFlag
    );

 void __cdecl _wperror(
      wchar_t const* _ErrorMessage
    );



     
     FILE* __cdecl _wpopen(
          wchar_t const* _Command,
          wchar_t const* _Mode
        );

#line 177 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 int __cdecl _wremove(
      wchar_t const* _FileName
    );




 
 __declspec(allocator) wchar_t* __cdecl _wtempnam(
      wchar_t const* _Directory,
      wchar_t const* _FilePrefix
    );



 

 errno_t __cdecl _wtmpnam_s(
      wchar_t* _Buffer,
                              size_t   _BufferCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 204 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 210 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









 wint_t __cdecl _fgetwc_nolock(
      FILE* _Stream
    );


 wint_t __cdecl _fputwc_nolock(
         wchar_t _Character, 
      FILE*   _Stream
    );


 wint_t __cdecl _getwc_nolock(
      FILE* _Stream
    );


 wint_t __cdecl _putwc_nolock(
         wchar_t _Character,
      FILE*   _Stream
    );


 wint_t __cdecl _ungetwc_nolock(
         wint_t _Character,
      FILE*  _Stream
    );





#line 251 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
















 int __cdecl __stdio_common_vfwprintf(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


 int __cdecl __stdio_common_vfwprintf_s(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


 int __cdecl __stdio_common_vfwprintf_p(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__inline int __cdecl _vfwprintf_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 303 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 307 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vfwprintf(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 317 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
}
#line 321 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_s_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 332 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vfwprintf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 348 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 352 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_p_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 365 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_p(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 379 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
}
#line 383 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 393 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vwprintf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 406 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 410 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_s_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 424 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
#line 439 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 441 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 451 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 455 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_p(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 464 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 478 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 487 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl fwprintf(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 496 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 505 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_s_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 524 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl fwprintf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)


#line 535 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 544 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 546 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_p_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 556 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 565 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_p(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 574 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 583 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 601 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl wprintf(
        wchar_t const* const _Format,
    ...)


#line 609 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 618 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_s_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 627 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 636 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl wprintf_s(
            wchar_t const* const _Format,
        ...)


#line 646 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 655 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 657 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 666 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_p(
        wchar_t const* const _Format,
    ...)


#line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 692 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"








 int __cdecl __stdio_common_vfwscanf(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
        wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );


__inline int __cdecl _vfwscanf_l(
      FILE*                                const _Stream,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}
#line 724 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vfwscanf(
      FILE*                                const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 734 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
}
#line 738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwscanf_s_l(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 749 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}
#line 755 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vfwscanf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 767 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 771 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 773 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__inline int __cdecl _vwscanf_l(
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 782 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 786 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vwscanf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 795 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}
#line 799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwscanf_s_l(
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 809 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 813 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vwscanf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 824 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
#line 828 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 830 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _fwscanf_l(
                                     FILE*          const _Stream,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 840 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 849 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl fwscanf(
                           FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 858 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 867 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwscanf_s_l(
                                       FILE*          const _Stream,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 877 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 886 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl fwscanf_s(
                                 FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)


#line 897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 906 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 908 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _wscanf_l(
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 917 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 926 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl wscanf(
        wchar_t const* const _Format,
    ...)


#line 934 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 943 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wscanf_s_l(
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 952 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 961 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl wscanf_s(
            wchar_t const* const _Format,
        ...)


#line 971 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 980 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 982 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









    





#line 998 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

 int __cdecl __stdio_common_vswprintf(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

 int __cdecl __stdio_common_vswprintf_s(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

 int __cdecl __stdio_common_vsnwprintf_s(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
                                         size_t           _MaxCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

 int __cdecl __stdio_common_vswprintf_p(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf_l(
           wchar_t*       const _Buffer,
                                             size_t         const _BufferCount,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
    )


#line 1056 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4793)

 

__inline int __cdecl _vsnwprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
                                         size_t         const _MaxCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1081 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vsnwprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vsnwprintf_s(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
                               size_t         const _MaxCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}
#line 1106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(pop)

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf(
        wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                   wchar_t const* _Format,
                                             va_list        _ArgList
    )


#line 1129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1136 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s(  wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1145 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_c_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_c(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_l(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1195 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)
}
#line 1202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl __vswprintf_l(
                         wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1214 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf(
               wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
}
#line 1233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl vswprintf(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                            va_list              _ArgList
    )


#line 1245 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1249 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1262 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    __inline int __cdecl vswprintf_s(
           wchar_t*       const _Buffer,
                                   size_t         const _BufferCount,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 1283 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
#line 1287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1297 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_p_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1310 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1318 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_p(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1330 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1334 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1345 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1363 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vscwprintf_l(_Format, 0, _ArgList);
}
#line 1367 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1378 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1386 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_p(
        wchar_t const* const _Format, 
                                  va_list              _ArgList
    )


#line 1396 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vscwprintf_p_l(_Format, 0, _ArgList);
}
#line 1400 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl __swprintf_l(
                         wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1411 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_l(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1432 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1441 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf(
               wchar_t*       const _Buffer,
        wchar_t const* const _Format,
    ...)


#line 1451 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1460 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl swprintf(
               wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1471 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)


#pragma warning(disable:4793 4996)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(    wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(    wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1494 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(    wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(    wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(pop)

 

__inline int __cdecl _swprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1524 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    __inline int __cdecl swprintf_s(
           wchar_t*       const _Buffer,
                                   size_t         const _BufferCount,
            wchar_t const* const _Format,
        ...)


#line 1536 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1545 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1547 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1554 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_p_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1566 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1575 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_p(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1586 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1595 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_c_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1607 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1616 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_c(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1627 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1636 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwprintf_l(
        wchar_t*       const _Buffer,
                                          size_t         const _BufferCount,
         wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 1648 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf(
        wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                   wchar_t const* _Format,
    ...)


#line 1673 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1687 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
                                         size_t         const _MaxCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1700 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1709 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf_s(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
                               size_t         const _MaxCount,
        wchar_t const* const _Format,
    ...)


#line 1721 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1730 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s(  wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
__inline int __cdecl _scwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1747 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1756 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf(
        wchar_t const* const _Format,
    ...)


#line 1765 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1774 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1784 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1793 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf_p(
        wchar_t const* const _Format,
    ...)


#line 1802 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1811 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    #pragma warning(push)
    #pragma warning(disable: 4141 4412 4793 4996 6054)

    

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int swprintf(
                       wchar_t*       const _Buffer,
                wchar_t const* const _Format,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            #pragma warning(suppress: 28719)
            _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);       
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl vswprintf(
                       wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            ) throw()
        {
            #pragma warning(suppress: 28719)
            return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int _swprintf_l(
                                 wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                             _locale_t      const _Locale,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl _vswprintf_l(
                                 wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                             _locale_t      const _Locale,
                                                    va_list              _ArgList
            ) throw()
        {
            return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        }

    #line 1872 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)
#line 1875 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"






#line 1882 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"







 
 int __cdecl __stdio_common_vswscanf(
                                        unsigned __int64 _Options,
              wchar_t const*   _Buffer,
                                        size_t           _BufferCount,
        wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );

 

__inline int __cdecl _vswscanf_l(
                             wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 1910 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1916 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl vswscanf(
                             wchar_t const* _Buffer,
        wchar_t const* _Format,
                                  va_list        _ArgList
    )


#line 1927 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
}
#line 1931 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswscanf_s_l(
                             wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 1943 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1949 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    
    __inline int __cdecl vswscanf_s(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 1962 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
#line 1966 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1968 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _Args) throw() { return vswscanf_s(_Buffer, _Size, _Format, _Args); } }
#line 1976 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwscanf_l(
              wchar_t const* const _Buffer,
                                        size_t         const _BufferCount,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                           va_list              _ArgList
    )


#line 1989 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#line 1995 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vsnwscanf_s_l(
                wchar_t const* const _Buffer,
                                          size_t         const _BufferCount,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
                                             va_list              _ArgList
    )


#line 2008 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#line 2014 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _swscanf_l(
                                      wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                                    _locale_t            _Locale,
    ...)


#line 2025 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2034 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl swscanf(
                            wchar_t const* const _Buffer,
        wchar_t const* const _Format,
    ...)


#line 2044 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2053 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swscanf_s_l(
                                        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 2064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2073 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    
    __inline int __cdecl swscanf_s(
                                  wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)


#line 2085 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);  
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 2094 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 2096 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf_l(
              wchar_t const* const _Buffer,
                                        size_t         const _BufferCount,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 2108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf(
        wchar_t const* const _Buffer,
                                  size_t         const _BufferCount,
            wchar_t const* const _Format,
    ...)


#line 2133 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2147 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwscanf_s_l(
                wchar_t const* const _Buffer,
                                          size_t         const _BufferCount,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 2159 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwscanf_s(
         wchar_t const* const _Buffer,
                                   size_t         const _BufferCount,
           wchar_t const* const _Format,
    ...)


#line 2179 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2188 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"







} __pragma(pack(pop))

#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
     errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
     errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );
    
    
     errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );
    
    
     errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );
    
     
     wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"











#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 116 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 139 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
 size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
    
#line 159 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 183 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 197 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 205 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
 size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
        



    #line 235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 251 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")) 
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 262 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 266 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


 errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

  errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 306 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

   int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

   int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

   int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

   int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

  errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 344 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 352 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

  errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 368 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 375 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

  errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 390 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 403 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 410 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 421 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


 errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 439 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 446 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 

 size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

 size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
 int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
 int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
 int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
 int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
 int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 558 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"









    


#line 571 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
     wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
     int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
     int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
     wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
     wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
     wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
     wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
     wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
     int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 637 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 643 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
 wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

 errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 62 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

 

 size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 100 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 119 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrdate_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 130 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"


 errno_t __cdecl _wstrtime_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 151 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"









    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"







#pragma once




    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 32 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 33 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820) 
#line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"







struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 105 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"



 int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

 int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

 int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

 int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

 int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

 int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

 int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

 int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

 int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"
#line 249 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"



#pragma warning(pop)
#line 254 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"


} __pragma(pack(pop))
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;




 wchar_t* __cdecl _wsetlocale(
            int            _Category,
      wchar_t const* _Locale
    );


 _locale_t __cdecl _wcreate_locale(
        int            _Category,
      wchar_t const* _Locale
    );



 wint_t __cdecl btowc(
      int _Ch
    );

 size_t __cdecl mbrlen(
        char const* _Ch,
                                                size_t      _SizeInBytes,
                                             mbstate_t*  _State
    );

 size_t __cdecl mbrtowc(
                              wchar_t*    _DstCh,
        char const* _SrcCh,
                                                size_t      _SizeInBytes,
                                             mbstate_t*  _State
    );

 
 errno_t __cdecl mbsrtowcs_s(
                              size_t*      _Retval,
              wchar_t*     _Dst,
                                   size_t       _Size,
                      char const** _PSrc,
                                   size_t       _N,
                                mbstate_t*   _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 99 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

 
 errno_t __cdecl wcrtomb_s(
                             size_t*    _Retval,
      char*      _Dst,
                                  size_t     _SizeInBytes,
                                  wchar_t    _Ch,
                           mbstate_t* _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 117 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

 
 errno_t __cdecl wcsrtombs_s(
                                              size_t*         _Retval,
      char*           _Dst,
                                                   size_t          _SizeInBytes,
                                wchar_t const** _Src,
                                                   size_t          _Size,
                                            mbstate_t*      _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 144 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

 int __cdecl wctob(
      wint_t _WCh
    );





    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 180 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 280 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

#line 282 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
 #line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#line 49 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

#pragma once










 
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
typedef double max_align_t;	
}
 #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"
#line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(0), _Last(0)
		{	
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	constexpr const _Elem *begin() const noexcept
		{	
		return (_First);
		}

	constexpr const _Elem *end() const noexcept
		{	
		return (_Last);
		}

	constexpr size_t size() const noexcept
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.end());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 76 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
  
  
 #line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

namespace std {
		
 
 
 #line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 
 
 
 
 

 
 

  

  











#line 55 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
   
   
  #line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 




















#line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		


		
 

 



































 
 

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static const bool value = false;
	};

		

 
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 #line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		
template<class _Ty = void>
	struct plus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
typedef int _Is_trans;	

		
template<>
	struct plus<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	typedef _Is_trans is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 




#line 347 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
	const size_t _FNV_offset_basis = 2166136261U;
	const size_t _FNV_prime = 16777619U;
 #line 351 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
	{	
	typedef _Kty argument_type;
	typedef size_t result_type;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static const bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

template<>
	struct hash<char16_t>
		: public _Bitwise_hash<char16_t>
	{	
	};

template<>
	struct hash<char32_t>
		: public _Bitwise_hash<char32_t>
	{	
	};

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 426 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 524 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}




 





 #line 541 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 549 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 





 


#line 560 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 569 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


























































namespace std {
	
template<class... _Types>
	struct _Arg_types
	{	
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	
	typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	
	typedef _Ty1 first_argument_type;
	typedef _Ty2 second_argument_type;
	};

	
template<class _Ty>
	struct _Is_function
	{	
	typedef false_type _Bool_type;
	};











template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; };


template<class _Ret,
	class... _Types>
	struct _Is_function<_Ret (_Types..., ...)>
	{	
	typedef true_type _Bool_type;
	typedef _Ret result_type;
	};

template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	
	};

		
template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, true_type) noexcept
	{	
	return (_Val);
	}

template<class _Ty> inline
	_Ty *_Addressof(_Ty& _Val, false_type) noexcept
	{	
	return (reinterpret_cast<_Ty *>(
		&const_cast<char&>(
		reinterpret_cast<const volatile char&>(_Val))));
	}

template<class _Ty> inline
	_Ty *addressof(_Ty& _Val) noexcept
	{	
	return (_Addressof(_Val, is_function<_Ty>()));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 707 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
#line 708 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"





#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4756)	

namespace std {















 

 
 
 
 

 
 
 
 

 
 
 
 

 
 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static constexpr bool has_denorm_loss = (bool)(false);
	static constexpr bool has_infinity = (bool)(false);
	static constexpr bool has_quiet_NaN = (bool)(false);
	static constexpr bool has_signaling_NaN = (bool)(false);
	static constexpr bool is_bounded = (bool)(false);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(false);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr bool is_specialized = (bool)(false);
	static constexpr bool tinyness_before = (bool)(false);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
	static constexpr int digits = (int)(0);
	static constexpr int digits10 = (int)(0);

	static constexpr int max_digits10 = (int)(0);

	static constexpr int max_exponent = (int)(0);
	static constexpr int max_exponent10 = (int)(0);
	static constexpr int min_exponent = (int)(0);
	static constexpr int min_exponent10 = (int)(0);
	static constexpr int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static constexpr _Ty (min)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(true);
	static constexpr bool is_integer = (bool)(true);
	static constexpr bool is_modulo = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static constexpr bool has_denorm_loss = (bool)(true);
	static constexpr bool has_infinity = (bool)(true);
	static constexpr bool has_quiet_NaN = (bool)(true);
	static constexpr bool has_signaling_NaN = (bool)(true);
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(true);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr bool tinyness_before = (bool)(true);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
	static constexpr int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)((-128) != 0);
	static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 263 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((_Ty)0x0000);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return ((_Ty)0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(0x0000 != 0);
	static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 320 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 322 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (false);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (true);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(1);
	static constexpr int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 - 1);
	static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8);
	static constexpr int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-32768));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (32767);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (short) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 552 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned short));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};
 #line 613 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

		
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	
public:
	typedef char16_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char16_t));
	static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);
#line 670 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647 - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (int) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 728 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned int));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 786 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647L - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 844 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffUL);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 902 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	
public:
	typedef char32_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char32_t));
	static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);
#line 960 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

 
		
template<> class numeric_limits<__int64>
	: public _Num_int_base
	{	
public:
	typedef __int64 _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0x7fffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (__int64) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);
#line 1019 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned __int64>
	: public _Num_int_base
	{	
public:
	typedef unsigned __int64 _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned __int64));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned __int64) * 301L / 1000);
#line 1077 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};
 #line 1079 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (1.175494351e-38F);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (3.402823466e+38F);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (1.192092896e-07F);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5F);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (1.401298464e-45F);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _FNan._Float);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _FSnan._Float);
		}

	static constexpr int digits = (int)(24);
	static constexpr int digits10 = (int)(6);

	static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)128);
	static constexpr int max_exponent10 = (int)((int)38);
	static constexpr int min_exponent = (int)((int)(-125));
	static constexpr int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _Nan._Double);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _Snan._Double);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5L);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (((float)(1e+300 * 1e+300)));
		}

	static  _Ty quiet_NaN() noexcept	
		{	
		return (:: _LNan._Long_double);
		}

	static  _Ty signaling_NaN() noexcept	
		{	
		return (:: _LSnan._Long_double);
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

  









































































































































































































#line 1472 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

 
 
 
 

 
 
 
 

 
 
 
 



}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1495 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1496 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"






#line 55 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

#pragma once





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {































    
#line 48 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"















    
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;




 errno_t __cdecl _get_stream_buffer_pointers(
           FILE*   _Stream,
      char*** _Base,
      char*** _Pointer,
      int**   _Count
    );









    
     errno_t __cdecl clearerr_s(
          FILE* _Stream
        );

    
     errno_t __cdecl fopen_s(
          FILE**      _Stream,
                             char const* _FileName,
                             char const* _Mode
        );
    
    
     
     size_t __cdecl fread_s(
            void*  _Buffer,
                       size_t _BufferSize,
                                                                        size_t _ElementSize,
                                                                        size_t _ElementCount,
                                                                     FILE*  _Stream
        );
    
    
     errno_t __cdecl freopen_s(
          FILE**      _Stream,
                             char const* _FileName,
                             char const* _Mode,
                            FILE*       _OldStream
        );

     
     char* __cdecl gets_s(
          char*   _Buffer,
                           rsize_t _Size
        );

    
     errno_t __cdecl tmpfile_s(
            FILE** _Stream
        );

     
    
     errno_t __cdecl tmpnam_s(
          char*   _Buffer,
                           rsize_t _Size
        );

#line 137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 void __cdecl clearerr(
      FILE* _Stream
    );

 

 int __cdecl fclose(
      FILE* _Stream
    );


 int __cdecl _fcloseall(void);

 
 FILE* __cdecl _fdopen(
        int         _FileHandle,
      char const* _Mode
    );

 
 int __cdecl feof(
      FILE* _Stream
    );

 
 int __cdecl ferror(
      FILE* _Stream
    );


 int __cdecl fflush(
      FILE* _Stream
    );

 

 int __cdecl fgetc(
      FILE* _Stream
    );


 int __cdecl _fgetchar(void);

 

 int __cdecl fgetpos(
      FILE*   _Stream,
        fpos_t* _Position
    );

 

 char* __cdecl fgets(
      char* _Buffer,
                           int   _MaxCount,
                        FILE* _Stream
    );

 
 int __cdecl _fileno(
      FILE* _Stream
    );


 int __cdecl _flushall(void);

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl fopen(
      char const* _FileName,
      char const* _Mode
    );


 

 int __cdecl fputc(
         int   _Character,
      FILE* _Stream
    );


 int __cdecl _fputchar(
      int _Character
    );

 

 int __cdecl fputs(
       char const* _Buffer,
      FILE*       _Stream
    );


 size_t __cdecl fread(
      void*  _Buffer,
                                                  size_t _ElementSize,
                                                  size_t _ElementCount,
                                               FILE*  _Stream
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl freopen(
       char const* _FileName,
       char const* _Mode,
      FILE*       _Stream
    );

 
 FILE* __cdecl _fsopen(
      char const* _FileName,
      char const* _Mode,
        int         _ShFlag
    );

 

 int __cdecl fsetpos(
      FILE*         _Stream,
         fpos_t const* _Position
    );

 

 int __cdecl fseek(
      FILE* _Stream,
         long  _Offset,
         int   _Origin
    );

 

 int __cdecl _fseeki64(
      FILE*   _Stream,
         __int64 _Offset,
         int     _Origin
    );

 
 
 long __cdecl ftell(
      FILE* _Stream
    );

 
 
 __int64 __cdecl _ftelli64(
      FILE* _Stream
    );


 size_t __cdecl fwrite(
      void const* _Buffer,
                                                size_t      _ElementSize,
                                                size_t      _ElementCount,
                                             FILE*       _Stream
    );

 
 
 int __cdecl getc(
      FILE* _Stream
    );

 
 int __cdecl getchar(void);

 
 int __cdecl _getmaxstdio(void);

extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 311 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 int __cdecl _getw(
      FILE* _Stream
    );

 void __cdecl perror(
      char const* _ErrorMessage
    );



     
    
     int __cdecl _pclose(
          FILE* _Stream
        );

     
     FILE* __cdecl _popen(
          char const* _Command,
          char const* _Mode
        );

#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

 int __cdecl putc(
         int   _Character,
      FILE* _Stream
    );


 int __cdecl putchar(
      int _Character
    );


 int __cdecl puts(
      char const* _Buffer
    );

 

 int __cdecl _putw(
         int   _Word, 
      FILE* _Stream
    );



 int __cdecl remove(
      char const* _FileName
    );

 
 int __cdecl rename(
      char const* _OldFileName,
      char const* _NewFileName
    );

 int __cdecl _unlink(
      char const* _FileName
    );



    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
     int __cdecl unlink(
          char const* _FileName
        );

#line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



 void __cdecl rewind(
      FILE* _Stream
    );


 int __cdecl _rmtmp(void);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl setbuf(
                                                  FILE* _Stream,
        char* _Buffer
    );


 int __cdecl _setmaxstdio(
      int _Maximum
    );

 

 int __cdecl setvbuf(
                           FILE*  _Stream,
        char*  _Buffer,
                              int    _Mode,
                              size_t _Size
    );




#line 419 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(allocator) char* __cdecl _tempnam(
      char const* _DirectoryName,
      char const* _FilePrefix
    );



#line 429 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 FILE* __cdecl tmpfile(void);

extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 437 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   char* __cdecl tmpnam(  char *_Buffer);
#line 443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

 int __cdecl ungetc(
         int   _Character,
      FILE* _Stream
    );








 void __cdecl _lock_file(
      FILE* _Stream
    );

 void __cdecl _unlock_file(
      FILE* _Stream
    );

 

 int __cdecl _fclose_nolock(
      FILE* _Stream
    );

 

 int __cdecl _fflush_nolock(
      FILE* _Stream
    );

 

 int __cdecl _fgetc_nolock(
      FILE* _Stream
    );

 

 int __cdecl _fputc_nolock(
         int   _Character,
      FILE* _Stream
    );


 size_t __cdecl _fread_nolock(
      void*  _Buffer,
                                                  size_t _ElementSize,
                                                  size_t _ElementCount,
                                               FILE*  _Stream
    );


 
 size_t __cdecl _fread_nolock_s(
      void*  _Buffer,
               size_t _BufferSize,
                                                                  size_t _ElementSize,
                                                                  size_t _ElementCount,
                                                               FILE*  _Stream
    );


 int __cdecl _fseek_nolock(
      FILE* _Stream,
         long  _Offset,
         int   _Origin
    );


 int __cdecl _fseeki64_nolock(
      FILE*   _Stream,
         __int64 _Offset,
         int     _Origin
    );

 
 long __cdecl _ftell_nolock(
      FILE* _Stream
    );

 
 __int64 __cdecl _ftelli64_nolock(
      FILE* _Stream
    );


 size_t __cdecl _fwrite_nolock(
      void const* _Buffer,
                                                size_t      _ElementSize,
                                                size_t      _ElementCount,
                                             FILE*       _Stream
    );


 int __cdecl _getc_nolock(
      FILE* _Stream
    );


 int __cdecl _putc_nolock(
         int   _Character,
      FILE* _Stream
    );


 int __cdecl _ungetc_nolock(
         int   _Character,
      FILE* _Stream
    );






















#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



 int* __cdecl __p__commode(void);




    
#line 590 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






#line 597 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






 int __cdecl __stdio_common_vfprintf(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 int __cdecl __stdio_common_vfprintf_s(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 int __cdecl __stdio_common_vfprintf_p(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__inline int __cdecl _vfprintf_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 642 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vfprintf(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 652 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l(_Stream, _Format, 0, _ArgList);
}
#line 656 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_s_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 667 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 671 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vfprintf_s(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 687 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 689 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_p_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 700 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 704 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_p(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 714 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
}
#line 718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 728 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 732 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vprintf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 741 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 745 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_s_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 755 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 759 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vprintf_s(
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 770 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
#line 774 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 786 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 790 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_p(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 803 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 813 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 822 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl fprintf(
                            FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 831 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 840 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 int __cdecl _set_printf_count_output(
      int _Value
    );

 int __cdecl _get_printf_count_output(void);


__inline int __cdecl _fprintf_s_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 856 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 865 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl fprintf_s(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)


#line 876 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 885 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 887 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_p_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 906 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_p(
                            FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 915 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 924 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 933 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 942 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl printf(
        char const* const _Format,
    ...)


#line 950 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 959 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_s_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 968 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 977 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl printf_s(
            char const* const _Format,
        ...)


#line 987 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 996 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 998 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1007 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1016 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_p(
        char const* const _Format,
    ...)


#line 1024 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1033 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"







 int __cdecl __stdio_common_vfscanf(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
        char const*      _Format,
                                    _locale_t        _Locale,
                                           va_list          _Arglist
    );


__inline int __cdecl _vfscanf_l(
                            FILE*       const _Stream,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1058 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}
#line 1064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vfscanf(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1074 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l(_Stream, _Format, 0, _ArgList);
}
#line 1078 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfscanf_s_l(
                            FILE*       const _Stream,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}
#line 1095 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"




    
    __inline int __cdecl vfscanf_s(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 1112 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1114 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscanf_l(
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 1128 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vscanf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}
#line 1141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscanf_s_l(
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1151 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 1155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vscanf_s(
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
#line 1170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _fscanf_l(
                                     FILE*       const _Stream,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 1182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1191 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl fscanf(
                           FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 1200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fscanf_s_l(
                                       FILE*       const _Stream,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 1219 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1228 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl fscanf_s(
                                 FILE*       const _Stream,
            char const* const _Format,
        ...)


#line 1239 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1250 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _scanf_l(
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 1259 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl scanf(
        char const* const _Format,
    ...)


#line 1276 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1285 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scanf_s_l(
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 1294 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1303 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl scanf_s(
            char const* const _Format,
        ...)


#line 1313 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1322 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1324 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"








 
 int __cdecl __stdio_common_vsprintf(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 int __cdecl __stdio_common_vsprintf_s(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 int __cdecl __stdio_common_vsnprintf_s(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
                                         size_t           _MaxCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 int __cdecl __stdio_common_vsprintf_p(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnprintf_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1393 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf(
        char*       const _Buffer,
                                          size_t      const _BufferCount,
                   char const* const _Format,
                                             va_list           _ArgList
    )


#line 1405 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1412 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










#line 1423 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl vsnprintf(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsprintf_l(
        char*       const _Buffer,
                      char const* const _Format,
                    _locale_t   const _Locale,
                           va_list           _ArgList
    )


#line 1455 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    #pragma warning(pop)
}
#line 1462 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl vsprintf(
               char*       const _Buffer,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1473 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1493 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl vsprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
#line 1519 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    
    extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s(  char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1527 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1529 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_p_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1542 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1550 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_p(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1562 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1566 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
                                         size_t      const _MaxCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list          _ArgList
    )


#line 1580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsnprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1588 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_s(
       char*       const _Buffer,
                               size_t      const _BufferCount,
                               size_t      const _MaxCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1601 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}
#line 1605 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1614 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl vsnprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
                                   size_t      const _MaxCount,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1629 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
#line 1633 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    
    extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1642 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1644 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1654 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _vscprintf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1671 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vscprintf_l(_Format, 0, _ArgList);
}
#line 1675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1693 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _vscprintf_p(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1702 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vscprintf_p_l(_Format, 0, _ArgList);
}
#line 1706 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1726 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_c(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1742 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _sprintf_l(
                         char*       const _Buffer,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1752 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1766 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl sprintf(
               char*       const _Buffer,
        char const* const _Format,
    ...)


#line 1776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1790 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4996)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
#pragma warning(pop)

 

__inline int __cdecl _sprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1812 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1821 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl sprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
            char const* const _Format,
        ...)


#line 1834 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1843 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1845 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1851 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _sprintf_p_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1863 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1872 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _sprintf_p(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 1883 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1892 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snprintf_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1904 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1918 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










#line 1929 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 
__inline int __cdecl snprintf(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 1940 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress:28719)    
    _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1950 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _snprintf(
        char*       const _Buffer,
                                          size_t      const _BufferCount,
                   char const* const _Format,
    ...)


#line 1960 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress:28719)    
    _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1970 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1979 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1991 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2000 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_c(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 2011 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2020 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
                                         size_t      const _MaxCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2033 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2042 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_s(
       char*       const _Buffer,
                               size_t      const _BufferCount,
                               size_t      const _MaxCount,
        char const* const _Format,
    ...)


#line 2054 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2063 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2071 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2080 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _scprintf(
        char const* const _Format,
    ...)


#line 2097 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _scprintf_p(
        char const* const _Format,
    ...)


#line 2132 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p(_Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






 int __cdecl __stdio_common_vsscanf(
                                        unsigned __int64 _Options,
              char const*      _Buffer,
                                        size_t           _BufferCount,
        char const*      _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );


__inline int __cdecl _vsscanf_l(
                             char const* const _Buffer,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 2166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 2172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vsscanf(
                             char const* const _Buffer,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 2182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
}
#line 2186 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vsscanf_s_l(
                             char const* const _Buffer,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 2197 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 2203 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    #pragma warning(push)
    #pragma warning(disable:6530)

    
    __inline int __cdecl vsscanf_s(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 2218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
#line 2222 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
   
    #pragma warning(pop)

#line 2233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _sscanf_l(
                                      char const* const _Buffer,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 2243 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl sscanf(
                            char const* const _Buffer,
        char const* const _Format,
    ...)


#line 2261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _sscanf_s_l(
                                        char const* const _Buffer,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 2280 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl sscanf_s(
                                  char const* const _Buffer,
            char const* const _Format,
        ...)


#line 2300 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 2314 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 2316 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snscanf_l(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 2330 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2343 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snscanf(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
                  char const* const _Format,
    ...)


#line 2353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



__inline int __cdecl _snscanf_s_l(
          char const* const _Buffer,
                                          size_t      const _BufferCount,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 2378 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2391 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _snscanf_s(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
                char const* const _Format,
    ...)


#line 2401 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2414 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(pop)



#line 2420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










    

    


#line 2436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
     char* __cdecl tempnam(
          char const* _Directory,
          char const* _FilePrefix
        );

    

#line 2446 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details."))  int   __cdecl fcloseall(void);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))     FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))   int   __cdecl fgetchar(void);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))     int   __cdecl fileno(  FILE* _Stream);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))   int   __cdecl flushall(void);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))   int   __cdecl fputchar(  int _Ch);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))       int   __cdecl getw(  FILE* _Stream);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))       int   __cdecl putw(  int _Ch,   FILE* _Stream);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))      int   __cdecl rmtmp(void);

#line 2458 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE FILE;

 
namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
 #line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"










#pragma once







__pragma(pack(push, 8)) extern "C" {



 
 int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
 int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 56 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"

    












#line 71 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"

#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"




    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
     void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
     int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );
#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"




    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }
#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"





__pragma(pack(push, 8)) extern "C" {







     
     errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
     errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
     errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
     errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
     errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
     char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 70 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

#line 93 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
 int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

char* __cdecl strcpy(
      char*       _Dest,
                                            char const* _Source
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


 errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
 int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
 int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


 errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strlwr( char *_String);
#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"


 errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 char* __cdecl strncat(
      char*       _Dest,
        char const* _Source,
                           size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 275 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
 int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
 int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 339 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 347 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 

#line 353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

#line 357 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
 size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
    
#line 373 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 382 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 char* __cdecl _strnset(
      char*  _Dest,
                           int    _Val,
                           size_t _Count
    );


 errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 403 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 411 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

 char* __cdecl _strrev(
      char* _Str
    );


 errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 434 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 440 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

char* __cdecl _strset(
      char* _Dest,
           int   _Value
    );

 
 size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


 errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strupr( char *_String);
#line 473 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"


 errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 486 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 493 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 

 size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

 size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 541 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"





    


#line 550 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
     char* __cdecl strdup(
          char const* _String
        );

    

#line 559 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
     int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
     int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
     char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
     int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
     char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
     char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
     char* __cdecl strupr(
          char* _String
        );

#line 608 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 614 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

	

		
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


namespace std {
	
template<class _Ty>
	struct _Ptr_traits
	{	
	};

template<class _Ty>
	struct _Ptr_traits<_Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<const _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<volatile _Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Ptr_traits<const volatile _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Is_memfunptr
	{	
	typedef false_type _Bool_type;
	};













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)  &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef const volatile _Ty type;
	};

	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef _Ty& type;
	};








template<> struct add_lvalue_reference< void> { typedef  void type; }; template<> struct add_lvalue_reference<const void> { typedef const void type; }; template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef _Ty&& type;
	};








template<> struct add_rvalue_reference< void> { typedef  void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() noexcept;

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};








template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };


	
template<class _Ty>
	struct add_pointer
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

	
	
template<class _Ty>
	struct _Is_void
		: false_type
	{	
	};

template<>
	struct _Is_void<void>
		: true_type
	{	
	};

template<class _Ty>
	struct is_void
		: _Is_void<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};


	
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	
	typedef _Ty2 _Class_type;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	

template<class _Ty>
	struct is_null_pointer
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	
	};

	
template<class _Ty>
	struct is_union : _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class : _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From,
	class _To>
	struct is_convertible
		: _Cat_base<__is_convertible_to(_From, _To)>
	{	
	};

	
template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_const
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_const
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_const<_Ty[_Nx]>
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_const<const _Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_pod : _Cat_base<__is_pod(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_empty : _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic : _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract : _Cat_base<__is_abstract(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_final : _Cat_base<__is_final(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type : _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial : _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable : _Cat_base<__is_trivially_copyable(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_constructible
		: _Cat_base<__is_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible

		: is_constructible<
			_Ty,

			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct _Is_assignable
	{	
	template<class _Dest,
		class _Src>
		static auto _Fn(int)
			-> decltype((void)(::std:: declval<_Dest>() = ::std:: declval<_Src>()),
				true_type());

	template<class _Dest,
		class _Src>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_To, _From>(0)) type;
	};

template<class _To,
	class _From>
	struct is_assignable
		: _Is_assignable<_To, _From>::type
	{	
	};

	
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: _Cat_base<__is_destructible(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible

		: is_trivially_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable

		: _Cat_base<__is_trivially_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<__has_trivial_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable

		: _Cat_base<__is_nothrow_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible
		: _Cat_base<__is_nothrow_destructible(_Ty)>
	{	
	};

	
template<class _Ty,
	bool = is_integral<_Ty>::value>
	struct _Sign_base
	{	
	typedef typename remove_cv<_Ty>::type _Uty;
	typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
	typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
	};

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	
		
	typedef is_floating_point<_Ty> _Signed;
	typedef false_type _Unsigned;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
	};




	
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	
	static const size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	
	static const size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	
	static const size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	
	static const size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	
template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base,
	class _Der>
	struct is_base_of : _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	

		
template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	{	
	typedef typename decay<_Ty>::type type;
	};

template<class _Ty0,
	class _Ty1>
	struct common_type<_Ty0, _Ty1>
	{	
	typedef typename decay<
		decltype(_Always_false<_Ty0>::value
			? ::std:: declval<_Ty0>()
			: ::std:: declval<_Ty1>())
	>::type type;
	};

template<class _Ty0,
	class _Ty1,
	class... _Ty>
	struct common_type<_Ty0, _Ty1, _Ty...>
	{	
	typedef typename common_type<
		typename common_type<_Ty0, _Ty1>::type, _Ty...
	>::type type;
	};

	
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	
	static_assert(is_integral<_Ty>::value,
		"integer_sequence<T, I...> requires T to be an integral type.");

	typedef integer_sequence<_Ty, _Vals...> type;
	typedef _Ty value_type;

	static constexpr size_t size() noexcept
		{	
		return (sizeof...(_Vals));
		}
	};

	
template<bool _Negative,
	bool _Zero,
	class _Int_con,
	class _Int_seq>
	struct _Make_seq
	{	
	static_assert(!_Negative,
		"make_integer_sequence<T, N> requires N to be non-negative.");
	};

template<class _Ty,
	_Ty... _Vals>
	struct _Make_seq<false, true,
		integral_constant<_Ty, 0>,
		integer_sequence<_Ty, _Vals...> >
		: integer_sequence<_Ty, _Vals...>
	{	
	};

template<class _Ty,
	_Ty _Ix,
	_Ty... _Vals>
	struct _Make_seq<false, false,
		integral_constant<_Ty, _Ix>,
		integer_sequence<_Ty, _Vals...> >
		: _Make_seq<false, _Ix == 1,
			integral_constant<_Ty, _Ix - 1>,
			integer_sequence<_Ty, _Ix - 1, _Vals...> >
	{	
	};

template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = typename _Make_seq<_Size < 0, _Size == 0,
		integral_constant<_Ty, _Size>, integer_sequence<_Ty> >::type;

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};

	
template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type& _Arg) noexcept
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type&& _Arg) noexcept
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		_Move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
		&& is_copy_constructible<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) noexcept
	{	
	return (::std:: move(_Arg));
	}

	
template<class _Ty> inline
	typename decay<_Ty>::type _Decay_copy(_Ty&& _Arg)
	{	
	return (::std:: forward<_Ty>(_Arg));
	}

	
template<class...>
	struct _Param_tester
	{	
	typedef void type;
	};

	
template<class... _Types>	
	using void_t = typename _Param_tester<_Types...>::type;

	
struct _Invoker_pmf_object
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmf_pointer
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmd_object
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
		{	
		return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
		}
	};

struct _Invoker_pmd_pointer
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
		{	
		return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
		}
	};

struct _Invoker_functor
	{	
	template<class _Callable,
		class... _Types>
		static auto _Call(_Callable&& _Obj, _Types&&... _Args)
		-> decltype(::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...));
		}
	};

template<class _Callable,
	class _Ty1,
	class _Decayed = typename decay<_Callable>::type,
	bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
	bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
	struct _Invoker1;

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
		: _If<is_base_of<
			typename _Is_memfunptr<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmf_object,
		_Invoker_pmf_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
		: _If<is_base_of<
			typename _Is_member_object_pointer<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmd_object,
		_Invoker_pmd_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable>
	struct _Invoker<_Callable>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class _Ty1,
	class... _Types2>
	struct _Invoker<_Callable, _Ty1, _Types2...>
		: _Invoker1<_Callable, _Ty1>
	{	
	};

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
	{	
	return (_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
	}

template<class _Rx,
	bool = is_void<_Rx>::value>
	struct _Forced
	{	
	};

struct _Unforced
	{	
	};

template<class _Cv_void,
	class... _Valtys> inline
	void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
	{	
	::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
	}

template<class _Rx,
	class... _Valtys> inline
	_Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

template<class... _Valtys> inline
	auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
	-> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

	
template<class _Fty>
	struct result_of
	{	
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};










template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; };  template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; }; template<class _Fty, class... _Args> struct result_of<_Fty __vectorcall (_Args...)> { typedef decltype(::std:: invoke(::std:: declval<_Fty>(), ::std:: declval<_Args>()...)) type; };


	
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	
	};

template<class _Ty>
	struct _Weak_result_type<_Ty, typename _Param_tester<
		typename _Ty::result_type>::type>
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_argument_type<_Ty, typename _Param_tester<
		typename _Ty::argument_type>::type>
		: _Weak_result_type<_Ty>
	{	
	typedef typename _Ty::argument_type argument_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_binary_args<_Ty, typename _Param_tester<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type>::type>
		: _Weak_argument_type<_Ty>
	{	
	typedef typename _Ty::first_argument_type first_argument_type;
	typedef typename _Ty::second_argument_type second_argument_type;
	};

template<class _Ty>
	struct _Weak_types
	{	
	typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
	typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
	typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty> >::type>::type type;
	};

	
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	
public:
	static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	typedef _Ty type;

	reference_wrapper(_Ty& _Val) noexcept
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	operator _Ty&() const noexcept
		{	
		return (*_Ptr);
		}

	_Ty& get() const noexcept
		{	
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

	
template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(_Ty& _Val) noexcept
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: ref(_Val.get()));
	}

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) noexcept
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: cref(_Val.get()));
	}

	
template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	static const bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	static const bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	static const bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};

namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	

		
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1773 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
#line 1774 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {

  


  



  




  


  #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
}

 

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {







    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"















typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





     intptr_t __cdecl _get_heap_handle(void);

     
     int __cdecl _heapmin(void);

    
         int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    
           int __cdecl _heapchk(void);
         int __cdecl _resetstkoflw(void);
    #line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"
     
    
    
    

    


        
    #line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    typedef char __static_assert_t[(sizeof(unsigned int) <= 8) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 8;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 8;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 109 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"





    
        
        




    #line 122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"












#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"




#line 140 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"
#line 141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 8;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            





        }
    }
    #pragma warning(pop)

#line 168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"




    
#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"



} __pragma(pack(pop))
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








     __declspec(noreturn) void __cdecl abort();
     __declspec(noreturn) void __cdecl terminate() throw();

    

         terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

         terminate_handler __cdecl _get_terminate();

    #line 40 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"

#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"
#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"



__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;


    
     __declspec(noreturn) void __cdecl unexpected() throw(...);

    

         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) throw();

         unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

    class type_info;

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

} __pragma(pack(pop))

#line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"
#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"





#pragma pack(push, 8)


__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

class exception
{
public:

    exception()
        : _Data()
    {
    }

    explicit exception(char const* const _Message)
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int)
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other)
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other)
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

} 

#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"
#pragma pack(pop)





#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

 bool __cdecl uncaught_exception() noexcept;
 int __cdecl uncaught_exceptions() noexcept;


inline terminate_handler __cdecl get_terminate()
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected()
	{	
	return (_get_unexpected());
	}
#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

}

 






































































































































































#line 230 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"









#line 240 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

 void __cdecl __ExceptionPtrCreate(  void*);
 void __cdecl __ExceptionPtrDestroy(  void*);
 void __cdecl __ExceptionPtrCopy(  void*,   const void*);
 void __cdecl __ExceptionPtrAssign(  void*,   const void*);
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
 bool __cdecl __ExceptionPtrToBool(  const void*);
 void __cdecl __ExceptionPtrSwap(  void*,   void*);
 void __cdecl __ExceptionPtrCurrentException(  void*);
 void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr() throw ()
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) throw ()
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) throw ()
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	typedef exception_ptr _Myt;

	explicit operator bool() const throw ()
		{
		return __ExceptionPtrToBool(this);
		}

	void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() throw ()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception() noexcept
	{
	return exception_ptr::_Current_exception();
	}

inline void rethrow_exception(  exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except)
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}

	
class nested_exception
	{	
public:
	nested_exception() noexcept
		: _Exc(::std:: current_exception())
		{	
		}

	nested_exception(const nested_exception&) noexcept = default;
	nested_exception& operator=(const nested_exception&) noexcept = default;
	virtual ~nested_exception() noexcept = default;

	__declspec(noreturn) void rethrow_nested() const
		{	
		if (_Exc)
			::std:: rethrow_exception(_Exc);
		else
			::std:: terminate();
		}

	::std:: exception_ptr nested_ptr() const noexcept
		{	
		return (_Exc);
		}

private:
	::std:: exception_ptr _Exc;
	};

	
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
		{	
		}
	};

template<class _Ty> inline
	__declspec(noreturn) void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;
	typedef _With_nested<_Ty, _Uty> _Glued;

	throw _Glued(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty> inline
	__declspec(noreturn) void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	
	typedef typename decay<_Ty>::type _Decayed;

	throw _Decayed(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty> inline
	__declspec(noreturn) void throw_with_nested(_Ty&& _Arg)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;

	integral_constant<bool,
		is_class<_Uty>::value
		&& !is_base_of<nested_exception, _Uty>::value
		&& !is_final<_Uty>::value> _Tag;

	_Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
	}

	
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	
	integral_constant<bool,
		is_polymorphic<_Ty>::value
		&& (!is_base_of<nested_exception, _Ty>::value
			|| is_convertible<_Ty *, nested_exception *>::value)> _Tag;

	_Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 482 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 483 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#pragma once










 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"







#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"



typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;














































    
    
    
#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"




































#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"





#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

 
namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;

	namespace tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
	}	
}
 #line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 






    namespace std
    {
        struct nothrow_t { };

        extern nothrow_t const nothrow;
    }
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"

   
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new(
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

   
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new[](
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();


    
       
    inline void* __cdecl operator new(size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }
#line 97 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


    
       
    inline void* __cdecl operator new[](size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"



#pragma warning(pop)
#pragma pack(pop)

} 
#line 119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  



namespace std {

		
 

typedef void (__cdecl * new_handler) ();
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

		
 new_handler __cdecl set_new_handler(  new_handler)
	noexcept;	

 new_handler __cdecl get_new_handler()
	noexcept;	
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"
#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

#pragma once





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

#pragma once








#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"







#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"







#pragma once




extern "C++" {

#pragma pack(push, 8)






         
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

         
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

#line 53 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

         int*  __cdecl __p__crtDbgFlag(void);
         long* __cdecl __p__crtBreakAlloc(void);

        
        

         _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

         _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

         _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

         _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

     int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

     void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

     int __cdecl _CrtDumpMemoryLeaks(void);

     int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
     int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
     int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

     void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

     int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

     void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

     void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
     int __cdecl _CrtReportBlockType(
          void const* _Block
        );

     long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

     int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"
















































    












































     void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
     __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

     size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
     __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
     __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
     __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
     __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
     __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
     __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
     __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

     void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
     __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

     size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
     __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
     __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
     errno_t __cdecl _dupenv_s_dbg(
            char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
     __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
     __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
     __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
     __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
     __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
     __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
     errno_t __cdecl _wdupenv_s_dbg(
            wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
     __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );
    
     
       
     __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
     __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
     __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 583 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

#line 585 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"





















     int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

     int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


     int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

     int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

     size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

     size_t __cdecl _CrtGetDebugFillThreshold(void);

     _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

     int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

         _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        
        
        
         _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

         int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

         int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"







































    

    
    
    
        





    #line 736 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    
        
    #line 740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    
        
    #line 744 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 766 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"













    
#line 781 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern   const streamoff _BADOFF;
  #line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { (void)( (!!(("_Count <= _Dest_size" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0, L"%ls", L"\"_Count <= _Dest_size\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"_Count <= _Dest_size", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((int_type)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

		
template<>
	struct char_traits<char16_t>
	: public _Char_traits<char16_t, unsigned short>
	{	
	};

typedef streampos u16streampos;

		
template<>
	struct char_traits<char32_t>
	: public _Char_traits<char32_t, unsigned int>
	{	
	};

typedef streampos u32streampos;

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(const int_type& _Meta)
		noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(const _Elem& _Ch)
		noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(const int_type& _Meta)
		noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};
 #line 503 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((unsigned char)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 








#line 674 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

 





















 










#line 748 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 754 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
#line 755 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _Ty> inline
	void swap(_Ty&, _Ty&)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);
#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		noexcept(noexcept(swap(*_Left, *_Right)))
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)
#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
	{	
	_Ty _Tmp = _Move(_Left);
	_Left = _Move(_Right);
	_Right = _Move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		noexcept(noexcept(swap(_Left, _Right)))
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

constexpr piecewise_construct_t piecewise_construct{};

		

template<class...>
	class tuple;


template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	constexpr pair()
		: first(), second()
		{	
		}

	constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
			&& is_convertible<const _Other2&, _Ty2>::value,
			void>::type>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}


	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);


	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1&&>::value && is_nothrow_constructible<_Ty2, _Other2&&>::value))
#line 143 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1&&>::value && is_nothrow_constructible<_Ty2, _Other2&&>::value))
#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))
#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	void swap(_Myt& _Right)
		noexcept(noexcept(_Swap_adl(this->first, _Right.first)) && noexcept(_Swap_adl(this->second, _Right.second)))
#line 182 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	_Ty1 first;	
	_Ty2 second;	
	};

		

template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	constexpr pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
template<class _Ty,
	size_t _Size>
	class array;

	
template<class _Tuple>
	struct tuple_size
	{	
	static_assert(_Always_false<_Tuple>::value,
		"The C++ Standard doesn't define tuple_size for this type.");
	};

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	: integral_constant<size_t, 2>
	{	
	};

template<class... _Types>
	struct tuple_size<tuple<_Types...> >
	: integral_constant<size_t, sizeof...(_Types)>
	{	
	};


template<class _Tuple>
	struct tuple_size<const _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

	
template<size_t _Index,
	class _Tuple>
	struct tuple_element
	{	
	static_assert(_Always_false<_Tuple>::value,
		"tuple_element index out of bounds");
	};

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size> >
	{	
	static_assert(_Idx < _Size, "array index out of bounds");

	typedef _Ty type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...> >
	{	
	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...> >
		: public tuple_element<_Index - 1, tuple<_Rest...> >
	{	
	};


template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	
template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) noexcept
	{	
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) noexcept
	{	
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		_Ctype;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
		get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<1>(::std:: move(_Pr)));
	}

	

template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	
	_Ty _Old_val = ::std:: move(_Val);
	_Val = ::std:: forward<_Other>(_New_val);
	return (_Old_val);
	}
}

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 550 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
#line 551 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 

  

  


typedef const wchar_t *_Dbfile_t;
typedef unsigned int _Dbline_t;

 void __cdecl _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);

 

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() noexcept
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		return (*this);
		}

	~_Iterator_base12() noexcept
		{	
 
		_Lockit _Lock(3);
		_Orphan_me();
 #line 145 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 
			if (_Myproxy != _Parent_proxy)
				{	
				_Lockit _Lock(3);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 

#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 
		if (_Myproxy != 0)
			{	
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_Debug_message(L"ITERATOR LIST CORRUPTED!", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 201);
			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #line 206 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 
	if (_Myproxy != 0)
		{	
		_Lockit _Lock(3);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #line 226 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 
	_Lockit _Lock(3);
 #line 233 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 



#line 249 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
typedef _Container_base12 _Container_base;
typedef _Iterator_base12 _Iterator_base;
 #line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	
struct _Zero_then_variadic_args_t
	{	
	};	

struct _One_then_variadic_args_t
	{	
	};	

template<class _Ty1,
	class _Ty2,
	bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
	class _Compressed_pair final
		: private _Ty1

	{	
private:
	_Ty2 _Myval2;

	typedef _Ty1 _Mybase;	

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (*this);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (*this);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (*this);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (*this);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final

	{	
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (_Myval1);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (_Myval1);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (_Myval1);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (_Myval1);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

		

		
 


		
template<class _Ty>
	struct _Get_unchecked_type
		{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 412 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _Ty,
	class = void>
	struct _Is_checked_helper
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_checked_helper<_Ty, typename _Param_tester<
		typename _Ty::_Unchecked_type>::type>
		: true_type
	{	
	};

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return (typename _Is_checked_helper<_Iter>::type());
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		
		
struct input_iterator_tag
	{	
	};

struct _Mutable_iterator_tag
	{	
	};

struct output_iterator_tag
	: _Mutable_iterator_tag
	{	
	};

struct forward_iterator_tag
	: input_iterator_tag, _Mutable_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	
	};

		
struct _Nonscalar_ptr_iterator_tag
	{	
	};
struct _Scalar_ptr_iterator_tag
	{	
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;

		
template<class,
	class = void>
	struct _Is_iterator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty, typename _Param_tester<
		typename _Ty::iterator_category,
		typename _Ty::value_type,
		typename _Ty::difference_type,
		typename _Ty::pointer,
		typename _Ty::reference
		>::type>
		: true_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty *>
		: true_type
	{	
	};

		
template<class _Iter,
	bool = _Is_iterator<_Iter>::value>
	struct _Iterator_traits_base
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;

	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, false>
	{	
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		
template<class _Iter1,
	class _Iter2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
	{	
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2>
	struct _Ptr_cat_helper
	{	
	typedef _Nonscalar_ptr_iterator_tag type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef typename _If<is_scalar<_Elem>::value,
		_Scalar_ptr_iterator_tag,
		_Nonscalar_ptr_iterator_tag>::type type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Scalar_ptr_iterator_tag type;
	};

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(_Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(const _Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

		

 











#line 669 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  
   
  #line 675 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 682 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 689 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 696 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 705 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 712 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 721 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


		
template<class _Pr,
	class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt_pred(_Pr _Pred,
		_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	return (!_Pred(_Left, _Right)
		? false
		: _Pred(_Right, _Left)
			? (_Debug_message(L"invalid comparator", _File, _Line), true)
			: true);
	}

		
template<class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt(_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	return (_Debug_lt_pred(less<>(),
		::std:: forward<_Ty1>(_Left), ::std:: forward<_Ty2>(_Right), _File, _Line));
	}

		
template<class _InIt> inline
	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer(_Ty *_Ptr, _Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_pointer_if(bool, _InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer_if(bool _Test, _Ty *_Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Test && _Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_range2(_InIt _First, _InIt _Last,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	bool _Ans = _First == _Last;	
	_Ans = _Ans;	
	}

template<class _RanIt> inline
	void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr2(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, input_iterator_tag)
	{	
	if (_First != _Last)
		_Debug_pointer(_Ptr, _File, _Line);	
	}

template<class _RanIt,
	class _Pty> inline
	void _Debug_range_ptr2(_RanIt _First, _RanIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		_Debug_pointer(_Ptr, _File, _Line);	
		}
	}

template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt,
	class _Pr> inline
	void _Debug_order2(_InIt, _InIt, _Pr,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 855))
			_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}
 #line 868 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
		

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 885);
 #line 887 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FwdIt,
	class _Diff> inline
	void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 898);
 #line 900 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	
 
	if (_First != _Last)
		{	
		_Debug_pointer(_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 974);
		_Debug_pointer(_Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 975);
		}
 #line 978 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	_FwdIt next(_FwdIt _First,
		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
	{	
	static_assert(is_base_of<forward_iterator_tag,
		typename iterator_traits<_FwdIt>::iterator_category>::value,
		"next requires forward iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First,
		typename iterator_traits<_BidIt>::difference_type _Off = 1)
	{	
	static_assert(is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value,
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{	
	typedef reverse_iterator<_RanIt> _Myt;

public:
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		: current()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

protected:
	_RanIt current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> operator+(
		typename reverse_iterator<_RanIt>::difference_type _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right.base() < _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
	{	
	return (reverse_iterator<_RanIt>(_Iter));
	}

		

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array + _Size);
	}

		
template<class _Container>
	constexpr auto inline cbegin(const _Container& _Cont)
		noexcept(noexcept(::std:: begin(_Cont)))
		-> decltype(::std:: begin(_Cont))
	{	
	return (::std:: begin(_Cont));
	}

template<class _Container>
	constexpr auto inline cend(const _Container& _Cont)
		noexcept(noexcept(::std:: end(_Cont)))
		-> decltype(::std:: end(_Cont))
	{	
	return (::std:: end(_Cont));
	}

		
template<class _Container>
	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Container>
	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rbegin(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rend(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		
template<class _Container>
	auto inline crbegin(const _Container& _Cont)
		-> decltype(::std:: rbegin(_Cont))
	{	
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	auto inline crend(const _Container& _Cont)
		-> decltype(::std:: rend(_Cont))
	{	
	return (::std:: rend(_Cont));
	}


template<class _Container>
	constexpr auto inline size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr size_t size(const _Ty(&)[_Size]) noexcept
	{	
	return (_Size);
	}

template<class _Container>
	constexpr auto inline empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr bool empty(const _Ty(&)[_Size]) noexcept
	{	
	return (false);
	}

template<class _Elem> inline
	constexpr bool empty(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.size() == 0);
	}

template<class _Container>
	constexpr auto inline data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Container>
	constexpr auto inline data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Elem> inline
	constexpr const _Elem *data(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
 




























































































































#line 1558 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	_Array_const_iterator()
		{	
		_Ptr = 0;
		_Idx = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	
		_Ptr = _Parg;
		_Idx = _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Idx = _Right - _Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr + _Idx);
		}

	reference operator*() const
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1589);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1590, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1590, 0); };
			}

 


#line 1597 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		;

		return (_Ptr[_Idx]);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1614);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1615, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1615, 0); };
			}

 


#line 1622 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		++_Idx;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (_Ptr == 0
			|| _Idx <= 0)
			{	
			_Debug_message(L"array iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1640);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1641, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1641, 0); };
			}

 


#line 1648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		--_Idx;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Size < _Idx + _Off)
			{	
			_Debug_message(L"array iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1665);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1666, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1666, 0); };
			}

 

#line 1672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Idx += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx
			? -(difference_type)(_Right._Idx - _Idx)
			: (difference_type)_Idx - _Right._Idx);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (_Ptr != _Right._Ptr)
			{	
			_Debug_message(L"array iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1744);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1745, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1745, 0); };
			}
		}

 




#line 1755 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	pointer _Ptr;	
	size_t _Idx;	
 #line 1759 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef value_type&& reference;
	typedef _RanIt iterator_type;

	move_iterator()
		: current()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (::std:: move(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Copy_impl(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2228);
	return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2245 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 2246 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	*_Dest = *_First;	
	while (0 < --_Count)
		*++_Dest = *++_First;
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 














#line 2317 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Mutable_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + _Count;	
	_Copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	return (_Copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	
	_InIt _Last = _First + _Count;	
	_Last = _Last;	
	return (_Copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, true_type)
	{	
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, false_type)
	{	
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	if (_Count <= 0)
		return (_Dest);
	else
		{	
		_Debug_pointer(_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2392);
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2393);
		return (_Copy_n(_First, _Count,
			_Dest, _Is_checked(_Dest)));
		}
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutIt _Dest)
	{	
	return (::std:: copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy_n(_First, _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2436 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 2437 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2481 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2505);
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #line 2510 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2554 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Move(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Move(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2598);
	return (_Move(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: move(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2615 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 2616 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2660 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2684);
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #line 2689 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt,
	class _Ty> inline
	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void _Fill(char *_First, char *_Last, char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2718);
	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
	signed char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
	unsigned char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

 








#line 2763 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		_Mutable_iterator_tag)
	{	
	return (_Fill_n(_Dest, _Count, _Val));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + _Count;	
	_Fill_n(_Unchecked(_Dest), _Count, _Val);
	return (_Ans);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		true_type)
	{	
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		false_type)
	{	
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	_Debug_pointer_if(0 < _Count, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2809);
	return (_Fill_n(_Dest, _Count, _Val,
		_Is_checked(_Dest)));
	}

 
template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Ty> inline
	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
	{	
	return (_Unchecked(::std:: fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
		_Count, _Val)));
	}
 #line 2825 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 2826 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

inline bool _Equal(const char *_First1, const char *_Last1,
	const char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
	const signed char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, equal_to<>)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

 










#line 2870 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, true_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, false_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2897);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2898);
	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Is_checked(_First2)));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (::std:: equal(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 2915 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 2916 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}
 #line 2938 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
			input_iterator_tag, input_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2948);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
			random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2965);
	return (_Equal(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2975);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2976);
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Iter_cat(_First1), _Iter_cat(_First2)));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: equal(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (_Debug_lt(*_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2999))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool _Lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
	}

 









#line 3027 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3033);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3034);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3048))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3062);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3063);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3064);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
	{	
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	
	return (_Val <= 127);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
	{	
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
	{	
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	
	typedef typename remove_pointer<_InIt>::type _Elem;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
	{	
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	
	typedef integral_constant<bool,
		(is_same<_InIt, char *>::value
		|| is_same<_InIt, signed char *>::value
		|| is_same<_InIt, unsigned char *>::value
		|| is_same<_InIt, const char *>::value
		|| is_same<_InIt, const signed char *>::value
		|| is_same<_InIt, const unsigned char *>::value)
		&& is_integral<_Ty>::value
	> _Memchr_opt;
	return (_Find(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3160);
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3196);
	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
		forward_iterator_tag, forward_iterator_tag)
	{	
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	
	
	while (_Pred(*--_Last1, *--_Last2))
		;	
	++_Last1;
	++_Last2;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat(_Last1), _Iter_cat(_Last2));
	typedef typename iterator_traits<_FwdIt1>::difference_type _Diff1;
	typedef typename iterator_traits<_FwdIt2>::difference_type _Diff2;
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	
			_Diff2 _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				return (false);	
			_FwdIt1 _Skip1 = ::std:: next(_Next1);
			_Diff1 _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				return (false);	
			}
	return (true);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			_FwdIt2 _Last2 = ::std:: next(_First2,
				::std:: distance(_First1, _Last1));
			return (_Check_match_counts(_First1, _Last1,
				_First2, _Last2, _Pred));
			}
	return (true);
	}

 










#line 3292 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation2(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred, true_type)
	{	
		
	return (_Is_permutation(_First1, _Last1,
		_First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	bool _Is_permutation2(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred, false_type)
	{	
		
	return (_Is_permutation(_First1, _Last1,
		_First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3321);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3322);
	return (_Is_permutation2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Is_checked(_First2)));
	}

 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 3339 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
 #line 3340 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
	}
 #line 3362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3372);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			if (::std:: distance(_First1, _Last1)
				!= ::std:: distance(_First2, _Last2))
				return (false);	
			else
				return (_Check_match_counts(_First1, _Last1,
					_First2, _Last2, _Pred));
			}
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3396);
	return (_Is_permutation(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
		
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3407);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3408);
	return (_Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, _Last2, equal_to<>()));
	}

		
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3435);
	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	_FwdIt _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	
			}
		else if (++_Next == _Last)
			{	
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	
	while (_First != _Sentinel && _Last != _Sentinel)
		::std:: iter_swap(_First++, --_Last);
	return (::std:: make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel(_First, _Mid, _Last);
	::std:: reverse(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	::std:: reverse(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3496);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3497);
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	_Rechecked(_First, _Rotate(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last), _Iter_cat(_First)));
	return (_First);
	}

	
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	
public:
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;


	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits - 1;	
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits - 1;	
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	
	};

		
template<class _Elem>
	class  _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 
				_Myptr = (_Elem *)_malloc_dbg(_Count, 2,
					"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3630);

 

#line 3635 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}
		return (*this);
		}

	 ~_Yarn() noexcept
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 
			_free_dbg(_Myptr, 2);

 

#line 3679 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

constexpr allocator_arg_t allocator_arg{};

 __declspec(noreturn) void __cdecl _Xbad_alloc();
 __declspec(noreturn) void __cdecl _Xinvalid_argument(  const char *);
 __declspec(noreturn) void __cdecl _Xlength_error(  const char *);
 __declspec(noreturn) void __cdecl _Xout_of_range(  const char *);
 __declspec(noreturn) void __cdecl _Xoverflow_error(  const char *);
 __declspec(noreturn) void __cdecl _Xruntime_error(  const char *);
}

namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};
}	
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3731 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
#line 3732 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"






#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 

  
   

  

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma warning(disable: 4100)

namespace std {



 


 

#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 

  


#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

  #line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 49 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty> inline
	__declspec(allocator) _Ty *_Allocate(size_t _Count, _Ty *,
		bool _Try_aligned_allocation = true)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		return (static_cast<_Ty *>(_Ptr));

	
	if ((size_t)(-1) / sizeof (_Ty) < _Count)
		_Xbad_alloc();	
	const size_t _User_size = _Count * sizeof (_Ty);

 
	if (_Try_aligned_allocation
		&& 4096 <= _User_size)
		{	
		static_assert(sizeof (void *) < 32,
			"Big allocations should at least match vector register size");
		const size_t _Block_size = (2 * sizeof(void *) + 32 - 1) + _User_size;
		if (_Block_size <= _User_size)
			_Xbad_alloc();	
		const uintptr_t _Ptr_container =
			reinterpret_cast<uintptr_t>(::operator new(_Block_size));
		{ if (!(_Ptr_container != 0)) { (void)( (!!(("_Ptr_container != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 76, 0, L"%ls", L"\"_Ptr_container != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 76, 0); } ; };
		_Ptr = reinterpret_cast<void *>((_Ptr_container + (2 * sizeof(void *) + 32 - 1))
			& ~(32 - 1));
		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

 
		static_cast<uintptr_t *>(_Ptr)[-2] = 0xFAFAFAFAUL;
 #line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		}
	else
 #line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{	
		_Ptr = ::operator new(_User_size);
		{ if (!(_Ptr != 0)) { (void)( (!!(("_Ptr != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 90, 0, L"%ls", L"\"_Ptr != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 90, 0); } ; };
		}
	return (static_cast<_Ty *>(_Ptr));
	}

		
template<class _Ty> inline
	void _Deallocate(_Ty * _Ptr, size_t _Count)
	{	
 
	{ if (!(_Count <= (size_t)(-1) / sizeof (_Ty))) { (void)( (!!(("_Count <= (size_t)(-1) / sizeof (_Ty)" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0, L"%ls", L"\"_Count <= (size_t)(-1) / sizeof (_Ty)\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0); } ; };
	const size_t _User_size = _Count * sizeof (_Ty);
	if (4096 <= _User_size)
		{	
		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
		{ if (!((_Ptr_user & (32 - 1)) == 0)) { (void)( (!!(("(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 106, 0, L"%ls", L"\"(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 106, 0); } ; };
#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
		const uintptr_t _Ptr_container =
			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

 
		
		
		{ if (!(reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == 0xFAFAFAFAUL)) { (void)( (!!(("reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 116, 0, L"%ls", L"\"reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 116, 0); } ; };
#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
		{ if (!(_Ptr_container < _Ptr_user)) { (void)( (!!(("_Ptr_container < _Ptr_user" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 120, 0, L"%ls", L"\"_Ptr_container < _Ptr_user\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 120, 0); } ; };

 
		{ if (!(2 * sizeof(void *) <= _Ptr_user - _Ptr_container)) { (void)( (!!(("2 * sizeof(void *) <= _Ptr_user - _Ptr_container" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 124, 0, L"%ls", L"\"2 * sizeof(void *) <= _Ptr_user - _Ptr_container\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 124, 0); } ; };
#line 125 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 


#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{ if (!(_Ptr_user - _Ptr_container <= (2 * sizeof(void *) + 32 - 1))) { (void)( (!!(("_Ptr_user - _Ptr_container <= _NON_USER_SIZE" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 132, 0, L"%ls", L"\"_Ptr_user - _Ptr_container <= _NON_USER_SIZE\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 132, 0); } ; };
#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		_Ptr = reinterpret_cast<_Ty *>(_Ptr_container);
		}
 #line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

	::operator delete(_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Ty> inline
	void _Destroy(_Ty *_Ptr)
	{	
	_Ptr->~_Ty();
	}

		
template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(::std:: addressof(*_First));
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al)
	{	
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...> >
	{	
	typedef _First type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
	{	
	typedef _Ty<_Newfirst, _Rest...> type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 271 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 278 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

	typedef typename _If<is_void<element_type>::value,
		char&,
		typename add_lvalue_reference<element_type>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		using rebind = _Other *;

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_lvalue_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};

		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 326 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 333 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 340 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 347 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 361 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 367 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 373 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 379 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_is_always_equal
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 385 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Alloc_construct
	{	
		

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
			_Types&&... _Args)
			-> decltype(
				_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
			_Types&&... _Args)
			-> void
		{	
		::new (static_cast<void *>(_Ptr))
			_Objty(::std:: forward<_Types>(_Args)...);
		}

	};

		
struct _Alloc_destroy
	{	
	template<class _Ty,
		class _Objty>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
			-> decltype(_Al.destroy(_Ptr))
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty,
		class _Objty>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
			-> void
		{	
		_Ptr->~_Objty();
		}
	};

		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al) noexcept
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&) noexcept
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;
	typedef typename _Get_is_always_equal<_Alloc>::type
		is_always_equal;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Alloc_construct::_Fn(0, _Al, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Alloc_destroy::_Fn(0, _Al, _Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};

		
template<class _Ty>
	class allocator
	{	
public:
	static_assert(!is_const<_Ty>::value,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef true_type propagate_on_container_move_assignment;
	typedef true_type is_always_equal;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	allocator() noexcept
		{	
		}

	allocator(const allocator<_Ty>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Deallocate(_Ptr, _Count);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Allocate(_Count, (pointer)0));
		}

	__declspec(allocator) pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		void construct(_Objty *_Ptr, _Types&&... _Args)
		{	
		::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const noexcept
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() noexcept
		{	
		}

	allocator(const allocator<void>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) noexcept
	{	
	return (false);
	}

		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef _Alloc allocator_type;
	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef true_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;
	typedef true_type is_always_equal;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc& _Al, _Objty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;
	typedef typename _Mytraits::is_always_equal
		is_always_equal;

	_Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other>
			_Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	_Wrap_alloc() noexcept
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Mybase& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(const _Other& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc& operator=(const _Mybase& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(const _Other& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	__declspec(allocator) pointer allocate(size_type _Count,
		const_void_pointer _Hint, _Nil = _Nil())
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		void construct(_Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Mytraits::construct(*this, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size(_Nil = _Nil()) const noexcept
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (static_cast<const _Ty&>(_Left)
		== static_cast<const _Other&>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
	{	
	_Left = _Right;
	}

template<class _Alty> inline
	void _Pocca(_Alty&, const _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Left = ::std:: move(_Right);
	}

template<class _Alty> inline
	void _Pocma(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Swap_adl(_Left, _Right);
	}

template<class _Alty> inline
	void _Pocs(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}
}

		

  
   #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  


#line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
   
  #line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  
  
  

		
inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
inline int _Atomic_compare_exchange_weak_4(
	volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
inline _Uint4_t _Atomic_fetch_add_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);
inline _Uint4_t _Atomic_fetch_sub_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);

typedef _Atomic_integral_t _Atomic_counter_t;

  
inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
	}

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
	}

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Load_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_load_4(&_Counter, _Order));
	}

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
	_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Expected,
	memory_order _Order)
	{	
	return (_Atomic_compare_exchange_weak_4(
		&_Counter, &_Expected, _Expected + 1,
		_Order, _Order));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter(
	_Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
	{	
	return (_Compare_increment_atomic_counter_explicit(
		_Counter, _Expected, memory_order_seq_cst));
	}

  






























#line 160 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		
extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
#line 172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"





#line 1015 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
   #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"












#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"









__pragma(pack(push, 8)) extern "C" {






    
    

    typedef struct __JUMP_BUFFER
    {
        unsigned long Ebp;
        unsigned long Ebx;
        unsigned long Edi;
        unsigned long Esi;
        unsigned long Esp;
        unsigned long Eip;
        unsigned long Registration;
        unsigned long TryLevel;
        unsigned long Cookie;
        unsigned long UnwindFunc;
        unsigned long UnwindData[6];
    } _JUMP_BUFFER;





























































































#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"





    
    typedef int jmp_buf[16];
#line 147 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




    
#line 153 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    #pragma warning(push)
    #pragma warning(disable:4987) 
    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) throw(...);
    #pragma warning(pop)





#line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"


} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"



    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"













#pragma once



#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"










#pragma once



#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"







#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




















#pragma once



#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"







#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"



#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"



























#pragma once



#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"














#pragma once






#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"



#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"


extern "C" { 


#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;


void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);




























































}; 
#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

#line 189 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;




#line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 82 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 












































































 
 
 


extern "C" { 
  
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);








#line 285 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);





extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);






























 
 
 

 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _m_pcmpgtw(_mm_setzero_si64(), _A);

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _mm_setzero_si64();

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 _A)
{
  return _m_packssdw(_mm_cvt_ps2pi(_A),
                        _mm_cvt_ps2pi(_mm_movehl_ps(_A, _A)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 _A)
{
  __m64  _Ext_val = _m_pcmpgtb(_mm_setzero_si64(), _A);

  return _mm_cvtpi16_ps(_m_punpcklbw(_A, _Ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 _A)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(_A, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 _A)
{
  return _m_packsswb(_mm_cvtps_pi16(_A), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), _A),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), _B));
}



}; 
#line 497 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

#line 499 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 500 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 501 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);





extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);













#line 416 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"


}; 
#line 420 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

#line 422 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 423 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 424 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 35 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 106 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"









extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);

    extern __m64 _mm_hadd_pi16 (__m64, __m64);
    extern __m64 _mm_hadd_pi32 (__m64, __m64);
    extern __m64 _mm_hadds_pi16 (__m64, __m64);

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);

    extern __m64 _mm_hsub_pi16 (__m64, __m64);
    extern __m64 _mm_hsub_pi32 (__m64, __m64);
    extern __m64 _mm_hsubs_pi16 (__m64, __m64);

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);

    extern __m64 _mm_maddubs_pi16 (__m64, __m64);

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);

    extern __m64 _mm_mulhrs_pi16 (__m64, __m64);

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);

    extern __m64 _mm_shuffle_pi8 (__m64, __m64);

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);

    extern __m64 _mm_sign_pi8 (__m64, __m64);
    extern __m64 _mm_sign_pi16 (__m64, __m64);
    extern __m64 _mm_sign_pi32 (__m64, __m64);

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);

    extern __m64 _mm_alignr_pi8 (__m64, __m64, int);

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);

    extern __m64 _mm_abs_pi8 (__m64);
    extern __m64 _mm_abs_pi16 (__m64);
    extern __m64 _mm_abs_pi32 (__m64);


};
#line 128 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 132 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"


















































extern "C" {
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );



#line 194 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );



#line 203 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        



        extern __m128i _mm_stream_load_si128(__m128i*);


}; 
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 260 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 261 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 262 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"



extern "C" {
#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );



#line 121 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );



#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"


}; 
#line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 141 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"



extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 92 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"


extern "C" {
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);


#line 1221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);


#line 1231 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);


#line 1240 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);


#line 1250 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);


#line 1260 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);


#line 1270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);


#line 1279 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);


#line 1288 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);


#line 1300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

















#line 1318 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );





extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );

























#line 1838 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);


#line 1850 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);


#line 1862 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);




















#line 1921 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
extern int __cdecl _rdseed64_step(unsigned __int64 *);










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );




extern __m128i _mm_sha1rnds4_epu32(__m128i, __m128i, const int);
extern __m128i _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);
extern __m128i _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i _mm_sha256msg2_epu32(__m128i, __m128i);






#line 1979 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




extern void * _bnd_set_ptr_bounds(const void *, size_t);
extern void * _bnd_init_ptr_bounds(const void *);
extern void * _bnd_copy_ptr_bounds(const void *, const void *);
extern void _bnd_chk_ptr_bounds(const void *, size_t);
extern void _bnd_chk_ptr_lbounds(const void *);
extern void _bnd_chk_ptr_ubounds(const void *);
extern void _bnd_store_ptr_bounds(const void **, const void *);
extern void * _bnd_load_ptr_bounds(const void **, const void *);
extern const void * _bnd_get_ptr_lbound(const void *);
extern const void * _bnd_get_ptr_ubound(const void *);
extern void * _bnd_narrow_ptr_bounds(const void *, const void *, size_t);


}; 
#line 1998 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 2000 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2001 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2002 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"












#pragma once



#line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"







#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"



#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


extern "C" { 
#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);



#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);








#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);











#line 300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}; 
#line 307 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

#line 309 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 310 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 311 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"















#pragma once



#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"







#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"




extern "C" { 
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"



void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


}; 
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


extern "C" {
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




























#line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"






#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 100 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 122 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);


unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);





















long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);









char _InterlockedAnd8(char volatile * _Value, char _Mask);








long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);






short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);








long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);










long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);






long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);










long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);









char _InterlockedOr8(char volatile * _Value, char _Mask);








long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);









char _InterlockedXor8(char volatile * _Value, char _Mask);
















void _ReadBarrier(void);






void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);






void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);








void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);








unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);





unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);







unsigned char _interlockedbittestandset(long volatile *, long);

















  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
void _mm_pcommit(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);
__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);
__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(__m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);


void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}
#line 1134 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1136 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 1016 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

   

   


  






#line 1030 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1035 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1036 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		{	
		this->_Ptr = 0;
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		{	
		this->_Adopt(_Pstring);
		this->_Ptr = _Parg;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
			{	
			_Debug_message(L"string iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 75);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 76, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 76, 0); };
			}

 





#line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
			{	
			_Debug_message(L"string iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 105);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 106, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 106, 0); };
			}

 




#line 115 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
			{	
			_Debug_message(L"string iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 134);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 135, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 135, 0); };
			}

 



#line 143 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
			{	
			_Debug_message(L"string iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 164);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 165, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 165, 0); };
			}

 





#line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"string iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 247);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 248, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 248, 0); };
			}
		}

 










#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		{	
		_Mysize = 0;
		_Myres = 0;
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	union _Bxty
		{	
		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<class _Alloc_types>
	class _String_alloc
	{	
public:
	typedef _String_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_String_val<_Val_types> > iterator;
	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;

	enum
		{	
		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
		};

	enum
		{	
		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
		};

	value_type *_Myptr()
		{	
		return (_Get_data()._Myptr());
		}

	const value_type *_Myptr() const
		{	
		return (_Get_data()._Myptr());
		}

 

























#line 596 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
	_String_alloc(const _Alloc& _Al = _Alloc())
		: _Mypair(_One_then_variadic_args_t(), _Al)
		{	
		_Alloc_proxy();
		}

	_String_alloc(_Alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(), ::std:: move(_Al))
		{	
		_Alloc_proxy();
		}

	~_String_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Pocs(_Getal(), _Right._Getal());
		_Swap_adl(_Myproxy(), _Right._Myproxy());
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Alproxy.allocate(1);
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Myproxy(), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 667 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_String_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _String_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	typedef typename _String_val<_Val_types>::_Bxty _Bxty;

	_Bxty& _Bx() noexcept
		{	
		return (_Get_data()._Bx);
		}

	const _Bxty& _Bx() const noexcept
		{	
		return (_Get_data()._Bx);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

	size_type& _Myres() noexcept
		{	
		return (_Get_data()._Myres);
		}

	const size_type& _Myres() const noexcept
		{	
		return (_Get_data()._Myres);
		}

private:
	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string() noexcept
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 856);
		_Tidy();
		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem *_First,
		_Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	void _Construct(const _Elem *_First,
		const _Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 917 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) noexcept
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres())
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres() < this->_BUF_SIZE)
			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
				_Right._Mysize() + 1);
		else
			{	
			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
			_Right._Bx()._Ptr = pointer();
			}
		this->_Mysize() = _Right._Mysize();
		this->_Myres() = _Right._Myres();
		_Right._Tidy();
		}

	basic_string(::std:: initializer_list<_Elem> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& assign(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& append(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
		}

	~basic_string() noexcept
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Copy_alloc(_Right._Getal());
				}

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1079);
		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1097);
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Chassign(this->_Mysize(), _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
		else if (_Grow(_Num))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1160);
		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1175);
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
		{	
		if (this->_Mysize() < _Off || _Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1246);
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1268);
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize() - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Where - begin();
		erase(_Count, 1);
		return (begin() + _Count);
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1369);
		size_type _Count = _First - begin();
		erase(_Count, _Last - _First);
		return (begin() + _Count);
		}

	void clear() noexcept
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff,
			size_type _Count = npos)
		{	
		if (this->_Mysize() < _Off || _Right.size() < _Roff)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	

		size_type _Nm = this->_Mysize() - _N0 - _Off;	
		size_type _Newsize = this->_Mysize() + _Count - _N0;
		if (this->_Mysize() < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count <= _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1451);
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1483);
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(_First - begin(), _Last - _First, _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myptr(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myptr(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	reference at(size_type _Off)
		{	
		if (this->_Mysize() <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		if (this->_Mysize() <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1681);

 

#line 1686 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1694);

 

#line 1699 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		insert(end(), _Ch);
		}

	void pop_back()
		{	
		erase(this->_Mysize() - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	const _Elem *c_str() const noexcept
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const noexcept
		{	
		return (c_str());
		}

	size_type length() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize())
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize(), _Ch);
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myres());
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
			{	
			size_type _Size = this->_Mysize();
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const noexcept
		{	
		return (this->_Mysize() == 0);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))

	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1797);
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _Count)
			_Count = this->_Mysize() - _Off;
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1809);
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _Count)
			_Count = this->_Mysize() - _Off;
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres())
			if (this->_BUF_SIZE <= _Right._Myres())
				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx()._Ptr;
				this->_Getal().destroy(&this->_Bx()._Ptr);
				_Traits::copy(this->_Bx()._Buf,
					_Right._Bx()._Buf, _Right._Mysize() + 1);
				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
				}
		else
			if (_Right._Myres() < this->_BUF_SIZE)
				::std:: swap(this->_Bx()._Buf, _Right._Bx()._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx()._Ptr;
				this->_Getal().destroy(&_Right._Bx()._Ptr);
				_Traits::copy(_Right._Bx()._Buf,
					this->_Bx()._Buf, this->_Mysize() + 1);
				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
				}
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1847 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
				
			this->_Swap_alloc(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Bx(), _Right._Bx());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}

		else
			{	
			_Myt _Tmp = *this;

			*this = _Right;
			_Right = _Tmp;
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1885);
		if (_Count == 0 && _Off <= this->_Mysize())
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1905);
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1922);
		if (_Count == 0)
			return (_Off < this->_Mysize() ? _Off
				: this->_Mysize());	
		if (_Count <= this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize() - _Count ? _Off
					: this->_Mysize() - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1944);
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1962);
		if (0 < _Count && _Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1978);
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1997);
		if (0 < _Count && 0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2015);
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2035);
		if (_Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2050);
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2069);
		if (0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2086);
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	int compare(const _Myt& _Right) const noexcept
		{	
		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count = npos) const
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		if (_Right._Mysize() - _Roff < _Count)
			_Count = _Right._Mysize() - _Roff;	
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2125);
		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2131);
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2138);
		if (this->_Mysize() < _Off)
			_Xran();	
		if (this->_Mysize() - _Off < _N0)
			_N0 = this->_Mysize() - _Off;	

		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
			_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const noexcept
		{	
		return (this->_Getal());
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres() / 2 <= _Newres / 3)
			;
		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
			_Newres = this->_Myres()
				+ this->_Myres() / 2;	
		else
			_Newres = max_size();	

		_Elem *_Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
		this->_Myres() = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres() < _Newsize)
			_Copy(_Newsize, this->_Mysize());	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == 0 || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize() <= _Ptr)
			return (false);	
		else
			return (true);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres())
			{	
			pointer _Ptr = this->_Bx()._Ptr;
			this->_Getal().destroy(&this->_Bx()._Ptr);
			if (0 < _Newsize)
				_Traits::copy(this->_Bx()._Buf,
					::std:: addressof(*_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
			}
		this->_Myres() = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
		size_type;
	return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2633 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
#line 2634 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {










		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 106 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 134 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 162 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 218 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 246 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 274 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 280 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 281 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"














#pragma once







#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"


#pragma pack(push, 8)






#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610) 
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const  _DecoratedName[1];
};
#pragma warning(pop)

 int __cdecl __std_type_info_compare(
      __std_type_info_data const* _Lhs,
      __std_type_info_data const* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      __std_type_info_data const* _Data
    );

 char const* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))



class type_info
{
public: 

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    }

    char const* raw_name() const
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    mutable __std_type_info_data _Data;
};



namespace std {

using ::type_info;

class bad_cast
    : public exception
{
public:

    bad_cast()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message)
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int)
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message)
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int)
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message)
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int)
        : bad_typeid(_Message, 1)
    {
    }
};

} 

#line 185 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#line 186 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"

 























































#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)
#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"
#line 94 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"







#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {









   int __cdecl _isctype(  int _C,   int _Type);
   int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
    int __cdecl isalpha(  int _C);
   int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
    int __cdecl isupper(  int _C);
   int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
    int __cdecl islower(  int _C);
   int __cdecl _islower_l(  int _C,   _locale_t _Locale);


    int __cdecl isdigit(  int _C);

   int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
   int __cdecl isxdigit(  int _C);
   int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


    int __cdecl isspace(  int _C);

   int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
   int __cdecl ispunct(  int _C);
   int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
   int __cdecl isblank(  int _C);
   int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
    int __cdecl isalnum(  int _C);
   int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
   int __cdecl isprint(  int _C);
   int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
   int __cdecl isgraph(  int _C);
   int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
   int __cdecl iscntrl(  int _C);
   int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


    int __cdecl toupper(  int _C);


    int __cdecl tolower(  int _C);

    int __cdecl _tolower(  int _C);
   int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
    int __cdecl _toupper(  int _C);
   int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

   int __cdecl __isascii(  int _C);
   int __cdecl __toascii(  int _C);
   int __cdecl __iscsymf(  int _C);
   int __cdecl __iscsym(  int _C);









 
    
    
    






















    
    
    
         int __cdecl _chvalidator(  int _Ch,   int _Mask);
        
    

#line 115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



    
    
    
    
    
    
    
    



    












#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    
     int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    #line 153 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"

    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        
        return _chvalidator_l(_Locale, _C, _Mask);
        






#line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 221 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



    
    
    
    
    
#line 230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\locale.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};





















 void __cdecl _lock_locales(void);
 void __cdecl _unlock_locales(void);


 int __cdecl _configthreadlocale(
      int _Flag
    );


 char* __cdecl setlocale(
            int         _Category,
      char const* _Locale
    );


 struct lconv* __cdecl localeconv(void);


 _locale_t __cdecl _get_current_locale(void);


 _locale_t __cdecl _create_locale(
        int         _Category,
      char const* _Locale
    );

 void __cdecl _free_locale(
      _locale_t _Locale
    );



 wchar_t* __cdecl _wsetlocale(
            int            _Category,
      wchar_t const* _Locale
    );


 _locale_t __cdecl _wcreate_locale(
        int            _Category,
      wchar_t const* _Locale
    );



 wchar_t**    __cdecl ___lc_locale_name_func(void);
 unsigned int __cdecl ___lc_codepage_func   (void);
 unsigned int __cdecl ___lc_collate_cp_func (void);



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 
  
extern "C" {
  #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
 _Collvec __cdecl _Getcoll(void);
 _Ctypevec __cdecl _Getctype(void);
 _Cvtvec __cdecl _Getcvt(void);
 int __cdecl _Getdateorder(void);

 








 int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

 float __cdecl _Stof(const char *,
	    char **, long);
 double __cdecl _Stod(const char *,
	    char **, long);
 long double __cdecl _Stold(const char *,
	    char **, long);

 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
 size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
 int __cdecl _Tolower(int, const _Ctypevec *);
 int __cdecl _Toupper(int, const _Ctypevec *);
 int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
 size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
 const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

 
  
}
  #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"


extern "C" {
 char *__cdecl _Getdays(void);
 char *__cdecl _Getmonths(void);
 void *__cdecl _Gettnames(void);
 size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,     const char *,
	  const struct tm *, void *);

 wchar_t *__cdecl _W_Getdays(void);
 wchar_t *__cdecl _W_Getmonths(void);
 void *__cdecl _W_Gettnames(void);
 size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,     const wchar_t *,
	  const struct tm *, void *);
}

 







 _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 158 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 163 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 164 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class  _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() noexcept
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class  _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() noexcept
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	
 #line 227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
#line 302 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class  _Facet_base
	{	
public:
	virtual  ~_Facet_base() noexcept
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

 



#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

struct  _Crt_new_delete
	{	
  
	void * __cdecl operator new(size_t _Size)
		{	
		void * _Ptr = operator new(_Size, nothrow);
		if (!_Ptr)
			_Xbad_alloc();
		return (_Ptr);
		}

	void * __cdecl operator new(size_t _Size, const nothrow_t&) noexcept
		{	
		return (_malloc_dbg(_Size > 0 ? _Size : 1, 2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 74));
		}

	void __cdecl operator delete(void * _Ptr) noexcept
		{	
		:: free(_Ptr);
		}

	void __cdecl operator delete(void * _Ptr, const nothrow_t&) noexcept
		{	
		operator delete(_Ptr);
		}

	void * __cdecl operator new(size_t, void *_Ptr) noexcept
		{	
		return (_Ptr);
		}

	void __cdecl operator delete(void *, void *) noexcept
		{	
		}
  #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	
public:
	typedef int category;

			
	class  id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			
	class  facet
		: public _Facet_base, public _Crt_new_delete
		{	
	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

		virtual void  _Incref()
			{	
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
			}

		virtual _Facet_base * _Decref()
			{	
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Myrefs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() noexcept
			{	
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class  _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() noexcept
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 237 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet< ::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 323 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	locale(const locale& _Right) noexcept
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() noexcept
		: _Ptr(_Init(true))
		{	
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj;
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj(_Cat, _Str.c_str());
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}

		if (_Bad)
			{	
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		_Construct(_Str, _Cat);
		}
 #line 428 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	~locale() noexcept
		{	
		if (_Ptr != 0)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) noexcept
		{	
		if (_Ptr != _Right._Ptr)
			{	
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 446 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static  const locale& __cdecl
		classic();	

	static  locale __cdecl
		global(const locale&);	

	static  locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

	static  _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static  _Locimp *__cdecl
		_Getgloballocale();
	static  void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 534 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 559 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 579 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 592 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			_Facet_Register(_Pfmod);
 #line 594 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 599 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 678 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 711 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 723);

	if (!_Ptrdest)
		_Xbad_alloc();

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 756);

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 796);

	if (!_Ptrdest)
		_Xbad_alloc();

	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 811 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class  codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const noexcept
		{	
		return (do_always_noconv());
		}

	int  max_length() const noexcept
		{	
		return (do_max_length());
		}

	int  encoding() const noexcept
		{	
		return (do_encoding());
		}

	 ~codecvt_base() noexcept
		{	
		}

protected:
	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (1);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

		
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		
template<>
	class  codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate <= 1)
				;	
			else if (_By < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				{	
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			_Nskip = _Nextra < 3 ? 0 : 1;	
			_First1 = _Mid1;	

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				break;	
			else
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);
			if (0 < _Nskip)
				_Ch <<= 6;	

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				return (_Mybase::error);	
			else if (0xffff < _Ch)
				{	
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip == 0)
				;
			else if (_Mid1 == _Last1)
				{	
				_Mid1 = _First1;
				break;
				}
			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				_Ch |= _By & 0x3f;	

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned long _Ch;
			unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	
				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	
				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
				_Save = true;	
				}
			else
				_Ch = _Ch1;	

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x10000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				break;	
			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
				;	
			else if (_Last2 - _Mid2 < 3 + _Nput)
				break;	
			else
				{	
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	
				*_Mid2++ = _By;
				--_Nput;
				}
			for (; 0 < _Nput; --_Nput)
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		for (; _Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & _Consume_header) != 0 ? 9	
			: (_Mode & _Generate_header) != 0 ? 7	
			: 6);	
		}

	virtual int do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class  codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1)
				break;	
			else
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				return (_Mybase::error);	
			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x00010000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else if (_Ch < 0x00200000)
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
			else if (_Ch < 0x04000000)
				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
			else
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;
				if ((_Mode & _Generate_header) == 0)
					;
				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
					return (_Mybase::partial);	
				else
					{	
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				break;	

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		_Mid2 = _First2;
		return (_Mybase::ok);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		int _Wchars = 0;
		_Statype _Mystate = _State;

		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (int)(_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int  do_encoding() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class  codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1674);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1675);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1710);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1711);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1747);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1772);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class  codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1908);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1909);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1944);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1945);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1981);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2006);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2060 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname() noexcept
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct  ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
		cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
		lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
		punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
		xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() noexcept
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2235);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2244);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2253);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2271);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2293);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2311);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2336);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class  ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2370);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2379);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2388);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const noexcept
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() noexcept
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() noexcept
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			:: free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;

		:: free(_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2518);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2532);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2546);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2559);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class  ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2692);
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2699);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2708);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2722);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2736);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2758);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2780);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class  ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2916);
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2924);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2933);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2947);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2961);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2983);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 3005);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3016 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

 




#line 3067 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3072 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 3073 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"

#pragma once











 
#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"




#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"
#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 




namespace std {
		

enum class errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};

typedef errc _Errc;

		

enum class io_errc {	
	stream = 1
	};

typedef io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<_Errc>
		: public true_type
	{	
	};

class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;

		
class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
	{	
public:
	 error_category() noexcept	
		{	
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() noexcept
		{	
		}

	virtual const char *name() const noexcept = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const noexcept;

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const noexcept;

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const noexcept;

	bool operator==(const error_category& _Right) const noexcept
		{	
		return (_Addr == _Right._Addr);
		}

	bool operator!=(const error_category& _Right) const noexcept
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const noexcept
		{	
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code() noexcept
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_code_enum<_Enum>::value,
			void>::type>
		error_code(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const noexcept;

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() noexcept
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_condition_enum<_Enum>::value,
			void>::type>
		error_condition(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline bool operator==(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
inline bool operator<(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

inline bool operator<(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		
inline error_condition
	error_category::default_error_condition(int _Errval) const noexcept
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const noexcept
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const noexcept
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const noexcept
	{	
	return (category().default_error_condition(value()));
	}

		
inline error_code make_error_code(_Errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(_Errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
	{	
	typedef error_code argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class _System_error
	: public runtime_error
	{	
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	
		if (!_Message.empty())
			_Message.append(": ");
		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
		{	
		}

	error_code _Mycode;	
	};

class system_error
	: public _System_error
	{	
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	const error_code& code() const noexcept
		{	
		return (_Mycode);
		}

 

 





#line 572 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
	};

 const char *__cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);
 unsigned long __cdecl _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category() noexcept
		{	
		_Addr = _Generic_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		return (_Syserror_map(_Errcode));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category() noexcept
		{	
		_Addr = _Iostream_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public error_category
	{	
public:
	_System_error_category() noexcept
		{	
		_Addr = _System_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(
			static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

		if (_Val == 0)
			return ("unknown error");

		_Narrow.resize(_Val);
		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	virtual error_condition
		default_error_condition(int _Errval) const noexcept
		{	
		int _Posv = _Winerror_map(_Errval);

		if (_Posv != 0)
			return (error_condition(_Posv, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Ty>
	struct _Immortalizer
	{	
	_Immortalizer()
		{	
		::new (static_cast<void *>(&_Storage)) _Ty();
		}

	~_Immortalizer() noexcept
		{	
		}

	_Immortalizer(const _Immortalizer&) = delete;
	_Immortalizer& operator=(const _Immortalizer&) = delete;

	typename aligned_union<1, _Ty>::type _Storage;
	};

template<class _Ty> inline
	_Ty& _Immortalize()
	{	
	static _Immortalizer<_Ty> _Static;
	return (*reinterpret_cast<_Ty *>(&_Static._Storage));
	}

inline const error_category& generic_category() noexcept
	{	
	return (_Immortalize<_Generic_error_category>());
	}

inline const error_category& iostream_category() noexcept
	{	
	return (_Immortalize<_Iostream_error_category>());
	}

inline const error_category& system_category() noexcept
	{	
	return (_Immortalize<_System_error_category>());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 711 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
#line 712 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\share.h"







#pragma once



#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
	static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
	static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
	static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
	static constexpr _Fmtflags left = (_Fmtflags)0x0040;
	static constexpr _Fmtflags right = (_Fmtflags)0x0080;
	static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
	static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
	static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
	static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
	static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
	static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)0x40;
	static constexpr _Openmode _Noreplace = (_Openmode)0x80;
	static constexpr _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class  ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;

			
	class failure

		: public system_error
		{	
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}


 

 





#line 246 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
		};

			
	class  Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() noexcept
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	
		return (!fail());
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() noexcept	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			
	struct _Iosarray
		: public _Crt_new_delete
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		: public _Crt_new_delete
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 647 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
#line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() noexcept
		{	
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 










#line 476 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()
		{	
		}

	istreambuf_iterator(istream_type& _Istr) noexcept
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem operator*() const
		{	
		if (!_Got)
			_Peek();

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 511);
 #line 513 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 526);
 #line 528 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) noexcept
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) noexcept
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const noexcept
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 676 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"
#line 677 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

extern  float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern  double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern  long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern  long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern  unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern  __int64 __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern  unsigned __int64 __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

namespace std {

template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 67);

	if (!_Ptrdest)
		_Xbad_alloc();
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	  static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() noexcept
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 178 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		:: free((void *)_Grouping);
		:: free((void *)_Falsename);
		:: free((void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname() noexcept
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

 
	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
 #line 360 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 394);
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 431);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 454);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 476);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 496);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

 
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 517);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const __int64 _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 537);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned __int64 _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}
 #line 553 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 558);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		float _Ans = :: _Stofx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 582);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		double _Ans = :: _Stodx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 606);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		long double _Ans = :: _Stoldx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 630);
		char _Ac[32], *_Ep;
		int _Errno = 0;

 
		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

 



#line 647 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		char *_Leading = _Ptr;	
		*_Ptr++ = '0';	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					{	
					++_Pten;
					if (0 < _Idx)
						_Sticky = true;
					}
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						{	
						++_Pten;
						if (0 < _Idx)
							_Sticky = true;
						}
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	

		if (_Sticky)
			{	
			char *_Px = _Ptr;
			for (; --_Px != _Leading; )
				{	
				if (*_Px == localeconv()->decimal_point[0])
					;	
				else if (*_Px != '9')
					{	
					++*_Px;
					break;
					}
				else
					*_Px = '0';	
				}

			if (_Px == _Leading)
				{	
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				|| *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

 
	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
 #line 1196 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1219);
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

 
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}
 #line 1287 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabs(_Val))
			{	
			int _Ptwo;
			(void):: frexp(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabsl(_Val))
			{	
			int _Ptwo;
			(void):: frexpl(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1379);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1481);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 






















#line 1584 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1589 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
#line 1590 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() noexcept
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) noexcept
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

public:
	 basic_ios(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;
	};

 












#line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

namespace tr1 {	
using ::std:: hexfloat;
}	

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"
#line 363 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_ostream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() noexcept
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 198);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 204);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 211);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator<<(__int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned __int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 416 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 564);
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	

	

  

















































 












#line 689 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1032 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
#line 1033 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"





#line 56 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4700)

namespace std {
		
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t>

		get_temporary_buffer(ptrdiff_t _Count) noexcept

	{	
	_Ty *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count))
		_Xbad_alloc();	
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	_Construct(::std:: addressof(*_Dest),
		*_First);	
	while (0 < --_Count)
		_Construct(::std:: addressof(*++_Dest), *++_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(::std:: addressof(*_Next));
	throw;
	}
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, forward_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		_Construct(::std:: addressof(*_Dest), *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(::std:: addressof(*_Next));
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 














#line 132 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Mutable_iterator_tag)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	
	_FwdIt _Ans = _Dest + _Count;	
	_Uninitialized_copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	
	return (_Uninitialized_copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	
	_InIt _Last = _First + _Count;	
	_Last = _Last;	
	return (_Uninitialized_copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, true_type)
	{	
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, false_type)
	{	
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	if (_Count <= 0)
		return (_Dest);
	else
		{	
		_Debug_pointer(_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 207);
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 208);
		return (_Uninitialized_copy_n(_First,
			_Count, _Dest, _Is_checked(_Dest)));
		}
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	
	return (::std:: uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
		_Count, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy_n(_First,
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 251 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
 #line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Construct(::std:: addressof(*_Dest), *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(::std:: addressof(*_Next));
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 304 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_FwdIt _Ans = _Dest + (_Last - _First);	
	_Uninitialized_copy0(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, true_type)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, false_type)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 348);
	return (_Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 365 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
 #line 366 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 374);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_copy(_First, _Last, _Dest,
		_Al, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 403);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Rechecked(_Dest,
		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 438);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Dest, (_Valty&&)*_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_move(_First, _Last, _Dest,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2,
	class _Valty> inline
	_Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 469);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_move(_First, _Last, _Dest, _Al,
		_Val_type(_First), _Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Rechecked(_Dest,
		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 502);
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(::std:: addressof(*_First), _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(::std:: addressof(*_Next));
	throw;
	}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	::std:: fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
 


 #line 541 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Construct(::std:: addressof(*_First), _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(::std:: addressof(*_Next));
	throw;
	}

	return (_First);
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	_Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	return (_Fill_n(_First, _Count, _Val));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	
	return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


 #line 588 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Al.construct(_First, *_Pval);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_fill_n(_First, _Count,
		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Tval,
	class _Valty> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, *_Pval);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al)
	{	
	_Uninit_fill_n(_First, _Count, _Pval, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


 #line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)

		_Al.construct(_First);

	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_def_fill_n(_First, _Count,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Valty> inline
	void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
		_Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, (_Valty)0);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		_Alloc& _Al)
	{	
	_Uninit_def_fill_n(_First, _Count, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _OutIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator<_OutIt, _Ty>& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
		{	
		_Construct(::std:: addressof(*_Next), _Val);
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty> operator++(int)
		{	
		raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

	_OutIt base() const
		{	
		return (_Next);
		}

private:
	_OutIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator() noexcept
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(_Ty&& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				::std:: forward<_Ty>(_Val);	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, ::std:: forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =

				::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

 
		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	
		}

	_Ty *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) noexcept
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(_Myt& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() noexcept
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() noexcept
		{	
		_Other *_Cvtptr = _Myptr;	
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	_Myt& operator=(_Myt& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr() noexcept
		{	
		delete _Myptr;
		}

	_Ty& operator*() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 958);
 #line 960 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (*get());
		}

	_Ty *operator->() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 968);
 #line 970 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (get());
		}

	_Ty *get() const noexcept
		{	
		return (_Myptr);
		}

	_Ty *release() noexcept
		{	
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	
	};
 #line 997 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1003 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
#line 1004 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
 #pragma warning(disable: 4244)

namespace std {
 

		
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Myvec::value_type,
			typename _Myvec::difference_type,
			typename _Myvec::const_pointer,
			typename _Myvec::const_reference,
			_Iterator_base>
	{	
public:
	typedef _Vector_const_iterator<_Myvec> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::const_pointer pointer;
	typedef typename _Myvec::const_reference reference;
	typedef typename _Myvec::pointer _Tptr;

	_Vector_const_iterator()
		: _Ptr()
		{	
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pvector);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = (_Tptr)_Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
			{	
			_Debug_message(L"vector iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 72);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 73, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 73, 0); };
			}

 





#line 83 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
			{	
			_Debug_message(L"vector iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 101);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 102, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 102, 0); };
			}

 




#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
			{	
			_Debug_message(L"vector iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 130);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 131, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 131, 0); };
			}

 




#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
			{	
			_Debug_message(L"vector iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 159);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 160, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 160, 0); };
			}

 




#line 169 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"vector iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 241);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 242, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 242, 0); };
			}
		}

 










#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	_Tptr _Ptr;	
	};

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>&
		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
			typename _Vector_const_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;

	_Vector_iterator()
		{	
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>&
		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
			typename _Vector_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _Vec_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Vec_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_Vec_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	
public:
	typedef _Vector_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Myt> iterator;
	typedef _Vector_const_iterator<_Myt> const_iterator;

	_Vector_val()
		{	
		_Myfirst = pointer();
		_Mylast = pointer();
		_Myend = pointer();
		}

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

		
template<class _Alloc_types>
	class _Vector_alloc
	{	
public:
	typedef _Vector_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;

 

























#line 538 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	_Vector_alloc(const _Alloc& _Al = _Alloc())
		: _Mypair(_One_then_variadic_args_t(), _Al)
		{	
		_Alloc_proxy();
		}

	_Vector_alloc(_Alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(), ::std:: move(_Al))
		{	
		_Alloc_proxy();
		}

	~_Vector_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Pocs(_Getal(), _Right._Getal());
		_Swap_adl(_Myproxy(), _Right._Myproxy());
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Alproxy.allocate(1);
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Myproxy(), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 609 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_Vector_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _Vector_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	pointer& _Myfirst() noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	const pointer& _Myfirst() const noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	pointer& _Mylast() noexcept
		{	
		return (_Get_data()._Mylast);
		}

	const pointer& _Mylast() const noexcept
		{	
		return (_Get_data()._Mylast);
		}

	pointer& _Myend() noexcept
		{	
		return (_Get_data()._Myend);
		}

	const pointer& _Myend() const noexcept
		{	
		return (_Get_data()._Myend);
		}

private:
	_Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class vector
		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
	{	
public:
	typedef vector<_Ty, _Alloc> _Myt;
	typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

 
 

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector() noexcept
		: _Mybase()
		{	
		}

	explicit vector(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		if (_Buy(_Count))
			{	
			try {
			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,
				this->_Getal());
			this->_Mylast() += _Count;
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(size_type _Count, const value_type& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		try {

		for (; _First != _Last; ++_First)
			emplace_back(*_First);

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		if (_Buy(::std:: distance(_First, _Last)))
			{	
			try {
			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	void _Construct_n(size_type _Count, const value_type *_Pval)
		{	
		if (_Buy(_Count))
			{	
			try {
			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 853 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this != &_Right)
			{	
			_Tidy();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all((_Myt&)_Right);
		this->_Myfirst() = _Right._Myfirst();
		this->_Mylast() = _Right._Mylast();
		this->_Myend() = _Right._Myend();

		_Right._Myfirst() = pointer();
		_Right._Mylast() = pointer();
		_Right._Myend() = pointer();
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Construct(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	void push_back(value_type&& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst();
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(this->_Mylast(),
				::std:: forward<value_type>(this->_Myfirst()[_Idx]));
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(this->_Mylast(),
				::std:: forward<value_type>(_Val));
			++this->_Mylast();
			}
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: move(_Val)));
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		if (this->_Mylast() == this->_Myend())
			_Reserve(1);
		_Orphan_range(this->_Mylast(), this->_Mylast());
		this->_Getal().construct(this->_Mylast(),
			::std:: forward<_Valty>(_Val)...);
		++this->_Mylast();
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector emplace iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 940);
 #line 942 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		emplace_back(::std:: forward<_Valty>(_Val)...);
		::std:: rotate(begin() + _Off, end() - 1, end());
		return (begin() + _Off);
		}


	vector(::std:: initializer_list<value_type> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Construct(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<value_type> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy();
				this->_Copy_alloc(_Right._Getal());
				}

			this->_Orphan_all();

			if (_Right.empty())
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
					_Right._Mylast(), this->_Myfirst());	
				_Destroy(_Ptr, this->_Mylast());	
				this->_Mylast() = this->_Myfirst() + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst() + size();
				_Copy_impl(_Right._Myfirst(),
					_Ptr, this->_Myfirst());
				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
					this->_Mylast());
				}
			else
				{	
				if (this->_Myfirst() != pointer())
					{	
					_Destroy(this->_Myfirst(), this->_Mylast());
					this->_Getal().deallocate(this->_Myfirst(),
						this->_Myend() - this->_Myfirst());
					}
				if (_Buy(_Right.size()))
					try {
					this->_Mylast() =
						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
						this->_Myfirst());
					} catch (...) {
					_Tidy();
					throw;
					}
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (capacity() < _Count)
			{	
			if (max_size() < _Count)
				_Xlen();
			_Reallocate(_Count);
			}
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myend() - this->_Myfirst());
		}

	size_type _Unused_capacity() const noexcept
		{	
		return (this->_Myend() - this->_Mylast());
		}

	size_type _Has_unused_capacity() const noexcept
		{	
		return (this->_Myend() != this->_Mylast());
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myfirst(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Mylast(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Mylast(), &this->_Get_data()));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (_Has_unused_capacity())
			{	
			if (empty())
				_Tidy();
			else
				_Reallocate(size());
			}
		}

	void resize(size_type _Newsize)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			_Reserve(_Newsize - size());
			try {
			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
				this->_Getal());
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	void resize(size_type _Newsize, const value_type& _Val)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			const value_type *_Ptr = ::std:: addressof(_Val);

			if (_Inside(_Ptr))
				{	
				const difference_type _Idx = _Ptr
					- ::std:: addressof(*this->_Myfirst());
				_Reserve(_Newsize - size());
				_Ptr = ::std:: addressof(*this->_Myfirst()) + _Idx;
				}
			else
				_Reserve(_Newsize - size());

			try {
			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	size_type size() const noexcept
		{	
		return (this->_Mylast() - this->_Myfirst());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (this->_Myfirst() == this->_Mylast());
		}

	_Alloc get_allocator() const noexcept
		{	
		return (this->_Getal());
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1216);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1217, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1217, 0); };
			}

 

#line 1223 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	reference operator[](size_type _Pos)
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1232);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1233, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1233, 0); };
			}

 

#line 1239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	pointer data() noexcept
		{	
		return (this->_Myfirst());
		}

	const_pointer data() const noexcept
		{	
		return (this->_Myfirst());
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const value_type& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst();
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(this->_Mylast(),
				this->_Myfirst()[_Idx]);
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(this->_Mylast(),
				_Val);
			++this->_Mylast();
			}
		}

 
	void pop_back()
		{	
		if (empty())
			_Debug_message(L"vector empty before pop", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1300);
		else
			{	
			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
			this->_Getal().destroy(this->_Mylast() - 1);
			--this->_Mylast();
			}
		}

 





#line 1316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		clear();
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		for (; _First != _Last; ++_First)
			emplace_back(*_First);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		size_type _Newsize = ::std:: distance(_First, _Last);

		if (capacity() < _Newsize)
			{	
			size_type _Newcapacity = _Grow_to(_Newsize);
			_Tidy();
			_Buy(_Newcapacity);
			}

		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
		}

	void assign(size_type _Count, const value_type& _Val)
		{	
		clear();
		insert(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const _Ty& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1386);
 #line 1388 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_First != _Last)
			{	
			size_type _Oldsize = size();

			try {
			for (; _First != _Last; ++_First)
				push_back(*_First);	

			} catch (...) {
			erase(begin() + _Oldsize, end());
			throw;
			}

			::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
			}
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				forward_iterator_tag)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1415);
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1416);
 #line 1418 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else
			{	
			_Ucopy(_First, _Last, this->_Mylast());
			::std:: rotate((_Where)._Ptr, this->_Mylast(),
				this->_Mylast() + _Count);
			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			}
		}

 
	iterator erase(const_iterator _Where)
		{	
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() <= (_Where)._Ptr)
			_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1474);
		_Move((_Where)._Ptr + 1, this->_Mylast(), (_Where)._Ptr);
		_Destroy(this->_Mylast() - 1, this->_Mylast());
		_Orphan_range((_Where)._Ptr, this->_Mylast());
		--this->_Mylast();
		return (_Make_iter(_Where));
		}

 








#line 1492 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		if (_First_arg == begin() && _Last_arg == end())
			clear();
		else if (_First_arg != _Last_arg)
			{	
			iterator _First = _Make_iter(_First_arg);
			iterator _Last = _Make_iter(_Last_arg);

			if (_First != _Last)
				{	
 
				if (_Last < _First || _First._Getcont() != &this->_Get_data()
					|| (_First)._Ptr < this->_Myfirst()
					|| this->_Mylast() < (_Last)._Ptr)
					_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1509);
				pointer _Ptr = _Move((_Last)._Ptr, this->_Mylast(),
					(_First)._Ptr);
				_Orphan_range((_First)._Ptr, this->_Mylast());

 


#line 1518 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

				_Destroy(_Ptr, this->_Mylast());
				this->_Mylast() = _Ptr;
				}
			}
		return (_Make_iter(_First_arg));
		}

	void _Pop_back_n(size_type _Count)
		{	
		pointer _Ptr = this->_Mylast() - _Count;

 
		_Orphan_range(_Ptr, this->_Mylast());
 #line 1533 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Destroy(_Ptr, this->_Mylast());
		this->_Mylast() = _Ptr;
		}

	void clear() noexcept
		{	
		this->_Orphan_all();
		_Destroy(this->_Myfirst(), this->_Mylast());
		this->_Mylast() = this->_Myfirst();
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1548 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}

		else
			{	
 
			_Debug_message(L"vector containers incompatible for swap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1570);

 

#line 1575 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		}

protected:
	bool _Buy(size_type _Capacity)
		{	
		this->_Myfirst() = pointer();
		this->_Mylast() = pointer();
		this->_Myend() = pointer();

		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			this->_Myfirst() = this->_Getal().allocate(_Capacity);
			this->_Mylast() = this->_Myfirst();
			this->_Myend() = this->_Myfirst() + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Destroy_range(_First, _Last, this->_Getal());
		}

	size_type _Grow_to(size_type _Count) const
		{	
		size_type _Capacity = capacity();

		_Capacity = max_size() - _Capacity / 2 < _Capacity
			? 0 : _Capacity + _Capacity / 2;	
		if (_Capacity < _Count)
			_Capacity = _Count;
		return (_Capacity);
		}

	bool _Inside(const value_type *_Ptr) const
		{	
		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
		}

	void _Reallocate(size_type _Count)
		{	
		pointer _Ptr = this->_Getal().allocate(_Count);

		try {
		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
		} catch (...) {
		this->_Getal().deallocate(_Ptr, _Count);
		throw;
		}

		size_type _Size = size();
		if (this->_Myfirst() != pointer())
			{	
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			}

		this->_Orphan_all();
		this->_Myend() = _Ptr + _Count;
		this->_Mylast() = _Ptr + _Size;
		this->_Myfirst() = _Ptr;
		}

	void _Reserve(size_type _Count)
		{	
		if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();
			_Reallocate(_Grow_to(size() + _Count));
			}
		}

	void _Tidy()
		{	
		if (this->_Myfirst() != pointer())
			{	
			this->_Orphan_all();
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			this->_Myfirst() = pointer();
			this->_Mylast() = pointer();
			this->_Myend() = pointer();
			}
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, this->_Getal()));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_move(_First, _Last,
			_Ptr, this->_Getal()));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const value_type& _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1689);
 #line 1691 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			size_type _Whereoff = (_Where)._Ptr - this->_Myfirst();
			int _Ncopied = 0;

			try {
			_Ufill(_Newvec + _Whereoff, _Count,
				::std:: addressof(_Val));	
			++_Ncopied;
			_Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			++_Ncopied;
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Newvec + (_Whereoff + _Count));	
			} catch (...) {
			if (1 < _Ncopied)
				_Destroy(_Newvec, _Newvec + _Whereoff);
			if (0 < _Ncopied)
				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else if ((size_type)(this->_Mylast() - (_Where)._Ptr)
			< _Count)
			{	
			value_type _Tmp = _Val;	

			_Umove((_Where)._Ptr, this->_Mylast(),
				(_Where)._Ptr + _Count);	

			try {
			_Ufill(this->_Mylast(),
				_Count - (this->_Mylast() - (_Where)._Ptr),
				::std:: addressof(_Tmp));	
			} catch (...) {
			_Destroy((_Where)._Ptr + _Count,
				this->_Mylast() + _Count);
			throw;
			}

			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			::std:: fill((_Where)._Ptr, this->_Mylast() - _Count,
				_Tmp);	
			}
		else
			{	
			value_type _Tmp = _Val;	

			pointer _Oldend = this->_Mylast();
			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
				this->_Mylast());	

			_Orphan_range((_Where)._Ptr, this->_Mylast());
			_Move_backward((_Where)._Ptr, _Oldend - _Count,
				_Oldend);	
			::std:: fill((_Where)._Ptr,
				(_Where)._Ptr + _Count, _Tmp);	
			}
		return (begin() + _Off);
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
		{	
		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
		return (_Ptr + _Count);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<T> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<T> subscript");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			{	
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
			}
		}

 



#line 1815 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}




typedef unsigned int _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _Alloc>
	class _Vb_iter_base
		: public _Iterator012<random_access_iterator_tag,
			bool,
			typename _Alloc::difference_type,
			bool *,
			bool,
			_Iterator_base>
	{	
public:
	typedef typename _Alloc::size_type _Sizet;
	typedef vector<bool, _Alloc> _Mycont;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	
 
		_Sizet _Mysize = ((_Mycont *)this->_Getcont())->_Mysize;

		_Inc += _Myoff;
		_Inc += _VBITS * (_Myptr
			- (((_Mycont *)this->_Getcont())->_Myvec)._Myfirst());
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 


#line 1930 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		
template<class _Alloc>
	class _Vb_reference
		: public _Vb_iter_base<_Alloc>
	{	
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_reference<_Alloc> _Mytype;

	_Vb_reference() noexcept
		{	
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	
		}

	_Mytype& operator=(const _Mytype& _Right) noexcept
		{	
		return (*this = bool(_Right));
		}

	_Mytype& operator=(bool _Val) noexcept
		{	
		if (_Val)
			*(_Vbase *)_Getptr() |= _Mask();
		else
			*(_Vbase *)_Getptr() &= (~_Mask());	
		return (*this);
		}

	void flip() noexcept
		{	
		*(_Vbase *)_Getptr() ^= _Mask();
		}

	operator bool() const noexcept
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Myptr == 0
			|| 0 <= this->_Valid(0))
			{	
			_Debug_message(L"vector<bool> iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1985);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1986, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1986, 0); };
			}

 


#line 1993 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1) << this->_Myoff);
		}
	};

template<class _Alloc> inline
	void swap(_Vb_reference<_Alloc> _Left,
		_Vb_reference<_Alloc> _Right)
	{	
	bool _Val = _Left;	
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _Alloc>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alloc>
	{	
public:
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_const_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Mytype& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Mytype& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	bool operator>(const _Mytype& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Mytype& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Mytype& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Mytype& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			_Debug_message(L"vector<bool> iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2161);
		}

 










#line 2176 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
				{	
				_Debug_message(L"vector<bool> iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2186);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2187, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2187, 0); };
				}

 


#line 2194 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
				{	
				_Debug_message(L"vector<bool> iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2209);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2210, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2210, 0); };
				}

 


#line 2217 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alloc> inline
	_Vb_const_iterator<_Alloc> operator+(
		typename _Alloc::difference_type _Off,
		_Vb_const_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
		: public true_type
	{	
	};

	
template<class _Alloc>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alloc>
	{	
public:
	typedef _Vb_const_iterator<_Alloc> _Mybase;
	typedef _Vb_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Alloc> inline
	_Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
		_Vb_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_iterator<_Alloc> >
		: public true_type
	{	
	};

		
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	
public:
	typedef vector<_Vbase, _Alloc> _Vectype;
	typedef typename _Vectype::_Alty _Alty;
	typedef typename _Alty::size_type size_type;

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, _Al),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() noexcept
		{	
		_Free_proxy();
		}

 












#line 2410 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	void _Swap_alloc(_Vb_val& _Right)
		{	
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec.get_allocator());
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec.get_allocator());
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 2434 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	
	typename _Alty::size_type _Mysize;	
	};

		

template<class _Alloc>
	class vector<bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	
public:
	typedef vector<bool, _Alloc> _Myt;
	typedef _Vb_val<_Alloc> _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Vectype _Vectype;

	typedef typename _Alty::size_type size_type;
	typedef typename _Alty::difference_type difference_type;
	typedef bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Alty> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Alty> const_iterator;
	typedef _Vb_iterator<_Alty> iterator;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	static const int _VBITS = ::std:: _VBITS;
	enum {_EEN_VBITS = _VBITS};	
	vector()
		: _Mybase(0, false)
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		}

	explicit vector(size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, false, _Al)
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, _Val, _Al)
		{	
		_Trim(_Count);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(0, false, _Al)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	
		insert(begin(), _First, _Last);
		}

	vector(_Myt&& _Right)
		: _Mybase(::std:: forward<_Myt>(_Right))
		{	
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(::std:: forward<_Myt>(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->get_allocator() != _Right.get_allocator())
				{	
				this->_Free_proxy();
				this->_Myvec = ::std:: move(_Right._Myvec);
				this->_Alloc_proxy();
				}
			else
				this->_Myvec = ::std:: move(_Right._Myvec);


			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;
			}
		return (*this);
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		push_back(_Tmp);
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		return (insert(_Where, _Tmp));
		}


	vector(::std:: initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			::std:: initializer_list<bool> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		this->_Mysize = _Right._Mysize;
		this->_Myvec = _Right._Myvec;
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myvec.capacity() * _VBITS);
		}

	iterator begin() noexcept
		{	
		return (iterator((_Vbase *)this->_Myvec._Myfirst(), this));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator((_Vbase *)this->_Myvec._Myfirst(), this));
		}

	iterator end() noexcept
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator end() const noexcept
		{	
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (this->_Myvec._Has_unused_capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize);
		}

	size_type max_size() const noexcept
		{	
		const size_type _Maxsize = this->_Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const noexcept
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const noexcept
		{	
		return (this->_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference operator[](size_type _Off)
		{	
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		erase(end() - 1);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const bool& _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const bool& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, (void)++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2839);
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		size_type _Off = _Insert_x(_Where, _Count);
		::std:: copy(_First, _Last, begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 
		if (end() <= _Where)
			_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2854);
		::std:: copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, this->_Mysize);

 

#line 2861 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	
 
			if (_Last < _First || end() < _Last)
				_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2877);
			iterator _Next = ::std:: copy(_Last, end(), _First);
			size_type _Newsize = _Next - begin();
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 


#line 2887 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (begin() + _Off);
		}

	void clear() noexcept
		{	
		erase(begin(), end());
		}

	void flip() noexcept
		{	
		for (typename _Vectype::iterator _Next = this->_Myvec.begin();
			_Next != this->_Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(this->_Mysize);
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->get_allocator() == _Right.get_allocator())
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else
			{	
 
			_Debug_message(L"vector<bool> containers incompatible for swap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2925);

 

#line 2930 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		}

	static void swap(reference _Left, reference _Right) noexcept
		{	
		bool _Val = _Left;	

		_Left = _Right;
		_Right = _Val;
		}

	size_t hash() const
		{	
		return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
			this->_Myvec.size() * sizeof (_Vbase)));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 
		if (end() < _Where)
			_Debug_message(L"vector<bool> insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2961);
		bool _Realloc = capacity() - size() < _Count;
 #line 2964 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}

 
			_Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
 #line 2984 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (_Off);
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	
		typedef _Vb_iter_base<_Alty> _Myiterbase;

		_Lockit _Lock(3);
		_Vbase *_Base = (_Vbase *)this->_Myvec._Myfirst();

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	
				size_type _Off = _VBITS * ((*_Pnext)->_Myptr - _Base)
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 



#line 3017 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<bool> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc> inline
	bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc> inline
	bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

	
template<class _Alloc>
	struct hash<vector<bool, _Alloc> >
	{	
	typedef vector<bool, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Keyval.hash());
		}
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3078 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
#line 3079 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"






#line 57 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"







































#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"










































































































































































































































































#line 268 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 273 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4244)

namespace std {
		
const int _ISORT_MAX = 32;	

		
template<class _InIt,
	class _Fn1> inline
	void _For_each(_InIt _First, _InIt _Last, _Fn1& _Func)
	{	
	for (; _First != _Last; ++_First)
		_Func(*_First);
	}

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 31);
	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

	return (::std:: move(_Func));
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 52);
	return (_Rechecked(_First,
		_Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				return (_Firstb);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 73);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 74);
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: adjacent_find(_First, _Last, equal_to<>()));
	}

		
template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 105);
	return (_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		{	
		++_First1;
		++_First2;
		}
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 















#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, true_type)
	{	
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, false_type)
	{	
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 172);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 173);
	pair<typename _Get_unchecked_type<_InIt1>::type, _InIt2> _Ans(
		_Mismatch2(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred, _Is_checked(_First2)));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(
		::std:: mismatch(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	return (pair<_InIt1, _InTy *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}
 #line 199 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 200 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	
	return (::std:: mismatch(_First1, _Last1, _First2,
		equal_to<>()));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize])
	{	
	return (::std:: mismatch(_First1, _Last1, _First2,
		equal_to<>()));
	}
 #line 224 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2
		&& _Pred(*_First1, *_First2); )
		{	
		++_First1;
		++_First2;
		}
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 249);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 250);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 251);
	pair<typename _Get_unchecked_type<_InIt1>::type, typename _Get_unchecked_type<_InIt2>::type> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Rechecked(_First2, _Ans.second)));
	}

		
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: mismatch(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _All_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 286);
	return (_All_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _Any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (true);
	return (false);
	}

template<class _InIt,
	class _Pr> inline
	bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 305);
	return (_Any_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _None_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 324);
	return (_None_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 343);
	return (_Rechecked(_First,
		_Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 358);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 










#line 376 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, true_type)
	{	
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, false_type)
	{	
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 403);
	return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *copy_if(_InIt _First, _InIt _Last, _OutTy (&_Dest)[_OutSize],
		_Pr _Pred)
	{	
	return (_Unchecked(
		::std:: copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 421 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 422 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	
			_Debug_pointer(_Dest1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 435);
			*_Dest1++ = *_First;
			}
		else
			{	
			_Debug_pointer(_Dest2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 440);
			*_Dest2++ = *_First;
			}
	return (pair<_OutIt1, _OutIt2>( _Dest1, _Dest2));
	}

 













#line 461 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			true_type, true_type)
	{	
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			true_type, false_type)
	{	
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			false_type, true_type)
	{	
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			false_type, false_type)
	{	
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 528);
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred,
			_Is_checked(_Dest1), _Is_checked(_Dest2))));
	}

 
template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutTy1 *, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutIt2 _Dest2, _Pr _Pred)
	{	
	pair<_Array_iterator<_OutTy1, _OutSize1>, _OutIt2> _Ans =
		::std:: partition_copy(_First, _Last,
			_Array_iterator<_OutTy1, _OutSize1>(_Dest1), _Dest2, _Pred);
	return (pair<_OutTy1 *, _OutIt2>(
		_Unchecked(_Ans.first),
		_Ans.second));
	}

template<class _InIt,
	class _OutIt1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutIt1, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutTy2 (&_Dest2)[_OutSize2], _Pr _Pred)
	{	
	pair<_OutIt1, _Array_iterator<_OutTy2, _OutSize2> > _Ans =
		::std:: partition_copy(_First, _Last,
			_Dest1, _Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (pair<_OutIt1, _OutTy2 *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutTy1 *, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutTy2 (&_Dest2)[_OutSize2],
			_Pr _Pred)
	{	
	pair<_Array_iterator<_OutTy1, _OutSize1>,
		_Array_iterator<_OutTy2, _OutSize2> > _Ans =
			::std:: partition_copy(_First, _Last,
				_Array_iterator<_OutTy1, _OutSize1>(_Dest1),
				_Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (pair<_OutTy1 *, _OutTy2 *>(
		_Unchecked(_Ans.first),
		_Unchecked(_Ans.second)));
	}
 #line 591 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 592 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _Pr> inline
	bool _Is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);	
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 611);
	return (_Is_partitioned(_Unchecked(_First), _Unchecked(_Last),
		_Pred));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Pr> inline
	_FwdIt _Partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 645);
	return (_Rechecked(_First,
		_Partition_point(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
		forward_iterator_tag, forward_iterator_tag)
	{	
	for (; ; ++_First1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (_Mid1 == _Last1)
				return (_Last1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_Diff1 _Count1 = _Last1 - _First1;
	_Diff2 _Count2 = _Last2 - _First2;

	for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}
	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 704);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 705);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 706);
	return (_Rechecked(_First1,
		_Search(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2),
			_Iter_cat(_First1), _Iter_cat(_First2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: search(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First);

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			{	
			_FwdIt _Mid = _First;

			for (_Diff _Count1 = _Count; ; )
				if (--_Count1 == 0)
					return (_First);	
				else if (++_Mid == _Last)
					return (_Last);	
				else if (!_Pred(*_Mid, _Val))
					{	
					break;
					}

			_First = _Mid;	
			}
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First);

	_FwdIt _Oldfirst = _First;
	for (_Diff _Inc = 0; _Count <= _Last - _Oldfirst; )
		{	
		_First = _Oldfirst + _Inc;
		if (_Pred(*_First, _Val))
			{	
			_Diff _Count1 = _Count;
			_FwdIt _Mid = _First;

			for (; _Oldfirst != _First && _Pred(_First[-1], _Val);
				--_First)
				--_Count1;	

			if (_Count1 <= _Last - _Mid)
				for (; ; )
					{	
					if (--_Count1 == 0)
						return (_First);	
					else if (!_Pred(*++_Mid, _Val))
						{	
						break;
						}
					}
			_Oldfirst = ++_Mid;	
			_Inc = 0;
			}
		else
			{	
			_Oldfirst = _First + 1;
			_Inc = _Count - 1;
			}
		}
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 807);
	return (_Rechecked(_First,
		_Search_n(_Unchecked(_First), _Unchecked(_Last), _Count, _Val,
			_Pred, _Iter_cat(_First))));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Ty> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val)
	{	
	return (::std:: search_n(_First, _Last, _Count, _Val,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		{	
		_Debug_pointer_if(_Count2 <= _Count1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 841);
		for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!_Pred(*_Mid1, *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
		}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 864);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 865);
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: find_end(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (_Pred(*_First1, *_Mid2))
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 902);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 903);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 904);
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: find_first_of(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_Dest)
		::std:: iter_swap(_First1, _Dest);
	return (_Dest);
	}

 









#line 942 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		forward_iterator_tag, forward_iterator_tag)
	{	
	return (_Swap_ranges(_First1, _Last1,
		_Dest));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_FwdIt2 _Ans = _Dest + (_Last1 - _First1);	
	_Swap_ranges(_First1, _Last1,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest, true_type)
	{	
	return (_Swap_ranges(_First1, _Last1,
		_Dest, _Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest, false_type)
	{	
	return (_Swap_ranges(_First1, _Last1,
		_Dest, _Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	_Debug_range_ptr(_First1, _Last1, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 988);
	return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _FwdIt1,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: swap_ranges(_First1, _Last1,
		_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 1005 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1006 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = _Func(*_First);
	return (_Dest);
	}

 










#line 1031 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Transform(_First, _Last,
		_Dest, _Func));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Transform(_First, _Last,
		_Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, true_type)
	{	
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, false_type)
	{	
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1084);
	_Debug_pointer_if(_First != _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1085);
	return (_Transform1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Func, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Fn1> inline
	_OutTy *transform(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Fn1 _Func)
	{	
	return (_Unchecked(
		::std:: transform(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #line 1103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1104 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2, ++_Dest)
		*_Dest = _Func(*_First1, *_First2);
	return (_Dest);
	}

 











#line 1131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Transform(_First1, _Last1,
		_First2, _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last1 - _First1);	
	_Transform(_First1, _Last1,
		_First2, _Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, input_iterator_tag)
	{	
	return (_Transform3(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1);	
	_Last2 = _Last2;	
	return (_Transform3(_First1, _Last1,
		_Unchecked(_First2), _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		true_type)
	{	
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		false_type)
	{	
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1219);
	_Debug_pointer_if(_First1 != _Last1, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1220);
	_Debug_pointer_if(_First1 != _Last1, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1221);
	return (_Transform2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Dest, _Func,
		_Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutIt _Dest, _Fn2 _Func)
	{	
	return (::std:: transform(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	
	return (_Unchecked(
		::std:: transform(_First1, _Last1,
			_First2, _Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	
	return (_Unchecked(
		::std:: transform(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2),
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #line 1268 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1269 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	void _Replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Oldval)
			*_First = _Newval;
	}

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1286);
	_Replace(_Unchecked(_First), _Unchecked(_Last),
		_Oldval, _Newval);
	}

		
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_First = _Val;
	}

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1307);
	_Replace_if(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Val);
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = *_First == _Oldval ? _Newval : *_First;
	return (_Dest);
	}

 










#line 1336 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Replace_copy(_First, _Last,
		_Unchecked(_Dest), _Oldval, _Newval);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		true_type)
	{	
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		false_type)
	{	
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1391);
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval,
		_Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *replace_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return (_Unchecked(
		::std:: replace_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Oldval, _Newval)));
	}
 #line 1410 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1411 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = _Pred(*_First) ? _Val : *_First;
	return (_Dest);
	}

 











#line 1438 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Replace_copy_if(_First, _Last,
		_Unchecked(_Dest), _Pred, _Val);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		true_type)
	{	
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		false_type)
	{	
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1498);
	_Debug_pointer_if(_First != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1499);
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val,
		_Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr,
	class _Ty> inline
	_OutTy *replace_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred, const _Ty& _Val)
	{	
	return (_Unchecked(
		::std:: replace_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred, _Val)));
	}
 #line 1519 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1520 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Fn0> inline
	void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Func();
	}

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1534);
	_Generate(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

		
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Func();
	return (_Dest);
	}

 








#line 1559 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		_Mutable_iterator_tag)
	{	
	return (_Generate_n(_Dest, _Count, _Func));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + _Count;	
	_Ans = _Ans;	
	return (_Rechecked(_Dest,
		_Generate_n(_Unchecked(_Dest), _Count, _Func)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		true_type)
	{	
	return (_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		false_type)
	{	
	return (_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	_Debug_pointer_if(0 < _Count, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1606);
	_Debug_pointer_if(0 < _Count, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1607);
	return (_Generate_n(_Dest, _Count, _Func,
		_Is_checked(_Dest)));
	}

 
template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Fn0> inline
	_OutTy *generate_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, _Fn0 _Func)
	{	
	return (_Unchecked(
		::std:: generate_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
			_Count, _Func)));
	}
 #line 1624 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1625 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (!(*_First == _Val))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1636);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 










#line 1654 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		true_type)
	{	
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		false_type)
	{	
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1683);
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val,
		_Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *remove_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Val)
	{	
	return (_Unchecked(
		::std:: remove_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Val)));
	}
 #line 1702 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1703 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1714);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 










#line 1732 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		true_type)
	{	
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		false_type)
	{	
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1761);
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred,
		_Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *remove_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		::std:: remove_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 1780 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1781 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_FwdIt _Next = _First;
	for (++_First; _First != _Last; ++_First)
		if (!(*_First == _Val))
			*_Next++ = _Move(*_First);
	return (_Next);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = ::std:: find(_First, _Last, _Val);
	if (_First == _Last)
		return (_First);	
	else
		return (_Rechecked(_First,
			_Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Next = _First;
	for (++_First; _First != _Last; ++_First)
	if (!_Pred(*_First))
		*_Next++ = _Move(*_First);
	return (_Next);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_First = ::std:: find_if(_First, _Last, _Pred);
	if (_First == _Last)
		return (_First);	
	else
		return (_Rechecked(_First,
			_Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				{	
				for (; ++_First != _Last; )
					if (!_Pred(*_Firstb, *_First))
						*++_Firstb = _Move(*_First);
				return (++_Firstb);
				}
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1851);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1852);
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: unique(_First, _Last, equal_to<>()));
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _Ty *)
	{	
	_Ty _Val = *_First;

	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!_Pred(_Val, *_First))
			{	
			_Val = *_First;
			*_Dest++ = _Val;
			}
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag)
	{	
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		_Val_type(_First)));
	}

template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr _Pred, forward_iterator_tag)
	{	
	_FwdIt _Firstb = _First;

	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!_Pred(*_Firstb, *_First))
			{	
			_Firstb = _First;
			*_Dest++ = *_Firstb;
			}
	return (_Dest);
	}

 











#line 1923 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1950);
	_Debug_pointer_if(_First != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1951);
	return (_First == _Last ? _Dest :
		_Unique_copy1(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		::std:: unique_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 1970 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 1971 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (::std:: unique_copy(_First, _Last, _Dest,
		equal_to<>()));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: unique_copy(_First, _Last, _Dest,
		equal_to<>()));
	}
 #line 1992 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	for (; _First != _Last; ++_Dest)
		*_Dest = *--_Last;
	return (_Dest);
	}

 









#line 2015 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Reverse_copy(_First, _Last,
		_Dest));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Reverse_copy(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		true_type)
	{	
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		false_type)
	{	
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2063);
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _BidIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *reverse_copy(_BidIt _First, _BidIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: reverse_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2080 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 2081 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	
	_Dest = ::std:: copy(_Mid, _Last, _Dest);
	return (::std:: copy(_First, _Mid, _Dest));
	}

		
template<class _RanIt,
	class _Fn1,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
	{	
	_RanIt _Next = _First;
	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
		{	
		_Diff _Off = _Func(_Index);

 
		if (_Off < 0 || _Index <= _Off)
			{	
			_Debug_message(L"random value out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2106);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2107, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2107, 0); };
			}

 

#line 2113 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		::std:: iter_swap(_Next, _First + _Off);
		}
	}

template<class _RanIt,
	class _Fn1> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2122);
	if (2 <= _Last - _First)
		{	
		_Debug_pointer(_Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2125);
		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last), _Func,
			_Dist_type(_First));
		}
	}

template<class _RanIt,
	class _Urng> inline
	void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
	{	
	typedef typename iterator_traits<_RanIt>::difference_type _Diff;
	typedef typename remove_reference<_Urng>::type _Urng0;
	_Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
	_Random_shuffle(_First, _Last, _Rng);
	}

 
		
template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
	{	
	_Random_shuffle(_First, _Last, _Func);
	}

	
struct _Rand_urng_from_func
	{	
	typedef unsigned int result_type;

	static result_type (min)()
		{	
		return (0);
		}

	static result_type (max)()
		{	
		return (0x7fff);
		}

	result_type operator()()
		{	
		return (:: rand());
		}
	};

		
template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	
	_Rand_urng_from_func _Func;
	::std:: shuffle(_First, _Last, _Func);
	}
 #line 2179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		forward_iterator_tag)
	{	
	while (_First != _Last && _Pred(*_First))
		++_First;	

	if (_First == _Last)
		return (_First);	

	for (_FwdIt _Next = ::std:: next(_First); _Next != _Last; ++_Next)
		if (_Pred(*_Next))
			::std:: iter_swap(_First++, _Next);	

	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		bidirectional_iterator_tag)
	{	
	for (; ; ++_First)
		{	
		for (; _First != _Last && _Pred(*_First); ++_First)
			;	
		if (_First == _Last)
			break;	

		for (; _First != --_Last && !_Pred(*_Last); )
			;	
		if (_First == _Last)
			break;	

		::std:: iter_swap(_First, _Last);	
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2225);
	return (_Rechecked(_First,
		_Partition(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Iter_cat(_First))));
	}

		
template<class _BidIt,
	class _Diff,
	class _Ty> inline
	_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 == 0 || _Count2 == 0)
		{	
		::std:: advance(_First, _Count2);
		return (_First);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move(_First, _Mid, _Tempbuf._Init());
		_Move(_Mid, _Last, _First);
		return (_Move_backward(_Tempbuf._First(), _Tempbuf._Last(),
			_Last));
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Move_backward(_First, _Mid, _Last);
		return (_Move(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
	else
		{	
		return (::std:: rotate(_First, _Mid, _Last));
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count == 0)
		return (_First);
	else if (_Count == 1)
		return (_Pred(*_First) ? _Last : _First);
	else if (_Count <= _Tempbuf._Maxlen())
		{	
		_BidIt _Next = _First;
		for (_Tempbuf._Init(); _First != _Last; ++_First)
			if (_Pred(*_First))
				*_Next++ = _Move(*_First);
			else
				*_Tempbuf++ = _Move(*_First);

		_Move(_Tempbuf._First(), _Tempbuf._Last(), _Next);	
		return (_Next);
		}
	else
		{	
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count / 2);

		_BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
			_Count / 2, _Tempbuf);	
		_BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
			_Count - _Count / 2, _Tempbuf);	

		_Diff _Count1 = 0;
		_Distance(_Left, _Mid, _Count1);
		_Diff _Count2 = 0;
		_Distance(_Mid, _Right, _Count2);

		return (_Buffered_rotate(_Left, _Mid, _Right,
			_Count1, _Count2, _Tempbuf));	
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf(_Count);
	return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2322);
	return (_First == _Last ? _First
		: _Rechecked(_First,
			_Stable_partition(_Unchecked(_First), _Unchecked(_Last),
				_Pred, _Dist_type(_First), _Val_type(_First))));
	}

 
		
template<class _RanIt,
	class _Pr> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			{	
			if (_Debug_lt_pred(_Pred, *_Root, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2338))
				_Debug_message(L"invalid heap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2339);
			else if (++_First == _Last)
				break;
			else if (_Debug_lt_pred(_Pred, *_Root, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2342))
				_Debug_message(L"invalid heap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2343);
			}
	}

  


 

#line 2353 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty&& _Val, _Pr _Pred)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && _Debug_lt_pred(_Pred, *(_First + _Idx), _Val, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2363);
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	*(_First + _Hole) = _Move(_Val);	
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Diff _Count = _Last - _First;
	if (0 < _Count)
		{	
		_Ty _Val = _Move(*_Last);
		_Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2391);
	if (_First != _Last)
		{	
		--_Last;
		_Debug_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
		}
	}

		
template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: push_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty&& _Val, _Pr _Pred)
	{	
	_Diff _Top = _Hole;
	_Diff _Idx = 2 * _Hole + 2;

	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
		{	
		if (_Debug_lt_pred(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2421))
			--_Idx;
		*(_First + _Hole) = _Move(*(_First + _Idx));
		_Hole = _Idx;
		}

	if (_Idx == _Bottom)
		{	
		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));
		_Hole = _Bottom - 1;
		}
	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
	}

template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty&& _Val, _Pr _Pred, _Diff *)
	{	
	*_Dest = _Move(*_First);
	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
		_Move(_Val), _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
	{	
	_Ty _Val = _Move(*(_Last - 1));
	_Pop_heap(_First, _Last - 1, _Last - 1,
		_Move(_Val), _Pred, _Dist_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2469);
	_Debug_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	if (2 <= _Last - _First)
		_Pop_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: pop_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
	{	
	_Diff _Bottom = _Last - _First;
	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
		{	
		--_Hole;
		_Ty _Val = _Move(*(_First + _Hole));
		_Adjust_heap(_First, _Hole, _Bottom,
			_Move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2503);
	if (2 <= _Last - _First)
		{	
		_Debug_pointer(_Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2506);
		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
		}
	}

		
template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: make_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	for (; 2 <= _Last - _First; --_Last)
		_Pop_heap(_First, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2532);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2533);
	_Debug_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: sort_heap(_First, _Last, less<>());
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid, _Val))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	return (_Rechecked(_First,
		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: lower_bound(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (!_Pred(_Val, *_Mid))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	return (_Rechecked(_First,
		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
			_Dist_type(_First))));
	}

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: upper_bound(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Diff,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred, _Diff *)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);

	while (0 < _Count)
		{	
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Debug_lt_pred(_Pred, *_Mid, _Val, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2657))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Pred(_Val, *_Mid))
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
			::std:: advance(_First, _Count);
			_FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred)
	{	
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
			_Val, _Pred, _Dist_type(_First)));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val)
	{	
	return (::std:: equal_range(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_First = ::std:: lower_bound(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

		
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: binary_search(_First, _Last, _Val, less<>()));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2732))
				{	
				*_Dest++ = *_First2++;
				if (_First2 == _Last2)
					break;
				}
			else
				{	
				*_Dest++ = *_First1++;
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Copy_impl(_First1, _Last1, _Dest);	
	return (_Copy_impl(_First2, _Last2, _Dest));
	}

 













#line 2765 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
		input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Merge0(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last1 - _First1)
		+ (_Last2 - _First2);	
	_Merge0(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2833);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2834);
	_Debug_pointer_if(_First1 != _Last1 || _First2 != _Last2, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2835);
	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		::std:: merge(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 2857 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 2858 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 2884 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred,
		bool _In_place = false)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *--_Last2, *--_Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2897))
				{	
				*--_Dest = _Move(*_Last1);
				++_Last2;
				if (_First1 == _Last1)
					break;
				}
			else
				{	
				*--_Dest = _Move(*_Last2);
				++_Last1;
				if (_First2 == _Last2)
					break;
				}
			}

	_Dest = _Move_backward(_First2, _Last2, _Dest);	
	if (!_In_place)
		_Dest = _Move_backward(_First1, _Last1, _Dest);
	return (_Dest);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, bool _In_place = false)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2930))
				{	
				*_Dest++ = _Move(*_First2++);
				if (_First2 == _Last2)
					break;
				}
			else
				{	
				*_Dest++ = _Move(*_First1++);
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Move(_First1, _Last1, _Dest);	
	if (!_In_place)
		_Dest = _Move(_First2, _Last2, _Dest);
	return (_Dest);
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count1 == 0 || _Count2 == 0)
		;	
	else if (_Count1 + _Count2 == 2)
		{	
		if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2962))
			::std:: iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move(_First, _Mid, _Tempbuf._Init());
		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
			_Mid, _Last, _First, _Pred, true);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Merge_backward(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred, true);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			::std:: advance(_Firstn, _Count1n);
			_Lastn = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			::std:: advance(_Lastn, _Count2n);
			_Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
			_Distance(_First, _Firstn, _Count1n);
			}
		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf, _Pred);	
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_order(_First, _Mid, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3026);
	_Debug_order(_Mid, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3027);
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

		
template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	
	::std:: inplace_merge(_First, _Mid, _Last, less<>());
	}

		
template<class _BidIt,
	class _Pr,
	class _Ty> inline
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	
			_BidIt _Next1 = _Next;
			_Ty _Val = _Move(*_Next);

			if (_Debug_lt_pred(_Pred, _Val, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3053))
				{	
				_Move_backward(_First, _Next, ++_Next1);
				*_First = _Move(_Val);
				}
			else
				{	
				for (_BidIt _First1 = _Next1;
					_Debug_lt_pred(_Pred, _Val, *--_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3061);
					_Next1 = _First1)
					*_Next1 = _Move(*_First1);	
				*_Next1 = _Move(_Val);	
				}
			}
	}

template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3080))
		::std:: iter_swap(_Mid, _First);
	if (_Debug_lt_pred(_Pred, *_Last, *_Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3082))
		{	
		::std:: iter_swap(_Last, _Mid);
		if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3085))
			::std:: iter_swap(_Mid, _First);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3(_First, _Mid, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;
	_Median(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_Debug_lt_pred(_Pred, *(_Pfirst - 1), *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3117)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_Debug_lt_pred(_Pred, *_Plast, *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3121)
		&& !_Pred(*_Pfirst, *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3131))
				;
			else if (_Pred(*_Gfirst, *_Pfirst))
				break;
			else if (_Plast++ != _Gfirst)
				::std:: iter_swap(_Plast - 1, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_Debug_lt_pred(_Pred, *(_Glast - 1), *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3138))
				;
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				break;
			else if (--_Pfirst != _Glast - 1)
				::std:: iter_swap(_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				::std:: iter_swap(_Pfirst, _Plast);
			++_Plast;
			::std:: iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				::std:: iter_swap(_Glast, _Pfirst);
			::std:: iter_swap(_Pfirst, --_Plast);
			}
		else
			::std:: iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff,
	class _Pr> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{	
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)
			{	
			_Sort(_First, _Mid.first, _Ideal, _Pred);
			_First = _Mid.second;
			}
		else
			{	
			_Sort(_Mid.second, _Last, _Ideal, _Pred);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	
		::std:: make_heap(_First, _Last, _Pred);
		::std:: sort_heap(_First, _Last, _Pred);
		}
	else if (2 <= _Count)
		_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3202);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3203);
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);
	}

		
template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	
	::std:: sort(_First, _Last, less<>());
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		::std:: advance(_Mid2, _Chunk);

		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		_Move(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);

		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midn = _Mid;
		::std:: advance(_Midn, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort(_Mid, _Last, _Pred);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		_Chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count, _Pred);
		_Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last, _Pred);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
				_Tempbuf, _Pred);
			}
		else
			{	
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf, _Pred);	
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
	{	
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3319);
	if (_First != _Last)
		{	
		_Debug_pointer_if(::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3322);
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First), _Pred);
		}
	}

		
template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	
	::std:: stable_sort(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr _Pred, _Ty *)
	{	
	::std:: make_heap(_First, _Mid, _Pred);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3345))
			{	
			_Ty _Val = _Move(*_Next);
			_Pop_heap(_First, _Mid, _Next, _Move(_Val), _Pred,
				_Dist_type(_First));
			}
	::std:: sort_heap(_First, _Mid, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3358);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3359);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3360);
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

		
template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	::std:: partial_sort(_First, _Mid, _Last, less<>());
	}

		
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
	{	
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, (void)++_Mid2)
		*_Mid2 = *_First1;	
	::std:: make_heap(_First2, _Mid2, _Pred);

	for (; _First1 != _Last1; ++_First1)
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3388))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1), _Pred);	

	::std:: sort_heap(_First2, _Mid2, _Pred);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3402);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3403);

	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2), _Pred,
				_Dist_type(_First2), _Val_type(_First1))));
	}

		
template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	
	return (::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2,
		less<>()));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	if (_Nth == _Last)
		return;	

	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Nth, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3451);
	_Debug_range(_Nth, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3452);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3453);
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	::std:: nth_element(_First, _Nth, _Last, less<>());
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3473))
			return (false);
		else if (_Pred(*_First1, *_First2))
			++_First1;
		else
			{	
			++_First1;
			++_First2;
			}
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3491);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3492);
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: includes(_First1, _Last1, _First2, _Last2,
		less<>()));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3516))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest++ = *_First1;
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 












#line 3550 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3584);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3585);
	_Debug_pointer_if(_First1 != _Last1 || _First2 != _Last2, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3586);
	return (_Set_union2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		set_union(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3607 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 3608 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3632 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3642))
			++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3648);
			*_Dest++ = *_First1++;
			++_First2;
			}
	return (_Dest);
	}

 












#line 3669 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3703);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3704);
	return (_Set_intersection2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		set_intersection(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3725 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 3726 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3750 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3761))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3763);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			++_First1;
			++_First2;
			}
	return (::std:: copy(_First1, _Last1, _Dest));
	}

 













#line 3792 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3827);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3828);
	return (_Set_difference2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		set_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3850 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 3851 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3877 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3888))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3890);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3896);
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			++_First1;
			++_First2;
			}
	_Dest = ::std:: copy(_First1, _Last1, _Dest);
	return (::std:: copy(_First2, _Last2, _Dest));
	}

 














#line 3925 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3960);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3961);
	return (_Set_symmetric_difference2(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		set_symmetric_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3984 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
 #line 3985 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, less<>()));
	}
 #line 4011 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_Found, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4020))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4029);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4030);
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: max_element(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_First, *_Found, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4050))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4059);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4060);
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: min_element(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	pair<_FwdIt, _FwdIt> _Found(_First, _First);

	if (_First != _Last)
		for (; ++_First != _Last; )
			{	
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	
				if (_Debug_lt_pred(_Pred, *_First, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4086))
					_Found.first = _First;
				else if (!_Debug_lt_pred(_Pred, *_First, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4088))
					_Found.second = _First;
				}
			else
				{	
				if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4093))
					{	
					if (_Debug_lt_pred(_Pred, *_Next, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4095))
						_Found.first = _Next;
					if (!_Debug_lt_pred(_Pred, *_First, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4097))
						_Found.second = _First;
					}
				else
					{	
					if (_Debug_lt_pred(_Pred, *_First, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4102))
						_Found.first = _First;
					if (!_Debug_lt_pred(_Pred, *_Next, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4104))
						_Found.second = _Next;
					}
				_First = _Next;
				}
			}
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4118);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4119);
	pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

		
template<class _FwdIt> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: minmax_element(_First, _Last, less<>()));
	}

		
template<class _Ty> inline

	 

	constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Debug_lt(_Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4142) ? _Right : _Left);
	}

template<class _Ty> inline
		
	_Ty (max)(::std:: initializer_list<_Ty> _Ilist)
	{	
	const _Ty *_Res = ::std:: max_element(_Ilist.begin(), _Ilist.end());
	return (*_Res);
	}

		
template<class _Ty,
	class _Pr> inline
	constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
	{	
	return (_Debug_lt_pred(_Pred, _Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4159) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
		
	_Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	
	const _Ty *_Res = ::std:: max_element(_Ilist.begin(), _Ilist.end(), _Pred);
	return (*_Res);
	}

		
template<class _Ty> inline

	 

	constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Debug_lt(_Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4178) ? _Right : _Left);
	}

template<class _Ty> inline
		
	_Ty (min)(::std:: initializer_list<_Ty> _Ilist)
	{	
	const _Ty *_Res = ::std:: min_element(_Ilist.begin(), _Ilist.end());
	return (*_Res);
	}

		
template<class _Ty,
	class _Pr> inline
	constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
	{	
	return (_Debug_lt_pred(_Pred, _Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4195) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
		
	_Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	
	const _Ty *_Res = ::std:: min_element(_Ilist.begin(), _Ilist.end(), _Pred);
	return (*_Res);
	}

		
template<class _Ty> inline
	constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty> inline
		
	pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
	{	
	pair<const _Ty *, const _Ty *> _Res = ::std:: minmax_element(
		_Ilist.begin(), _Ilist.end());
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		
template<class _Ty,
	class _Pr> inline
	constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Pred(_Right, _Left)
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty,
	class _Pr> inline
		
	pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
		_Pr _Pred)
	{	
	pair<const _Ty *, const _Ty *> _Res = ::std:: minmax_element(
		_Ilist.begin(), _Ilist.end(), _Pred);
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *--_Next, *_Next1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4260))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *_Next, *--_Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4263); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4282);
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	
	return (::std:: next_permutation(_First, _Last, less<>()));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *_Next1, *--_Next, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4305))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *--_Mid, *_Next, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4308); )
				;
			::std:: iter_swap(_Next, _Mid);
			::std:: reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			::std:: reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4327);
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	return (::std:: prev_permutation(_First, _Last, less<>()));
	}

		
template<class _RanIt,
	class _Diff,
	class _Pr> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *)
	{	
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (_Debug_lt_pred(_Pred, *(_First + (_Off - 1) / 2), *(_First + _Off), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4349))
#line 4350 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt,
	class _Pr>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4358);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4359);
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}

template<class _RanIt,
	class _Pr>
	bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	return (::std:: is_heap_until(_First, _Last, _Pred) == _Last);
	}

		
template<class _RanIt>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	
	return (::std:: is_heap_until(_First, _Last, less<>()));
	}

template<class _RanIt>
	bool is_heap(_RanIt _First, _RanIt _Last)
	{	
	return (::std:: is_heap(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4392))
				return (_Next);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4401);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 4402);
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _FwdIt,
	class _Pr> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	return (::std:: is_sorted_until(_First, _Last, _Pred) == _Last);
	}

		
template<class _FwdIt> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: is_sorted_until(_First, _Last, less<>()));
	}

template<class _FwdIt> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: is_sorted(_First, _Last, less<>()));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 4431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
#line 4432 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"






#line 275 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_istream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 199);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 205);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 212);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator>>(__int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned __int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 409 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 574);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 677);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 734);
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Count && 0 < _Num)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 760);
			read(_Str, _Num < _Count ? _Num : _Count);	
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

 #pragma vtordisp(pop)	

  






















 










#line 934 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_iostream() noexcept
		{	
		}
	};

	

 










#line 1003 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 1011);
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1153 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"
#line 1154 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
  











		
 extern  istream cin, *_Ptr_cin;
 extern  ostream cout, *_Ptr_cout;
 extern  ostream cerr, *_Ptr_cerr;
 extern  ostream clog, *_Ptr_clog;

 extern  wistream wcin, *_Ptr_wcin;
 extern  wostream wcout, *_Ptr_wcout;
 extern  wostream wcerr, *_Ptr_wcerr;
 extern  wostream wclog, *_Ptr_wclog;

		
class  _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;
private:
	 static int _Init_cnt;
	};
  #line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"





#line 276 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)
 #pragma warning(disable: 4455)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		

inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		


template<class _Ty> inline
	string _Integral_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value,
		"_Ty must be integral");
	char _Buf[21];
	int _Len = :: sprintf_s(_Buf, 21, _Fmt, _Val);
	return (string(_Buf, _Len));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scprintf(_Fmt, _Val);
	string _Str(_Len + 1, '\0');
	:: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Integral_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value,
		"_Ty must be integral");
	wchar_t _Buf[21];
	int _Len = :: swprintf_s(_Buf, 21, _Fmt, _Val);
	return (wstring(_Buf, _Len));
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scwprintf(_Fmt, _Val);
	wstring _Str(_Len + 1, L'\0');
	:: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}



		
inline string to_string(int _Val)
	{	
	return (_Integral_to_string("%d", _Val));
	}

inline string to_string(unsigned int _Val)
	{	
	return (_Integral_to_string("%u", _Val));
	}

inline string to_string(long _Val)
	{	
	return (_Integral_to_string("%ld", _Val));
	}

inline string to_string(unsigned long _Val)
	{	
	return (_Integral_to_string("%lu", _Val));
	}

inline string to_string(long long _Val)
	{	
	return (_Integral_to_string("%lld", _Val));
	}

inline string to_string(unsigned long long _Val)
	{	
	return (_Integral_to_string("%llu", _Val));
	}

inline string to_string(float _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(double _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(long double _Val)
	{	
	return (_Floating_to_string("%Lf", _Val));
	}

		
inline wstring to_wstring(int _Val)
	{	
	return (_Integral_to_wstring(L"%d", _Val));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	return (_Integral_to_wstring(L"%u", _Val));
	}

inline wstring to_wstring(long _Val)
	{	
	return (_Integral_to_wstring(L"%ld", _Val));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	return (_Integral_to_wstring(L"%lu", _Val));
	}

inline wstring to_wstring(long long _Val)
	{	
	return (_Integral_to_wstring(L"%lld", _Val));
	}

inline wstring to_wstring(unsigned long long _Val)
	{	
	return (_Integral_to_wstring(L"%llu", _Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(double _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(long double _Val)
	{	
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	
inline namespace literals {
inline namespace string_literals {
inline string operator "" s(const char *_Str, size_t _Len)
	{	
	return (string(_Str, _Len));
	}

inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	
	return (wstring(_Str, _Len));
	}

inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	
	return (u16string(_Str, _Len));
	}

inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	
	return (u32string(_Str, _Len));
	}
}	
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 657 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"
#line 658 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
 #pragma warning(disable: 4251)

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringbuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Myt;
	typedef _Alloc allocator_type;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringbuf(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		{	
		_Init(0, 0, _Getstate(_Mode));
		}

	explicit basic_stringbuf(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
		}

	basic_stringbuf(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Tidy();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mysb::swap(_Right);
			::std:: swap(_Seekhigh, _Right._Seekhigh);
			::std:: swap(_Mystate, _Right._Mystate);
			_Swap_adl(_Al, _Right._Al);
			}
		}

	basic_stringbuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_stringbuf() noexcept
		{	
		_Tidy();
		}

	enum
		{	
		_Allocated = 1,	
		_Constant = 2,	
		_Noread = 4,	
		_Append = 8,	
		_Atend = 16};	
	typedef int _Strstate;

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	_Mystr str() const
		{	
		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
			{	
			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
			return (_Str);
			}
		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
			{	
			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
			return (_Str);
			}
		else
			{	
			_Mystr _Nul;
			return (_Nul);
			}
		}

	void str(const _Mystr& _Newstr)
		{	
		_Tidy();
		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
		}

protected:
	virtual int_type overflow(int_type _Meta = _Traits::eof())
		{	
		if (_Mystate & _Constant)
			return (_Traits::eof());	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	

		if (_Mystate & _Append
			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

		if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else
			{	
			size_t _Oldsize = _Mysb::pptr() == 0
				? 0 : _Mysb::epptr() - _Mysb::eback();
			size_t _Newsize = _Oldsize;
			size_t _Inc = _Newsize / 2 < _MINSIZE
				? _MINSIZE : _Newsize / 2;	

			while (0 < _Inc && 2147483647 - _Inc < _Newsize)
				_Inc /= 2;	
			if (_Inc == 0)
				return (_Traits::eof());	

			_Newsize += _Inc;

			_Elem *_Newptr = _Al.allocate(_Newsize);
			_Elem *_Oldptr = _Mysb::eback();

			if (0 < _Oldsize)
				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

			if (_Oldsize == 0)
				{	
				_Seekhigh = _Newptr;
				_Mysb::setp(_Newptr, _Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
				}
			else
				{	
				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
					_Newptr + (_Mysb::pptr() - _Oldptr),
					_Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr,
						_Newptr + (_Mysb::gptr() - _Oldptr),
						_Mysb::pptr() + 1);
				}

			if (_Mystate & _Allocated)
				_Al.deallocate(_Oldptr, _Oldsize);
			_Mystate |= _Allocated;

			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		}

	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
		{	
		if (_Mysb::gptr() == 0
			|| _Mysb::gptr() <= _Mysb::eback()
			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
			&& _Mystate & _Constant))
			return (_Traits::eof());	
		else
			{	
			_Mysb::gbump(-1);
			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
			return (_Traits::not_eof(_Meta));
			}
		}

	virtual int_type underflow()
		{	
		if (_Mysb::gptr() == 0)
			return (_Traits::eof());	
		else if (_Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Mystate & _Noread || _Mysb::pptr() == 0
			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
			return (_Traits::eof());	
		else
			{	
			if (_Seekhigh < _Mysb::pptr())
				_Seekhigh = _Mysb::pptr();
			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
			return (_Traits::to_int_type(*_Mysb::gptr()));
			}
		}

	virtual pos_type seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Which = ios_base::in | ios_base::out)
		{	
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Which & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur
				&& (_Which & ios_base::out) == 0)
				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Which & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur)
				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}

		else if (_Off != 0)


			_Off = _BADOFF;	
		return (pos_type(_Off));
		}

	virtual pos_type seekpos(pos_type _Ptr,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		streamoff _Off = (streamoff)_Ptr;
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Off == _BADOFF)
			;
		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}
		else
			_Off = _BADOFF;	
		return (streampos(_Off));
		}

	void _Init(const _Elem *_Ptr,
		size_t _Count, _Strstate _State)
		{	
		_Seekhigh = 0;
		_Mystate = _State;

		if (_Count != 0
			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
			{	
			_Elem *_Pnew = _Al.allocate(_Count);
			_Traits::copy(_Pnew, _Ptr, _Count);
			_Seekhigh = _Pnew + _Count;

			if (!(_Mystate & _Noread))
				_Mysb::setg(_Pnew, _Pnew,
					_Pnew + _Count);	
			if (!(_Mystate & _Constant))
				{	
				_Mysb::setp(_Pnew,
					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
					_Pnew + _Count);
				if (_Mysb::gptr() == 0)
					_Mysb::setg(_Pnew, 0, _Pnew);
				}
			_Mystate |= _Allocated;
			}
		}

	void _Tidy()
		{	
		if (_Mystate & _Allocated)
			_Al.deallocate(_Mysb::eback(),
				(_Mysb::pptr() != 0 ? _Mysb::epptr()
					: _Mysb::egptr()) - _Mysb::eback());
		_Mysb::setg(0, 0, 0);
		_Mysb::setp(0, 0);
		_Seekhigh = 0;
		_Mystate &= ~_Allocated;
		}

private:
	enum
		{	
		_MINSIZE = 32};

	_Strstate _Getstate(ios_base::openmode _Mode)
		{	
		_Strstate _State = (_Strstate)0;
		if (!(_Mode & ios_base::in))
			_State |= _Noread;
		if (!(_Mode & ios_base::out))
			_State |= _Constant;
		if (_Mode & ios_base::app)
			_State |= _Append;
		if (_Mode & ios_base::ate)
			_State |= _Atend;
		return (_State);
		}

	_Elem *_Seekhigh;	
	_Strstate _Mystate;	
	allocator_type _Al;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_istringstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::in)
		{	
		}

	explicit basic_istringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::in)
		{	
		}

	basic_istringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_istringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_istringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_ostringstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::out)
		{	
		}

	explicit basic_ostringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::out)
		{	
		}

	basic_ostringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_ostringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_ostringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringstream(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode)
		{	
		}

	explicit basic_stringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode)
		{	
		}

	basic_stringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_stringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_stringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_stringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 671 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"
#line 672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"





#line 277 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"










































#line 44 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"





#line 50 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"












#line 63 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"

#line 65 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"


























#line 92 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"

#line 94 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port-arch.h"
#line 282 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\custom\\gtest-port.h"




































































#line 70 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\custom\\gtest-port.h"
#line 283 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 292 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 296 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"























#line 320 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"









#line 330 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 332 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 333 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"












#line 353 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"











#line 365 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"























#line 389 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\direct.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {





    
        
        struct _diskfree_t
        {
            unsigned total_clusters;
            unsigned avail_clusters;
            unsigned sectors_per_cluster;
            unsigned bytes_per_sector;
        };
    #line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\direct.h"

     
     
     unsigned __cdecl _getdiskfree(
           unsigned            _Drive,
          struct _diskfree_t* _DiskFree
        );

       int __cdecl _chdrive(  int _Drive);

       int __cdecl _getdrive(void);

       unsigned long __cdecl _getdrives(void);

#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\direct.h"








 
   
 __declspec(allocator) char* __cdecl _getcwd(
      char* _DstBuf,
                                  int   _SizeInBytes
    );

 
   
 __declspec(allocator) char* __cdecl _getdcwd(
                                  int   _Drive,
      char* _DstBuf,
                                  int   _SizeInBytes
    );






   int __cdecl _chdir(  char const* _Path);

   int __cdecl _mkdir(  char const* _Path);

   int __cdecl _rmdir(  char const* _Path);




    

    

        
        

         
            __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getcwd" ". See online help for details."))
         char* __cdecl getcwd(
              char* _DstBuf,
                                          int   _SizeInBytes
            );

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chdir" ". See online help for details."))
         int __cdecl chdir(
              char const* _Path
            );

        

    #line 106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\direct.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_mkdir" ". See online help for details."))
     int __cdecl mkdir(
          char const* _Path
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmdir" ". See online help for details."))
     int __cdecl rmdir(
          char const* _Path
        );

#line 118 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\direct.h"



} __pragma(pack(pop))
#line 396 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\io.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {












    
    
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"

struct _finddata32_t
{
    unsigned    attrib;
    __time32_t  time_create;    
    __time32_t  time_access;    
    __time32_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct _finddata32i64_t
{
    unsigned    attrib;
    __time32_t  time_create;    
    __time32_t  time_access;    
    __time32_t  time_write;
    __int64     size;
    char        name[260];
};

struct _finddata64i32_t
{
    unsigned    attrib;
    __time64_t  time_create;    
    __time64_t  time_access;    
    __time64_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct __finddata64_t
{
    unsigned    attrib;
    __time64_t  time_create;    
    __time64_t  time_access;    
    __time64_t  time_write;
    __int64     size;
    char        name[260];
};





























    
    
    
    
#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"

 
 int __cdecl _access(
      char const* _FileName,
        int         _AccessMode
    );


 errno_t __cdecl _access_s(
      char const* _FileName,
        int         _AccessMode
    );

 
 int __cdecl _chmod(
      char const* _FileName,
        int         _Mode
    );

 
 int __cdecl _chsize(
      int  _FileHandle,
      long _Size
    );


 errno_t __cdecl _chsize_s(
      int     _FileHandle,
      __int64 _Size
    );


 int __cdecl _close(
      int _FileHandle
    );


 int __cdecl _commit(
      int _FileHandle
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _creat(
      char const* _FileName,
        int         _PermissionMode
    );

 
 int __cdecl _dup(
      int _FileHandle
    );

 
 int __cdecl _dup2(
      int _FileHandleSrc,
      int _FileHandleDst
    );

 
 int __cdecl _eof(
      int _FileHandle
    );

 
 long __cdecl _filelength(
      int _FileHandle
    );

 
 
 intptr_t __cdecl _findfirst32(
      char const*           _FileName,
       struct _finddata32_t* _FindData
    );

 
 
 int __cdecl _findnext32(
       intptr_t              _FindHandle,
      struct _finddata32_t* _FindData
    );


 int __cdecl _findclose(
      intptr_t _FindHandle
    );

 intptr_t __cdecl _get_osfhandle(
          int _FileHandle
        );

 
 int __cdecl _isatty(
      int _FileHandle
    );

 int __cdecl _locking(
          int  _FileHandle,
          int  _LockMode,
          long _NumOfBytes
        );


 long __cdecl _lseek(
      int  _FileHandle,
      long _Offset,
      int  _Origin
    );

 

 errno_t __cdecl _mktemp_s(
      char*  _TemplateName,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mktemp_s(  char (&_TemplateName)[_Size]) throw() { return _mktemp_s(_TemplateName, _Size); } }
#line 224 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_mktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char * __cdecl _mktemp( char *_TemplateName);
#line 230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"

 int __cdecl _open_osfhandle(
      intptr_t _OSFileHandle,
      int      _Flags
    );


     
     
     int __cdecl _pipe(
             int*         _PtHandles,
                        unsigned int _PipeSize,
                        int          _TextMode
        );
#line 245 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"

 
 
 int __cdecl _read(
                                   int          _FileHandle,
      void*        _DstBuf,
                                   unsigned int _MaxCharCount
    );

 int __cdecl remove(
      char const* _FileName
    );

 
 int __cdecl rename(
      char const* _OldFilename,
      char const* _NewFilename
    );

 int __cdecl _unlink(
      char const* _FileName
    );

 
 int __cdecl _setmode(
      int _FileHandle,
      int _Mode
    );

 
 long __cdecl _tell(
      int _FileHandle
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_umask_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _umask(
      int _Mode
    );


 errno_t __cdecl _umask_s(
       int  _NewMode,
      int* _OldMode
    );

 int __cdecl _write(
                                 int          _FileHandle,
      void const*  _Buf,
                                 unsigned int _MaxCharCount
    );

 
 __int64 __cdecl _filelengthi64(
      int _FileHandle
    );

 
 
 intptr_t __cdecl _findfirst32i64(
      char const*              _FileName,
       struct _finddata32i64_t* _FindData
    );

 
 
 intptr_t __cdecl _findfirst64i32(
      char const*              _FileName,
       struct _finddata64i32_t* _FindData
    );

 
 
 intptr_t __cdecl _findfirst64(
      char const*            _FileName,
       struct __finddata64_t* _FindData
    );

 
 
 int __cdecl _findnext32i64(
       intptr_t                 _FindHandle,
      struct _finddata32i64_t* _FindData
    );

 
 
 int __cdecl _findnext64i32(
       intptr_t                 _FindHandle,
      struct _finddata64i32_t* _FindData
    );

 
 
 int __cdecl _findnext64(
       intptr_t               _FindHandle,
      struct __finddata64_t* _FindData
    );


 __int64 __cdecl _lseeki64(
      int     _FileHandle,
      __int64 _Offset,
      int     _Origin
    );

 
 __int64 __cdecl _telli64(
      int _FileHandle
    );


 errno_t __cdecl _sopen_s(
       int*        _FileHandle,
      char const* _FileName,
        int         _OpenFlag,
        int         _ShareFlag,
        int         _PermissionMode
    );

 
 errno_t __cdecl _sopen_s_nolock(
       int*        _FileHandle,
      char const* _FileName,
        int         _OpenFlag,
        int         _ShareFlag,
        int         _PermissionMode
    );

 errno_t __cdecl _sopen_dispatch(
      char const* _FileName,
        int         _OFlag,
        int         _ShFlag,
        int         _PMode,
       int*        _PFileHandle,
        int         _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _open(
          char const* const _FileName,
            int         const _OFlag,
            int         const _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _sopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _sopen(
          char const* const _FileName,
            int         const _OFlag,
            int         const _ShFlag,
            int         const _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _sopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
















#line 430 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"




    
    #pragma warning(push)
    #pragma warning(disable: 4141)

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_access" ". See online help for details."))
     int __cdecl access(
          char const* _FileName,
            int         _AccessMode
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chmod" ". See online help for details."))
     int __cdecl chmod(
          char const* _FileName,
            int         _AccessMode
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chsize" ". See online help for details."))
     int __cdecl chsize(
          int  _FileHandle,
          long _Size
        );
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_close" ". See online help for details."))
     int __cdecl close(
          int _FileHandle
    );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_creat" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     int __cdecl creat(
          char const* _FileName,
            int         _PermissionMode
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_dup" ". See online help for details."))
     int __cdecl dup(
          int _FileHandle
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_dup2" ". See online help for details."))
     int __cdecl dup2(
          int _FileHandleSrc,
          int _FileHandleDst
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_eof" ". See online help for details."))
     int __cdecl eof(
          int _FileHandle
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_filelength" ". See online help for details."))
     long __cdecl filelength(
          int _FileHandle
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_isatty" ". See online help for details."))
     int __cdecl isatty(
          int _FileHandle
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_locking" ". See online help for details."))
     int __cdecl locking(
          int  _FileHandle,
          int  _LockMode,
          long _NumOfBytes
        );
    
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lseek" ". See online help for details."))
     long __cdecl lseek(
          int  _FileHandle,
          long _Offset,
          int  _Origin
        );
    
     
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_mktemp" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_mktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char * __cdecl mktemp(
          char* _TemplateName
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_open" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     int __cdecl open(
          char const* _FileName,
            int         _OpenFlag,
        ...);
    
     
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_read" ". See online help for details."))
     int __cdecl read(
                                       int          _FileHandle,
          void*        _DstBuf,
                                       unsigned int _MaxCharCount
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_setmode" ". See online help for details."))
     int __cdecl setmode(
          int _FileHandle,
          int _Mode
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_sopen" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     int __cdecl sopen(
          char const* _FileName,
          int         _OpenFlag,
          int         _ShareFlag,
        ...);
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tell" ". See online help for details."))
     long __cdecl tell(
          int _FileHandle
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_umask" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_umask_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     int __cdecl umask(
          int _Mode
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
     int __cdecl unlink(
          char const* _FileName
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_write" ". See online help for details."))
     int __cdecl write(
                                     int          _FileHandle,
          void const*  _Buf,
                                     unsigned int _MaxCharCount
        );
    
    #pragma warning(pop)
#line 564 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_io.h"



} __pragma(pack(pop))
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\io.h"
#line 397 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 398 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




struct _RTL_CRITICAL_SECTION;






#line 410 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 415 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 422 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 424 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 425 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 430 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"









#line 440 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"











#line 452 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








































#line 493 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 494 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 503 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 511 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"













#line 525 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 532 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"












#line 545 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"









































#line 587 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 589 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





#line 595 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"










#line 606 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 615 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 623 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 624 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 633 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


#line 636 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 637 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


















#line 657 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 664 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





#line 670 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 672 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 680 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 687 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 691 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















#line 707 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















#line 723 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

















#line 741 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"

#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4100 4296 4521 4522)

namespace std {
	
template<class _Src,
	class _Dest>
	struct _Tuple_enable
	{	
	};

template<>
	struct _Tuple_enable<tuple<>, tuple<> >
	{	
	typedef void ** type;
	};

template<class _Src0,
	class... _Types1,
	class _Dest0,
	class... _Types2>
	struct _Tuple_enable<tuple<_Src0, _Types1...>,
		tuple<_Dest0, _Types2...> >
	: _If<is_convertible<_Src0, _Dest0>::value,
		_Tuple_enable<tuple<_Types1...>, tuple<_Types2...> >,
		_Tuple_enable<int, int>
	>::type
	{	
	};


	
struct _Ignore
	{	
	template<class _Ty>
		void operator=(const _Ty&) const
		{	
		}
	};

constexpr _Ignore ignore{};

		
struct _Tuple_alloc_t
	{	
	};

constexpr _Tuple_alloc_t _Tuple_alloc{};

	
template<class _Ty>
	struct _Tuple_val
	{	
	constexpr _Tuple_val()
		: _Val()
		{	
		}

	template<class _Other>
		constexpr _Tuple_val(_Other&& _Arg)
		: _Val(::std:: forward<_Other>(_Arg))
		{	
		}

	template<class _Other>
		_Tuple_val& operator=(_Other&& _Right)
		{	
		_Val = ::std:: forward<_Other>(_Right);
		return (*this);
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc&,
			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& !is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)..., _Al)
		{	
		}


	_Ty _Val;
	};

	
template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	
public:
	typedef tuple<> _Myt;

	constexpr tuple() noexcept
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) noexcept
		{	
		}

	constexpr tuple(const tuple&) noexcept
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
		{	
		}

	void swap(_Myt&) noexcept
		{	
		}

	constexpr bool _Equals(const _Myt&) const noexcept
		{	
		return (true);
		}

	constexpr bool _Less(const _Myt&) const noexcept
		{	
		return (false);
		}
	};

struct _One_arg_t
	{	
	};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: private tuple<_Rest...>
	{	
public:
	typedef _This _This_type;
	typedef tuple<_This, _Rest...> _Myt;
	typedef tuple<_Rest...> _Mybase;
	static const size_t _Mysize = 1 + sizeof...(_Rest);

	constexpr tuple()
		: _Mybase(),
			_Myfirst()
		{	
		}

	template<class... _Rest2>
		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
			: _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
				_Myfirst(allocator_arg)
		{	
		}

	template<class... _Other,
		class = typename _Tuple_enable<
			tuple<const _Other&...>, _Myt>::type>
		constexpr tuple(const tuple<_Other...>& _Right)
		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
		{	
		}

	template<class _Alloc,
		class... _Other,
		class = typename _Tuple_enable<
			tuple<const _Other&...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	
		}

	constexpr explicit tuple(const _This& _This_arg,
		const _Rest&... _Rest_arg)
		: _Mybase(_Rest_arg...),
			_Myfirst(_This_arg)
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: _Mybase(allocator_arg, _Al, _Rest_arg...),
			_Myfirst(_Al, _Tuple_alloc, _This_arg)
		{	
		}

	template<class _This2,
		class... _Rest2,
		class = typename _Tuple_enable<
			tuple<_This2, _Rest2...>, _Myt>::type>
		constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		class = typename _Tuple_enable<
			tuple<_This2, _Rest2...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class... _Other,
		class = typename _Tuple_enable<
			tuple<_Other...>, _Myt>::type>
		constexpr tuple(tuple<_Other...>&& _Right)
		: _Mybase((typename tuple<_Other...>::_Mybase&&)_Right),
			_Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>
				(_Right._Myfirst._Val))
		{	
		}

	template<class _Alloc,
		class... _Other,
		class = typename _Tuple_enable<
			tuple<_Other...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<typename tuple<_Other...>::_Mybase>
					(_Right._Get_rest())),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<typename tuple<_Other...>::_This_type>
					(_Right._Myfirst._Val))
		{	
		}

	template<class... _Other>
		_Myt& operator=(const tuple<_Other...>& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class... _Other>
		_Myt& operator=(tuple<_Other...>&& _Right)
		{	
		_Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
			(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<typename tuple<_Other...>::_Mybase>
			(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other>
		constexpr bool _Equals(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		constexpr bool _Less(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al),
			_Myfirst(_Al, _Tuple_alloc)
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _Myt& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	
		}

	tuple(const _Myt&) = default;
	tuple(_Myt&&) = default;

	template<class _Tag,
		class _This2,
		class = typename enable_if<is_same<_Tag, _One_arg_t>::value>::type>
		constexpr tuple(_Tag, _This2&& _This_arg)
		: _Mybase(),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<const _First&, const _Second&>, _Myt>::type>
		constexpr tuple(const pair<_First, _Second>& _Right)

		: _Mybase(_One_arg_t(), _Right.second),
			_Myfirst(_Right.first)
		{	
		
		}

	template<class _Alloc,
		class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<const _First&, const _Second&>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)

		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
			_Myfirst(_Al, _Tuple_alloc,
				_Right.first)
		{	
		
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(const pair<_First, _Second>& _Right)
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _Right.first;
		_Get_rest()._Myfirst._Val = _Right.second;
		return (*this);
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_Myt&& _Right)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<_Mybase>(_Right._Get_rest())),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_This>(_Right._Myfirst._Val))
		{	
		}

	template<class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<_First, _Second>, _Myt>::type>
		constexpr tuple(pair<_First, _Second>&& _Right)

		: _Mybase(_One_arg_t(), ::std:: forward<_Second>(_Right.second)),
			_Myfirst(::std:: forward<_First>(_Right.first))
		{	
		
		}

	template<class _Alloc,
		class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<_First, _Second>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)

		: _Mybase(allocator_arg, _Al,
				tuple<_Second>(::std:: forward<_Second>(_Right.second))),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_First>(_Right.first))
		{	
		
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)
#line 426 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
		{	
		_Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(pair<_First, _Second>&& _Right)
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = ::std:: forward<_First>(_Right.first);
		_Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
		return (*this);
		}

	_Mybase& _Get_rest() noexcept
		{	
		return (*this);
		}

	constexpr const _Mybase& _Get_rest() const noexcept
		{	
		return (*this);
		}

	void swap(tuple& _Right)
		noexcept(noexcept(_Swap_adl(this->_Myfirst._Val, _Right._Myfirst._Val)) && noexcept(_Swap_adl(_Right._Get_rest(), _Right._Get_rest())))
#line 457 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
		{	
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap(_Right._Get_rest());
		}

	_Tuple_val<_This> _Myfirst;	
	};


	

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator==(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator!=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator<(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator>=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator>(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator<=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class... _Types> inline
	void swap(tuple<_Types...>& _Left,
		tuple<_Types...>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	return (_Left.swap(_Right));
	}


	
template<class _Ty,
	class _Tuple>
	struct _Tuple_element;

template<class _This,
	class... _Rest>
	struct _Tuple_element<_This, tuple<_This, _Rest...> >
	{	
	typedef int _Check_type;
	static_assert(is_void<typename _Tuple_element<_This,
		tuple<_Rest...> >::_Check_type>::value,
		"duplicate type T in get<T>(tuple)");

	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<class _Ty,
	class _This,
	class... _Rest>
	struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
		: public _Tuple_element<_Ty, tuple<_Rest...> >
	{	
	};

template<class _Ty>
	struct _Tuple_element<_Ty, tuple<> >
	{	
	typedef void _Check_type;	
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

	
template<size_t _Index,
	class... _Types> inline
	constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
		get(tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
		get(const tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
		get(tuple<_Types...>&& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
		_RRtype;
	return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	
template<class _Ty,
	class... _Types> inline
	constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	
template<class... _Types> inline
	constexpr tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(::std:: forward<_Types>(_Args)...));
	}

	
template<class... _Types> inline
	constexpr tuple<_Types&...>
		tie(_Types&... _Args) noexcept
	{	
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}


	

template<class... _Types> inline
	constexpr tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) noexcept
	{	
	return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
	}


	
template<class _Seq_type1,
	class _Seq_type2>
	struct _Cat_sequences;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
		integer_sequence<size_t, _Indexes2...> >
	{	
	typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
	};

	
template<class _Ty,
	size_t _Size>
	class array;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

	
template<class _Ty,
	class... _For_array>
	struct _View_as_tuple
	{	
	static_assert(_Always_false<_Ty>::value,
		"Unsupported tuple_cat arguments.");
	};

template<class... _Types>
	struct _View_as_tuple<tuple<_Types...> >
	{	
	typedef tuple<_Types...> type;
	};

template<class _Ty1,
	class _Ty2>
	struct _View_as_tuple<pair<_Ty1, _Ty2> >
	{	
	typedef tuple<_Ty1, _Ty2> type;
	};

template<class _Ty,
	class... _Types>
	struct _View_as_tuple<array<_Ty, 0>, _Types...>
	{	
	typedef tuple<_Types...> type;
	};

template<class _Ty,
	size_t _Size,
	class... _Types>
	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
	{	
	};

	
template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	
	};

	
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	
	static_assert(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_seq;
	typedef _Ix_arg _Ix_arg_seq;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
		integer_sequence<size_t, _Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_sequences<_Kx_arg,

				make_integer_sequence<size_t, sizeof...(_Types2)> >::type,

			integer_sequence<size_t, _Ix...,
				_Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, integer_sequence<size_t>,
				integer_sequence<size_t>, 0,
			typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
	{	
	};

template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty> inline
	constexpr _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
		integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
	{	
	return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
	}

template<class... _Tuples> inline
	constexpr typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
		::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
	}



	
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>)
		: first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
			second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
		{	
		}

	
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
		: pair(_Val1, _Val2,
			make_integer_sequence<size_t, sizeof...(_Types1)>(),
			make_integer_sequence<size_t, sizeof...(_Types2)>())
		{	
		}

}

namespace std {
	
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	
	};

}	

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 874 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
#line 875 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"





#line 744 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 745 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 747 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



















#line 767 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 769 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 771 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 781 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 783 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
#line 784 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 796 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"













#line 811 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 819 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








#line 828 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















#line 844 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"














#line 859 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 863 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


#line 866 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



















#line 886 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 888 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


























#line 915 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 922 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 927 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 929 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


#line 932 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 936 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






#line 943 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 948 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 950 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"










#line 961 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 963 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"









#line 973 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 975 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"









#line 985 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 987 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

namespace testing {

class Message;





using ::std::tr1::get;
using ::std::tr1::make_tuple;
using ::std::tr1::tuple;
using ::std::tr1::tuple_size;
using ::std::tr1::tuple_element;
#line 1002 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

namespace internal {




class Secret;


















#line 1028 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
template <bool>
  struct CompileAssert {
};




#line 1036 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















































template <typename T1, typename T2>
struct StaticAssertTypeEqHelper;

template <typename T>
struct StaticAssertTypeEqHelper<T, T> {
  enum { value = true };
};






#line 1097 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
typedef ::std::string string;
#line 1099 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 1103 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
typedef ::std::wstring wstring;
#line 1105 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



 bool IsTrue(bool condition);





template <typename T>
class scoped_ptr {
 public:
  typedef T element_type;

  explicit scoped_ptr(T* p = 0) : ptr_(p) {}
  ~scoped_ptr() { reset(); }

  T& operator*() const { return *ptr_; }
  T* operator->() const { return ptr_; }
  T* get() const { return ptr_; }

  T* release() {
    T* const ptr = ptr_;
    ptr_ = 0;
    return ptr;
  }

  void reset(T* p = 0) {
    if (p != ptr_) {
      if (IsTrue(sizeof(T) > 0)) {  
        delete ptr_;
      }
      ptr_ = p;
    }
  }

  friend void swap(scoped_ptr& a, scoped_ptr& b) {
    using std::swap;
    swap(a.ptr_, b.ptr_);
  }

 private:
  T* ptr_;

  scoped_ptr(scoped_ptr const &); void operator=(scoped_ptr const &);
};





class  RE {
 public:
  
  
  RE(const RE& other) { Init(other.pattern()); }

  
  RE(const ::std::string& regex) { Init(regex.c_str()); }  





#line 1170 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

  RE(const char* regex) { Init(regex); }  
  ~RE();

  
  const char* pattern() const { return pattern_; }

  
  
  
  
  
  
  
  static bool FullMatch(const ::std::string& str, const RE& re) {
    return FullMatch(str.c_str(), re);
  }
  static bool PartialMatch(const ::std::string& str, const RE& re) {
    return PartialMatch(str.c_str(), re);
  }










#line 1201 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

  static bool FullMatch(const char* str, const RE& re);
  static bool PartialMatch(const char* str, const RE& re);

 private:
  void Init(const char* regex);

  
  
  
  const char* pattern_;
  bool is_valid_;






#line 1220 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

  const char* full_pattern_;  

#line 1224 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

  void operator=(RE const &);
};



 ::std::string FormatFileLocation(const char* file, int line);




 ::std::string FormatCompilerIndependentFileLocation(const char* file,
                                                               int line);







enum GTestLogSeverity {
  GTEST_INFO,
  GTEST_WARNING,
  GTEST_ERROR,
  GTEST_FATAL
};




class  GTestLog {
 public:
  GTestLog(GTestLogSeverity severity, const char* file, int line);

  
  ~GTestLog();

  ::std::ostream& GetStream() { return ::std::cerr; }

 private:
  const GTestLogSeverity severity_;

  GTestLog(GTestLog const &); void operator=(GTestLog const &);
};







inline void LogToStderr() {}
inline void FlushInfoLog() { fflush(0); }

#line 1279 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"






















#line 1302 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"













#line 1316 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
template <typename T>
const T& move(const T& t) {
  return t;
}
#line 1321 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





















template<typename To>
inline To ImplicitCast_(To x) { return x; }






















template<typename To, typename From>  
inline To DownCast_(From* f) {  
  
  
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4127))
  if (false) {
  __pragma(warning(pop))
    const To to = 0;
    ::testing::internal::ImplicitCast_<From*>(to);
  }


  
  switch (0) case 0: default: if (::testing::internal::IsTrue(f == 0 || dynamic_cast<To>(f) != 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h", 1381).GetStream() << "Condition " "f == NULL || dynamic_cast<To>(f) != NULL" " failed. ";
#line 1383 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
  return static_cast<To>(f);
}






template <class Derived, class Base>
Derived* CheckedDowncastToActualType(Base* base) {

  switch (0) case 0: default: if (::testing::internal::IsTrue(typeid(*base) == typeid(Derived))) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h", 1394).GetStream() << "Condition " "typeid(*base) == typeid(Derived)" " failed. ";
#line 1396 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 1400 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
  return dynamic_cast<Derived*>(base);  


#line 1404 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
}









 void CaptureStdout();
 std::string GetCapturedStdout();
 void CaptureStderr();
 std::string GetCapturedStderr();

#line 1420 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


 std::string TempDir();


 size_t GetFileSize(FILE* file);


 std::string ReadEntireFile(FILE* file);


 const ::std::vector<testing::internal::string>& GetArgvs();



const ::std::vector<testing::internal::string>& GetInjectableArgvs();
void SetInjectableArgvs(const ::std::vector<testing::internal::string>*
                             new_argvs);


#line 1441 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"














#line 1456 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





#line 1462 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"











































#line 1506 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

 void SleepMilliseconds(int n);



class  AutoHandle {
 public:
  
  
  
  
  
  typedef void* Handle;
  AutoHandle();
  explicit AutoHandle(Handle handle);

  ~AutoHandle();

  Handle Get() const;
  void Reset();
  void Reset(Handle handle);

 private:
  
  bool IsCloseable() const;

  Handle handle_;

  AutoHandle(AutoHandle const &); void operator=(AutoHandle const &);
};







class  Notification {
 public:
  Notification();
  void Notify();
  void WaitForNotification();

 private:
  AutoHandle event_;

  Notification(Notification const &); void operator=(Notification const &);
};
#line 1555 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"


















































































#line 1638 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
         





#line 1645 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















class  Mutex {
 public:
  enum MutexType { kStatic = 0, kDynamic = 1 };
  
  
  
  enum StaticConstructorSelector { kStaticMutex = 0 };

  
  
  
  explicit Mutex(StaticConstructorSelector ) {}

  Mutex();
  ~Mutex();

  void Lock();

  void Unlock();

  
  
  void AssertHeld();

 private:
  
  void ThreadSafeLazyInit();

  
  
  unsigned int owner_thread_id_;

  
  
  MutexType type_;
  long critical_section_init_phase_;  
  _RTL_CRITICAL_SECTION* critical_section_;

  Mutex(Mutex const &); void operator=(Mutex const &);
};












class GTestMutexLock {
 public:
  explicit GTestMutexLock(Mutex* mutex)
      : mutex_(mutex) { mutex_->Lock(); }

  ~GTestMutexLock() { mutex_->Unlock(); }

 private:
  Mutex* const mutex_;

  GTestMutexLock(GTestMutexLock const &); void operator=(GTestMutexLock const &);
};

typedef GTestMutexLock MutexLock;



class ThreadLocalValueHolderBase {
 public:
  virtual ~ThreadLocalValueHolderBase() {}
};



class ThreadLocalBase {
 public:
  
  
  
  
  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;

 protected:
  ThreadLocalBase() {}
  virtual ~ThreadLocalBase() {}

 private:
  ThreadLocalBase(ThreadLocalBase const &); void operator=(ThreadLocalBase const &);
};




class  ThreadLocalRegistry {
 public:
  
  
  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(
      const ThreadLocalBase* thread_local_instance);

  
  static void OnThreadLocalDestroyed(
      const ThreadLocalBase* thread_local_instance);
};

class  ThreadWithParamBase {
 public:
  void Join();

 protected:
  class Runnable {
   public:
    virtual ~Runnable() {}
    virtual void Run() = 0;
  };

  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);
  virtual ~ThreadWithParamBase();

 private:
  AutoHandle thread_;
};


template <typename T>
class ThreadWithParam : public ThreadWithParamBase {
 public:
  typedef void UserThreadFunc(T);

  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)
      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {
  }
  virtual ~ThreadWithParam() {}

 private:
  class RunnableImpl : public Runnable {
   public:
    RunnableImpl(UserThreadFunc* func, T param)
        : func_(func),
          param_(param) {
    }
    virtual ~RunnableImpl() {}
    virtual void Run() {
      func_(param_);
    }

   private:
    UserThreadFunc* const func_;
    const T param_;

    RunnableImpl(RunnableImpl const &); void operator=(RunnableImpl const &);
  };

  ThreadWithParam(ThreadWithParam const &); void operator=(ThreadWithParam const &);
};




























template <typename T>
class ThreadLocal : public ThreadLocalBase {
 public:
  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}
  explicit ThreadLocal(const T& value)
      : default_factory_(new InstanceValueHolderFactory(value)) {}

  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }

  T* pointer() { return GetOrCreateValue(); }
  const T* pointer() const { return GetOrCreateValue(); }
  const T& get() const { return *pointer(); }
  void set(const T& value) { *pointer() = value; }

 private:
  
  
  class ValueHolder : public ThreadLocalValueHolderBase {
   public:
    ValueHolder() : value_() {}
    explicit ValueHolder(const T& value) : value_(value) {}

    T* pointer() { return &value_; }

   private:
    T value_;
    ValueHolder(ValueHolder const &); void operator=(ValueHolder const &);
  };


  T* GetOrCreateValue() const {
    return static_cast<ValueHolder*>(
        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();
  }

  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {
    return default_factory_->MakeNewHolder();
  }

  class ValueHolderFactory {
   public:
    ValueHolderFactory() {}
    virtual ~ValueHolderFactory() {}
    virtual ValueHolder* MakeNewHolder() const = 0;

   private:
    ValueHolderFactory(ValueHolderFactory const &); void operator=(ValueHolderFactory const &);
  };

  class DefaultValueHolderFactory : public ValueHolderFactory {
   public:
    DefaultValueHolderFactory() {}
    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }

   private:
    DefaultValueHolderFactory(DefaultValueHolderFactory const &); void operator=(DefaultValueHolderFactory const &);
  };

  class InstanceValueHolderFactory : public ValueHolderFactory {
   public:
    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}
    virtual ValueHolder* MakeNewHolder() const {
      return new ValueHolder(value_);
    }

   private:
    const T value_;  

    InstanceValueHolderFactory(InstanceValueHolderFactory const &); void operator=(InstanceValueHolderFactory const &);
  };

  scoped_ptr<ValueHolderFactory> default_factory_;

  ThreadLocal(ThreadLocal const &); void operator=(ThreadLocal const &);
};















































































































































































































#line 2128 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"














































#line 2175 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



 size_t GetThreadCount();











#line 2191 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 2193 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







#line 2201 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

template <bool bool_value>
struct bool_constant {
  typedef bool_constant<bool_value> type;
  static const bool value = bool_value;
};
template <bool bool_value> const bool bool_constant<bool_value>::value;

typedef bool_constant<false> false_type;
typedef bool_constant<true> true_type;

template <typename T>
struct is_pointer : public false_type {};

template <typename T>
struct is_pointer<T*> : public true_type {};

template <typename Iterator>
struct IteratorTraits {
  typedef typename Iterator::value_type value_type;
};

template <typename T>
struct IteratorTraits<T*> {
  typedef T value_type;
};

template <typename T>
struct IteratorTraits<const T*> {
  typedef T value_type;
};





typedef __int64 BiggestInt;




#line 2243 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








inline bool IsAlpha(char ch) {
  return isalpha(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsAlNum(char ch) {
  return isalnum(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsDigit(char ch) {
  return isdigit(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsLower(char ch) {
  return islower(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsSpace(char ch) {
  return isspace(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsUpper(char ch) {
  return isupper(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsXDigit(char ch) {
  return isxdigit(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsXDigit(wchar_t ch) {
  const unsigned char low_byte = static_cast<unsigned char>(ch);
  return ch == low_byte && isxdigit(low_byte) != 0;
}

inline char ToLower(char ch) {
  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
}
inline char ToUpper(char ch) {
  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));
}

inline std::string StripTrailingSpaces(std::string str) {
  std::string::iterator it = str.end();
  while (it != str.begin() && IsSpace(*--it))
    it = str.erase(it);
  return str;
}







namespace posix {





typedef struct _stat64i32 StatStruct;










#line 2315 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline int IsATTY(int fd) { return _isatty(fd); }
#line 2317 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline int StrCaseCmp(const char* s1, const char* s2) {
  return _stricmp(s1, s2);
}
inline char* StrDup(const char* src) { return _strdup(src); }
#line 2322 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





#line 2328 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline int FileNo(FILE* file) { return _fileno(file); }
inline int Stat(const char* path, StatStruct* buf) { return _stat64i32(path, buf); }
inline int RmDir(const char* dir) { return _rmdir(dir); }
inline bool IsDir(const StatStruct& st) {
  return (0x4000 & st.st_mode) != 0;
}
#line 2335 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"















#line 2351 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



__pragma(warning(push)) __pragma(warning(disable: 4996))

inline const char* StrNCpy(char* dest, const char* src, size_t n) {
  return strncpy(dest, src, n);
}






inline int ChDir(const char* dir) { return chdir(dir); }
#line 2367 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline FILE* FOpen(const char* path, const char* mode) {
  return fopen(path, mode);
}

inline FILE *FReopen(const char* path, const char* mode, FILE* stream) {
  return freopen(path, mode, stream);
}
inline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }
#line 2376 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline int FClose(FILE* fp) { return fclose(fp); }

inline int Read(int fd, void* buf, unsigned int count) {
  return static_cast<int>(read(fd, buf, count));
}
inline int Write(int fd, const void* buf, unsigned int count) {
  return static_cast<int>(write(fd, buf, count));
}
inline int Close(int fd) { return close(fd); }
inline const char* StrError(int errnum) { return strerror(errnum); }
#line 2387 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline const char* GetEnv(const char* name) {




#line 2393 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"




#line 2398 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
  return getenv(name);
#line 2400 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
}

__pragma(warning(pop))






#line 2410 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
inline void Abort() { abort(); }
#line 2412 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

}  
















#line 2431 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"








const BiggestInt kMaxBiggestInt =
    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));



















template <size_t size>
class TypeWithSize {
 public:
  
  
  typedef void UInt;
};


template <>
class TypeWithSize<4> {
 public:
  
  
  
  
  typedef int Int;
  typedef unsigned int UInt;
};


template <>
class TypeWithSize<8> {
 public:

  typedef __int64 Int;
  typedef unsigned __int64 UInt;



#line 2491 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"
};


typedef TypeWithSize<4>::Int Int32;
typedef TypeWithSize<4>::UInt UInt32;
typedef TypeWithSize<8>::Int Int64;
typedef TypeWithSize<8>::UInt UInt64;
typedef TypeWithSize<8>::Int TimeInMillis;  






#line 2506 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



#line 2510 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"



















#line 2530 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"





#line 2536 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"







bool ParseInt32(const Message& src_text, const char* str, Int32* value);



bool BoolFromGTestEnv(const char* flag, bool default_val);
 Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
std::string StringFromGTestEnv(const char* flag, const char* default_val);

}  
}  

#line 2555 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-port.h"

#line 41 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"






#line 48 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"



#line 52 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iomanip"

#pragma once







#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4275)

namespace std {
		
struct money_base
	: public locale::facet
	{	
	enum
		{	
		symbol = '$', sign = '+', space = ' ', value = 'v', none = 'x'};
	typedef int part;

	struct pattern
		{	
		char field[4];
		};

	money_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}
	};

		
template<class _Elem>
	class _Mpunct
		: public money_base
	{	
public:
	typedef _Elem char_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type curr_symbol() const
		{	
		return (do_curr_symbol());
		}

	string_type positive_sign() const
		{	
		return (do_positive_sign());
		}

	string_type negative_sign() const
		{	
		return (do_negative_sign());
		}

	int frac_digits() const
		{	
		return (do_frac_digits());
		}

	pattern pos_format() const
		{	
		return (do_pos_format());
		}

	pattern neg_format() const
		{	
		return (do_neg_format());
		}

	explicit _Mpunct(size_t _Refs, bool _Intl)
		: money_base(_Refs), _International(_Intl)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	_Mpunct(const _Locinfo& _Lobj, size_t _Refs, bool _Intl,
		bool _Isdef = false)
		: money_base(_Refs), _International(_Intl)
		{	
		_Init(_Lobj, _Isdef);
		}

protected:
	_Mpunct(const char *_Locname, size_t _Refs,
		bool _Intl, bool _Isdef = false)
		: money_base(_Refs), _International(_Intl)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	virtual  ~_Mpunct() noexcept
		{	
		_Tidy();
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr)
		{	
		_Currencysign = _Maklocstr(_International ? _Ptr->int_curr_symbol : _Ptr->currency_symbol, (_Elem2 *)0, _Cvt);
#line 126 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"
		_Plussign = _Maklocstr(4 < (unsigned int)_Ptr->p_sign_posn ? "" : _Ptr->positive_sign, (_Elem2 *)0, _Cvt);
#line 128 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"
		_Minussign = _Maklocstr(4 < (unsigned int)_Ptr->n_sign_posn ? "-" : _Ptr->negative_sign, (_Elem2 *)0, _Cvt);
#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"
		_Decimalpoint = _Maklocchr(_Ptr->mon_decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->mon_thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr)
		{	
		_Currencysign = (const _Elem *)_Maklocwcs(_International
			? _Ptr->_W_int_curr_symbol : _Ptr->_W_currency_symbol);
		_Plussign = (const _Elem *)_Maklocwcs(
			4 < (unsigned int)_Ptr->p_sign_posn
				? L"" : _Ptr->_W_positive_sign);
		_Minussign = (const _Elem *)_Maklocwcs(
			4 < (unsigned int)_Ptr->n_sign_posn
				? L"-" : _Ptr->_W_negative_sign);
		_Decimalpoint = (_Elem)_Ptr->_W_mon_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_mon_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		_Cvt = _Lobj._Getcvt();
		const lconv *_Ptr = _Lobj._Getlconv();

		_Grouping = 0;
		_Currencysign = 0;
		_Plussign = 0;
		_Minussign = 0;

		try {
		_Grouping = _Maklocstr(_Ptr->mon_grouping, (char *)0, _Cvt);
		_Getvals((_Elem)0, _Ptr);
		} catch (...) {
		_Tidy();
		throw;
		}

		_Fracdigits = _International ? _Ptr->int_frac_digits
			: _Ptr->frac_digits;
		if (_Fracdigits < 0 || 127 <= _Fracdigits)
			_Fracdigits = 0;

		_Makpat(_Plusformat, _Ptr->p_sep_by_space,
			_Ptr->p_cs_precedes, _Ptr->p_sign_posn);
		_Makpat(_Minusformat, _Ptr->n_sep_by_space,
			_Ptr->n_cs_precedes, _Ptr->n_sign_posn);

		if (_Isdef)
			{	
			:: memcpy(&_Plusformat, "$+xv", 4);
			:: memcpy(&_Minusformat, "$+xv", 4);
			}
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Decimalpoint);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_curr_symbol() const
		{	
		return (string_type(_Currencysign));
		}

	virtual string_type  do_positive_sign() const
		{	
		return (string_type(_Plussign));
		}

	virtual string_type  do_negative_sign() const
		{	
		return (string_type(_Minussign));
		}

	virtual int  do_frac_digits() const
		{	
		return (_Fracdigits);
		}

	virtual pattern  do_pos_format() const
		{	
		return (_Plusformat);
		}

	virtual pattern  do_neg_format() const
		{	
		return (_Minusformat);
		}

private:
	void _Makpat(pattern& _Pattern, unsigned int _Sepbyspace,
		unsigned int _Symbolprecedes, unsigned int _Signposition)
		{	
		const char *_Ptr = _International || 2 < _Sepbyspace
			|| 1 < _Symbolprecedes || 4 < _Signposition
				? "$+xv"	
				: &(
				"+v$x" "+v$x" "v$+x" "v+$x" "v$+x"
				"+$vx" "+$vx" "$v+x" "+$vx" "$+vx"
				"+v $" "+v $" "v $+" "v +$" "v $+"
				"+$ v" "+$ v" "$ v+" "+$ v" "$+ v"
				"+xv$" "+ v$" "v$ +" "v+ $" "v$ +"
				"+x$v" "+ $v" "$v +" "+ $v" "$ +v")
					[_Signposition * 4	
					+ _Symbolprecedes * 20	
					+ _Sepbyspace * 40];	

		::memcpy_s((_Pattern.field), (sizeof (_Pattern.field)), (_Ptr), (4));
		}

	void _Tidy()
		{	
		:: free((void *)_Grouping);
		:: free((void *)_Currencysign);
		:: free((void *)_Plussign);
		:: free((void *)_Minussign);
		}

	const char *_Grouping;	
	_Elem _Decimalpoint;	
	_Elem _Kseparator;	
	const _Elem *_Currencysign;	
	const _Elem *_Plussign;	
	const _Elem *_Minussign;	
	int _Fracdigits;	
	pattern _Plusformat;	
	pattern _Minusformat;	
	bool _International;	

	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem,
	bool _Intl = false>
	class moneypunct
		: public _Mpunct<_Elem>
	{	
public:
	  static const bool intl;	
	  static locale::id id;	

	explicit moneypunct(size_t _Refs = 0)
		: _Mpunct<_Elem>(_Refs, _Intl)
		{	
		}

	moneypunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: _Mpunct<_Elem>(_Lobj, _Refs, _Intl, _Isdef)
		{	
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new moneypunct<_Elem, _Intl>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (3);
		}

protected:
	moneypunct(const char *_Locname, size_t _Refs = 0)
		: _Mpunct<_Elem>(_Locname, _Refs, _Intl)
		{	
		}

	virtual  ~moneypunct() noexcept
		{	
		}
	};

		
template<class _Elem,
	bool _Intl>
	 const bool moneypunct<_Elem, _Intl>::intl = _Intl;

		
template<class _Elem,
	bool _Intl>
	 locale::id moneypunct<_Elem, _Intl>::id;

		
template<class _Elem,
	bool _Intl = false>
	class moneypunct_byname
		: public moneypunct<_Elem, _Intl>
	{	
public:
	explicit moneypunct_byname(const char *_Locname, size_t _Refs = 0)
		: moneypunct<_Elem, _Intl>(_Locname, _Refs)
		{	
		}

	explicit moneypunct_byname(const string& _Str, size_t _Refs = 0)
		: moneypunct<_Elem, _Intl>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~moneypunct_byname() noexcept
		{	
		}
	};

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_get
		: public locale::facet
	{	
	typedef moneypunct<_Elem, false> _Mypunct0;
	typedef moneypunct<_Elem, true> _Mypunct1;

public:
	typedef _Elem char_type;
	typedef _InIt iter_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_InIt get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			string_type& _Val) const
		{	
		return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}

	  static locale::id id;	

	explicit money_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	money_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new money_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (3);
		}

protected:
	virtual  ~money_get() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Elem _Atoms[sizeof ("0123456789-")];
		string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Str.size() == 0)
			_State |= ios_base::failbit;	
		else
			{	
			const char *_Eb = _Str.c_str();
			char *_Ep;
			int _Errno = 0;
			const long double _Ans =
				:: _Stoldx(_Eb, &_Ep, 0, &_Errno);	

			if (_Ep == _Eb || _Errno != 0)
				_State |= ios_base::failbit;
			else
				_Val = _Ans;	
			}
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			string_type& _Val) const
		{	
		_Elem _Atoms[sizeof ("0123456789-")];
		string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);
		size_t _Len = _Str.size();

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Len == 0)
			_State |= ios_base::failbit;	
		else
			{	
			size_t _Idx = 0;
			_Val.resize(_Len);
			if (_Str[0] == '-')
				_Val[_Idx++] = _Atoms[10];
			for (; _Idx < _Len; ++_Idx)
				_Val[_Idx] = _Atoms[_Str[_Idx] - '0'];	
			}
		return (_First);
		}

private:
	string _Getmfld(_InIt& _First, _InIt& _Last,
		bool _Intl, ios_base& _Iosbase, _Elem *_Atoms) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon", 463);
		const _Mpunct<_Elem> *_Ppunct_fac;
		if (_Intl)
			_Ppunct_fac =
				&use_facet< _Mypunct1 >(_Iosbase.getloc());	
		else
			_Ppunct_fac =
				&use_facet< _Mypunct0 >(_Iosbase.getloc());	

		bool _Bad = false, _Neg = false;
		string_type _Sign;
		const money_base::pattern _Pattern = _Ppunct_fac->neg_format();
		string _Val;
		size_t _Idx;
		static const char _Src[] = {"0123456789-"};
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		for (size_t _Off = 0; !_Bad && _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
				{	
			case money_base::symbol:
				{	
				string_type _Symbol = _Ppunct_fac->curr_symbol();
				typename string_type::const_iterator _Source;

				if (!(_Iosbase.flags() & ios_base::showbase)
					&& _First != _Last && *_First != *_Symbol.c_str())
					_Symbol.erase();	
				else if (_Off == 3 && _Sign.size() <= 1
					&& (_First == _Last || *_First != *_Symbol.c_str()))
					_Symbol.erase();	

				for (_Source = _Symbol.begin();
					_First != _Last && _Source != _Symbol.end()
						&& *_First == *_Source; ++_Source, ++_First)
					;	

				if (_Source != _Symbol.end())
					_Bad = true;	
				break;
				}

			case money_base::sign:	
				if (_First == _Last)
					;	
				else if (0 < (_Ppunct_fac->positive_sign()).size()
					&& _Ppunct_fac->positive_sign()[0] == *_First)
					{	
					++_First;
					_Sign = _Ppunct_fac->positive_sign();
					}
				else if (0 < (_Ppunct_fac->negative_sign()).size()
					&& _Ppunct_fac->negative_sign()[0] == *_First)
					{	
					++_First;
					_Sign = _Ppunct_fac->negative_sign();
					_Neg = true;
					}
				else if (0 == (_Ppunct_fac->positive_sign()).size())
					;
				else if (0 == (_Ppunct_fac->negative_sign()).size())
					_Neg = true;
				break;	

			case money_base::value:
				{	
				int _Fracdigseen = 0;
				int _Fracdigits = _Ppunct_fac->frac_digits();
				const string _Grouping = _Ppunct_fac->grouping();
				const _Elem _Kseparator = _Grouping.size() == 0
					? (_Elem)0 : _Ppunct_fac->thousands_sep();

				if (_Kseparator == (_Elem)0
					|| 127 <= (unsigned char)*_Grouping.c_str())
					for (; _First != _Last
						&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
						++_First)
					_Val += _Src[_Idx];	
				else
					{	
					string _Groups((size_t)1, '\0');
					size_t _Group = 0;

					for (; _First != _Last; ++_First)
						if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
							{	
							_Val += _Src[_Idx];
							if (_Groups[_Group] != 127)
								++_Groups[_Group];
							}
						else if (_Groups[_Group] == '\0'
							|| *_First != _Kseparator)
							break;	
						else
							{	
							_Groups.append((size_t)1, '\0');
							++_Group;
							}

					if (_Group == 0)
						;	
					else if ('\0' < _Groups[_Group])
						++_Group;	
					else
						_Bad = true;	

					for (const char *_Pg = _Grouping.c_str();
						!_Bad && 0 < _Group; )
						if (*_Pg == 127)
							break;	
						else if ((0 < --_Group && *_Pg != _Groups[_Group])
							|| (0 == _Group && *_Pg < _Groups[_Group]))
							_Bad = true;	
						else if ('\0' < _Pg[1])
							++_Pg;	
					if (_Bad)
						break;	
					}

				const _Elem _Point = _Ppunct_fac->decimal_point();
				if (_First != _Last
					&& _Point != (_Elem)0
					&& *_First == _Point)
					{	
					while (++_First != _Last
						&& _Fracdigseen < _Fracdigits
						&& (_Idx = _Find_elem(_Atoms, *_First)) < 10)
						_Val += _Src[_Idx], ++_Fracdigseen;

					if (_Fracdigseen < _Fracdigits)
						_Bad = true;	
					}

				if (_Val.size() == 0)
					_Bad = true;	
				else
					for (; _Fracdigseen < _Fracdigits; ++_Fracdigseen)
						_Val += '0';	
				break;
				}

			case money_base::space:
			case money_base::none:
				{	
				if (_Off == 3)
					break;	

				bool _Seen = false;

				for (; _First != _Last
					&& _Ctype_fac.is(ctype_base::space, *_First); ++_First)
					_Seen = true;	
				if (_Pattern.field[_Off] == money_base::space && !_Seen)
					_Bad = true;	
				}
				}

		if (!_Bad && 1 < _Sign.size())
			{	
			typename string_type::const_iterator _Source;

			for (_Source = _Sign.begin(); ++_Source != _Sign.end()
				&& _First != _Last && *_First == *_Source; ++_First)
				;
			if (_Source != _Sign.end())
				_Bad = true;	
			}

		if (_Bad)
			_Val.erase();	
		else if (_Neg)
			_Val.insert((size_t)0, (size_t)1, '-');	
		return (_Val);
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id money_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_put
		: public locale::facet
	{	
	typedef moneypunct<_Elem, false> _Mypunct0;
	typedef moneypunct<_Elem, true> _Mypunct1;

public:
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_OutIt put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			long double _Val) const
		{	
		return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			const string_type& _Val) const
		{	
		return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}

	  static locale::id id;	

	explicit money_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	money_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new money_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (3);
		}

protected:
	virtual  ~money_put() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			long double _Val) const
		{	
		bool _Negative = false;
		if (_Val < 0)
			_Negative = true, _Val = -_Val;

		size_t _Exp;
		for (_Exp = 0; 1e35 <= _Val && _Exp < 5000; _Exp += 10)
			_Val /= 1e10;	

		char _Buf[40];

		int _Count = :: sprintf_s(_Buf, sizeof (_Buf), "%.0Lf",
			_Val);	

		if (_Count < 0)
			return (_Dest);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		const _Elem _E0 = _Ctype_fac.widen('0');

		string_type _Val2(_Count, (_Elem)0);
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Val2[0]);
		_Val2.append(_Exp, _E0);	
		return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill,
			_Negative, _Val2, _E0));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			const string_type& _Val) const
		{	
		static const char _Src[] = {"0123456789-"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		bool _Negative = false;
		size_t _Idx0 = 0;
		if (!_Val.empty() && _Val[0] == _Atoms[10])
			_Negative = true, ++_Idx0;	

		size_t _Size = _Val.size();
		size_t _Idx = _Idx0;
		for (; _Idx < _Size && _Find_elem(_Atoms, _Val[_Idx]) < 10; ++_Idx)
			;	
		string_type _Val2(&_Val[_Idx0], (size_t)(_Idx - _Idx0));
		if (_Val2.empty())	
			_Val2.append((size_t)1, _Atoms[0]);

		return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill,
			_Negative, _Val2, _Atoms[0]));
		}

private:
	_OutIt _Putmfld(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			bool _Neg, string_type _Val, _Elem _E0) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon", 772);
		const _Mpunct<_Elem> *_Ppunct_fac;
		if (_Intl)
			_Ppunct_fac =
				&use_facet< _Mypunct1 >(_Iosbase.getloc());	
		else
			_Ppunct_fac =
				&use_facet< _Mypunct0 >(_Iosbase.getloc());	

		const string _Grouping = _Ppunct_fac->grouping();
		int _Ifracdigits = _Ppunct_fac->frac_digits();
		unsigned int _Fracdigits = _Ifracdigits < 0 ? -_Ifracdigits
			: _Ifracdigits;

		if (_Val.size() <= _Fracdigits)
			_Val.insert((size_t)0, _Fracdigits - _Val.size() + 1, _E0);
		else if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
			{	
			const _Elem _Kseparator = _Ppunct_fac->thousands_sep();
			const char *_Pg = _Grouping.c_str();
			size_t _Off = _Val.size() - _Fracdigits;	

			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Off)
				{	
				_Val.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		money_base::pattern _Pattern;
		string_type _Sign;
		if (_Neg)
			{	
			_Pattern = _Ppunct_fac->neg_format();
			_Sign = _Ppunct_fac->negative_sign();
			}
		else
			{	
			_Pattern = _Ppunct_fac->pos_format();
			_Sign = _Ppunct_fac->positive_sign();
			}

		string_type _Symbol;
		if (_Iosbase.flags() & ios_base::showbase)
			_Symbol = _Ppunct_fac->curr_symbol();	

		bool _Intern = false;
		size_t _Fillcount, _Off;
		for (_Fillcount = 0, _Off = 0; _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
			{	
			case money_base::symbol:	
				_Fillcount += _Symbol.size();
				break;

			case money_base::sign:	
				_Fillcount += _Sign.size();
				break;

			case money_base::value:	
				_Fillcount += _Val.size() + (0 < _Fracdigits ? 1 : 0)
					+ (_Val.size() <= _Fracdigits
						? _Fracdigits - _Val.size() + 1 : 0);
				break;

			case money_base::space:	
				++_Fillcount;	
				

			case money_base::none:	
				if (_Off != 3)
					_Intern = true;	
				break;
			}

		_Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Fillcount
				? 0 : (size_t)_Iosbase.width() - _Fillcount;

		ios_base::fmtflags _Afl =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left
			&& (_Afl != ios_base::internal || !_Intern))
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}

		for (_Off = 0; _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
				{	
			case money_base::symbol:	
				_Dest = _Put(_Dest, _Symbol.begin(), _Symbol.size());
				break;

			case money_base::sign:	
				if (0 < _Sign.size())
					_Dest = _Put(_Dest, _Sign.begin(), 1);
				break;

			case money_base::value:	
				if (_Fracdigits == 0)
					_Dest = _Put(_Dest, _Val.begin(),
						_Val.size());	
				else if (_Val.size() <= _Fracdigits)
					{	
					*_Dest++ = _E0;
					*_Dest++ = _Ppunct_fac->decimal_point();
					_Dest = _Rep(_Dest, _E0,
						_Fracdigits - _Val.size());	
					_Dest = _Put(_Dest, _Val.begin(), _Val.size());
					}
				else
					{	
					_Dest = _Put(_Dest, _Val.begin(),
						_Val.size() - _Fracdigits);	
					*_Dest++ = _Ppunct_fac->decimal_point();
					_Dest = _Put(_Dest, _Val.end() - _Fracdigits,
						_Fracdigits);	
					}
				break;

			case money_base::space:	
				_Dest = _Rep(_Dest, _Fill, 1);
				

			case money_base::none:	
				if (_Afl == ios_base::internal)
					{	
					_Dest = _Rep(_Dest, _Fill, _Fillcount);
					_Fillcount = 0;
					}
				}

		if (1 < _Sign.size())
			_Dest = _Put(_Dest, _Sign.begin() + 1,
				_Sign.size() - 1);	
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	static _OutIt _Put(_OutIt _Dest,
		typename string_type::const_iterator _Source, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Source)
			*_Dest = *_Source;
		return (_Dest);
		}

	static _OutIt _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id money_put<_Elem, _OutIt>::id;

 











































#line 982 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 988 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"
#line 989 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocmon"






#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iomanip"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ctime"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"
















  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int* __cdecl __daylight(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 long* __cdecl __dstbias(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 long* __cdecl __timezone(void);




    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char** __cdecl __tzname(void);



  
 errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
 errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
 errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
 errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
     errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
 clock_t __cdecl clock(void);

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ctime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ctime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
 double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
 double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


 errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


 errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
 __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
 __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


 __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


 __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

 size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

 size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


 errno_t __cdecl _strdate_s(
        char*  _Buffer,
                                    size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 288 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   char* __cdecl _strdate( char *_Buffer);
#line 293 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"


 errno_t __cdecl _strtime_s(
        char*  _Buffer,
                                    size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 304 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strtime( char *_Buffer);
#line 309 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 __time32_t __cdecl _time32(
      __time32_t* _Time
    );

 __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
 int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
 int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










     void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
     unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 356 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"










    











































































































          __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _ctime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _gmtime64(_Time);
            #pragma warning(pop)
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _localtime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base); 
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 576 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

    #line 578 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details."))  void __cdecl tzset(void);
    #line 595 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

#line 597 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ctime"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ctime"

 
namespace std {
using :: clock_t; using :: size_t;
using :: time_t; using :: tm;
using :: asctime; using :: clock; using :: ctime;
using :: difftime; using :: gmtime; using :: localtime;
using :: mktime; using :: strftime; using :: time;
}
 #line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ctime"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ctime"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4275)

namespace std {
		
struct  time_base
	: public locale::facet
	{	
	enum dateorder
		{	
		no_order, dmy, mdy, ymd, ydm};

	 time_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~time_base() noexcept
		{	
		}
	};

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get
		: public time_base
	{	
public:
	typedef _Elem char_type;
	typedef _InIt iter_type;
	typedef ctype<_Elem> _Ctype;

	 static locale::id id;	

	dateorder  date_order() const
		{	
		return (do_date_order());
		}

	_InIt  get_time(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		return (do_get_time(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_date(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		return (do_get_date(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_weekday(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		return (do_get_weekday(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_monthname(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		return (do_get_monthname(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_year(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		return (do_get_year(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 87);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 88);
		return (do_get(_First, _Last, _Iosbase, _State, _Pt,
			_Specifier, _Modifier));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 97);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 98);
		_Debug_range(_Fmtfirst, _Fmtlast, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 99);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		_State = ios_base::goodbit;

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				{	
				if (_Ctype_fac.is(_Ctype::space, *_Fmtfirst))
					for (; _First != _Last
						&& _Ctype_fac.is(_Ctype::space, *_First); ++_First)
						;
				else if (*_First != *_Fmtfirst)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					++_First;
				}
			else if (++_Fmtfirst == _Fmtlast)
				{	
				if (*_First != _Fmtfirst[-1])
					_State |= ios_base::failbit;
				else
					++_First;
				break;
				}
			else
				{	
				char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier != 'E' && _Specifier != 'O'
					&& _Specifier != 'Q' && _Specifier != '#')
					;	
				else if (++_Fmtfirst == _Fmtlast)
					{	
					if (*_First != _Percent
						|| ++_First == _Last
						|| _Ctype_fac.narrow(*_First) != _Specifier)
						_State |= ios_base::failbit;
					else
						++_First;
					break;
					}
				else
					{	
					_Modifier = _Specifier;
					_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
					}

				_First = do_get(_First, _Last, _Iosbase, _State, _Pt,
					_Specifier, _Modifier);	
				}
		if (_First == _Last)
			_State |= ios_base::eofbit;
		return (_First);
		}

	explicit  time_get(size_t _Refs = 0)
		: time_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: time_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new time_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (5);
		}

protected:
	virtual  ~time_get() noexcept
		{	
		_Tidy();
		}

	 time_get(const char *_Locname, size_t _Refs = 0)
		: time_base(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		_Days = _Maklocstr(_Lobj._Getdays(), (_Elem *)0, _Cvt);
		_Months = _Maklocstr(_Lobj._Getmonths(), (_Elem *)0, _Cvt);
		_Ampm = _Maklocstr(":AM:am:PM:pm", (_Elem *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		_Days = (const _Elem *)_Maklocwcs(
			(const wchar_t *)_Lobj._W_Getdays());
		_Months = (const _Elem *)_Maklocwcs(
			(const wchar_t *)_Lobj._W_Getmonths());
		_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Days = 0;
		_Months = 0;
		_Ampm = 0;

		try {
		_Getvals((_Elem)0, _Lobj);

		_Dateorder = (dateorder)_Lobj._Getdateorder();

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	virtual dateorder  do_date_order() const
		{	
		return (_Dateorder);
		}

	virtual _InIt  do_get_time(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 243);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 244);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		_State |= _Getint(_First, _Last, 0, 23,
			_Pt->tm_hour, _Ctype_fac);

		if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
			_State |= ios_base::failbit;	
		else
			_State |= _Getint(++_First, _Last, 0, 59,
				_Pt->tm_min, _Ctype_fac);

		if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
			_State |= ios_base::failbit;	
		else
			_State |= _Getint(++_First, _Last, 0, 59,
				_Pt->tm_sec, _Ctype_fac);
		return (_First);
		}

	virtual _InIt  do_get_date(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 268);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 269);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		dateorder _Dorder = date_order();
		if (_Dorder == no_order)
			_Dorder = mdy;

		if (_First == _Last)
			;
		else if (!_Ctype_fac.is(_Ctype::digit, *_First))
			{	
			_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
			_Dorder = mdy;
			}
		else if (_Dorder == mdy)
			{	
			_State |= _Getint(_First, _Last, 1, 12,
				_Pt->tm_mon, _Ctype_fac);
			--_Pt->tm_mon;
			}
		else if (_Dorder == dmy)
			_State |= _Getint(_First, _Last, 1, 31,
				_Pt->tm_mday, _Ctype_fac);
		else	
			_First = get_year(_First, _Last, _Iosbase, _State, _Pt);

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			++_First;	

		if (_First != _Last)
			{	
			char _Ch = _Ctype_fac.narrow(*_First);
			if (_Ch == ':' || _Ch == ',' || _Ch == '/')
				++_First;
			}
		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			++_First;	

		if (_First == _Last)
			;
		else if (!_Ctype_fac.is(_Ctype::digit, *_First))
			if (_Dorder == mdy)
				_State |= ios_base::failbit;	
			else
				{	
				_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
				if (_Dorder == ydm)
					_Dorder = ymd;
				}
		else if (_Dorder == dmy || _Dorder == ymd)
			{	
			_State |= _Getint(_First, _Last, 1, 12,
				_Pt->tm_mon, _Ctype_fac);
			--_Pt->tm_mon;
			}
		else
			_State |= _Getint(_First, _Last, 1, 31,
				_Pt->tm_mday, _Ctype_fac);

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			++_First;	
		if (_First != _Last)
			{	
			char _Ch = _Ctype_fac.narrow(*_First);
			if (_Ch == ':' || _Ch == ',' || _Ch == '/')
				++_First;
			}
		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			++_First;	

		if (_First == _Last)
			_State |= ios_base::failbit;	
		else if (!_Ctype_fac.is(_Ctype::digit, *_First))
			if (_Dorder != ydm)
				_State |= ios_base::failbit;	
			else
				_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
		else if (_Dorder == ydm)
			{	
			_State |= _Getint(_First, _Last, 1, 12,
				_Pt->tm_mon, _Ctype_fac);
			--_Pt->tm_mon;
			}
		else if (_Dorder == ymd)
			_State |= _Getint(_First, _Last, 1, 31,
				_Pt->tm_mday, _Ctype_fac);
		else	
			_First = get_year(_First, _Last, _Iosbase, _State, _Pt);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		return (_First);
		}

	virtual _InIt  do_get_weekday(
		_InIt _First, _InIt _Last,
		ios_base&, ios_base::iostate& _State, tm *_Pt) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 367);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 368);
		int _Num = _Getloctxt(_First, _Last, (size_t)0, _Days);

		if (_Num < 0)
			_State |= ios_base::failbit;
		else
			_Pt->tm_wday = _Num >> 1;	
		return (_First);
		}

	virtual _InIt  do_get_monthname(
		_InIt _First, _InIt _Last,
		ios_base&, ios_base::iostate& _State, tm *_Pt) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 382);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 383);
		int _Num = _Getloctxt(_First, _Last, (size_t)0, _Months);

		if (_Num < 0)
			_State |= ios_base::failbit;
		else
			_Pt->tm_mon = _Num >> 1;	
		return (_First);
		}

	virtual _InIt  do_get_year(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 397);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 398);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		int _Ans = 0;
		ios_base::iostate _Res = _Getint(_First, _Last, 0, 9999,
			_Ans, _Ctype_fac);

		_State |= _Res;	
		if (_Res & ios_base::failbit)
			;	
		else if (_Ans < 69)
			_Pt->tm_year = _Ans + 100;	
		else if (_Ans < 100)
			_Pt->tm_year = _Ans;		
		else
			_Pt->tm_year = _Ans - 1900;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
		char _Specifier, char = 0) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());
		int _Ans = 0;

		_State = ios_base::goodbit;

		switch (_Specifier)
			{	
		case 'a':
		case 'A':
			_First = get_weekday(_First, _Last, _Iosbase, _State, _Pt);
			break;

		case 'b':
		case 'B':
		case 'h':
			_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
			break;

		case 'c':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%b %d %H : %M : %S %Y");
			break;

		case 'C':
			_State |= _Getint(_First, _Last, 0, 99,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_year = _Ans * 100 - 1900;	
			break;

		case 'd':
		case 'e':
			_State |= _Getint(_First, _Last, 1, 31,
				_Pt->tm_mday, _Ctype_fac);
			break;

		case 'D':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%m / %d / %y");
			break;

		case 'H':
			_State |= _Getint(_First, _Last, 0, 23,
				_Pt->tm_hour, _Ctype_fac);
			break;

		case 'I':
			_State |= _Getint(_First, _Last, 1, 12,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_hour = _Ans == 12 ? 0 : _Ans;
			break;

		case 'j':
			_State |= _Getint(_First, _Last, 1, 366,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'm':
			_State |= _Getint(_First, _Last, 1, 12,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_mon = _Ans - 1;
			break;

		case 'M':
			_State |= _Getint(_First, _Last, 0, 59,
				_Pt->tm_min, _Ctype_fac);
			break;

		case 'n':
		case 't':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				" ");
			break;

		case 'p':
			_Ans = _Getloctxt(_First, _Last, (size_t)0, ":AM:am:PM:pm");
			if (_Ans < 0)
				_State |= ios_base::failbit;
			else if (1 < _Ans)
				_Pt->tm_hour += 12;
			break;

		case 'r':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%I : %M : %S %p");
			break;

		case 'R':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%H : %M");
			break;

		case 'S':
			_State |= _Getint(_First, _Last, 0, 60,
				_Pt->tm_sec, _Ctype_fac);
			break;

		case 'T':
		case 'X':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%H : %M : %S");
			break;

		case 'U':
			_State |= _Getint(_First, _Last, 0, 53,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'w':
			_State |= _Getint(_First, _Last, 0, 6,
				_Pt->tm_wday, _Ctype_fac);
			break;

		case 'W':
			_State |= _Getint(_First, _Last, 0, 53,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'x':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%d / %m / %y");
			break;

		case 'y':
			_State |= _Getint(_First, _Last, 0, 99,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_year = _Ans < 69 ? _Ans + 100 : _Ans;
			break;

		case 'Y':
			_First = get_year(_First, _Last, _Iosbase, _State, _Pt);
			break;

		default:
			_State |= ios_base::failbit;	
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		return (_First);
		}

	_InIt  _Getfmt(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			const char *_Fmtfirst) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		for (; *_Fmtfirst != '\0'; ++_Fmtfirst)
			if (*_Fmtfirst == '%')
				_First = do_get(_First, _Last, _Iosbase, _State, _Pt,
					*++_Fmtfirst);	
			else if (*_Fmtfirst == ' ')
				for (; _First != _Last
					&& _Ctype_fac.is(_Ctype::space, *_First); ++_First)
					;
			else if (_Ctype_fac.narrow(*_First) != *_Fmtfirst)
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				++_First;
		if (_First == _Last)
			_State |= ios_base::eofbit;
		return (_First);
		}

private:
	ios_base::iostate __cdecl _Getint(
		_InIt& _First, _InIt& _Last,
		int _Lo, int _Hi, int& _Val,
		const _Ctype& _Ctype_fac) const
		{	
		char _Ac[32], *_Ep;
		char *_Ptr = _Ac;
		char _Ch;

		if (_First == _Last)
			;
		else if ((_Ch = _Ctype_fac.narrow(*_First)) == '+')
			*_Ptr++ = '+', ++_First;	
		else if (_Ch == '-')
			*_Ptr++ = '-', ++_First;	

		bool _Seendigit = false;
		while (_First != _Last && _Ctype_fac.narrow(*_First) == '0')
			_Seendigit = true, ++_First;	
		if (_Seendigit)
			*_Ptr++ = '0';	

		for (char *const _Pe = &_Ac[32 - 1]; _First != _Last
			&& '0' <= (_Ch = _Ctype_fac.narrow(*_First)) && _Ch <= '9';
			_Seendigit = true, ++_First)
			{	
			*_Ptr = _Ch;
			if (_Ptr < _Pe)
				++_Ptr;	
			}

		if (!_Seendigit)
			_Ptr = _Ac;
		*_Ptr = '\0';
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep, 10, &_Errno);
		ios_base::iostate _State = ios_base::goodbit;

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0 || _Ans < _Lo || _Hi < _Ans)
			_State |= ios_base::failbit;	
		else
			_Val = _Ans;	
		return (_State);
		}

	void  _Tidy()
		{	
		:: free((void *)_Days);
		:: free((void *)_Months);
		:: free((void *)_Ampm);
		}

	const _Elem *_Days;	
	const _Elem *_Months;	
	const _Elem *_Ampm;	
	dateorder _Dateorder;
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem,
	class _InIt>
	 locale::id time_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get_byname
		: public time_get<_Elem, _InIt>
	{	
public:
	explicit time_get_byname(const char *_Locname, size_t _Refs = 0)
		: time_get<_Elem, _InIt>(_Locname, _Refs)
		{	
		}

	explicit time_get_byname(const string& _Str, size_t _Refs = 0)
		: time_get<_Elem, _InIt>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~time_get_byname() noexcept
		{	
		}
	};

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put
		: public locale::facet
	{	
public:
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef ctype<_Elem> _Ctype;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 697);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 698);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				*_Dest++ = *_Fmtfirst;	
			else if (++_Fmtfirst == _Fmtlast)
				{	
				*_Dest++ = _Fmtfirst[-1];
				break;
				}
			else
				{	
				char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier != 'E' && _Specifier != 'O'
					&& _Specifier != 'Q' && _Specifier != '#')
					;	
				else if (++_Fmtfirst == _Fmtlast)
					{	
					*_Dest++ = _Percent;
					*_Dest++ = _Specifier;
					break;
					}
				else
					{	
					_Modifier = _Specifier;
					_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
					}

				_Dest = do_put(_Dest, _Iosbase, _Fill, _Pt,
					_Specifier, _Modifier);	
				}
		return (_Dest);
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
		char _Specifier, char _Modifier = '\0') const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}

	 static locale::id id;	

	explicit  time_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new time_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (5);
		}

protected:
	virtual  ~time_put() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Tnames = _Lobj._Gettnames();
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base&, _Elem, const tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 782);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 783);

		char _Fmt[5] = "!%x\0";	
		size_t _Count, _Num;
		string _Str;

		if (_Modifier == '\0')
			_Fmt[2] = _Specifier;
		else
			{	
			_Fmt[2] = _Modifier;
			_Fmt[3] = _Specifier;
			}

		for (_Num = 16; ; _Num *= 2)
			{	
			_Str.append(_Num, '\0');
			if (0 < (_Count = _Strftime(&*_Str.begin(), _Str.size(),
				_Fmt, _Pt, _Tnames._Getptr())))
				break;
			}
		return (::std:: copy(&_Str[1], &_Str[_Count], _Dest));
		}

private:
	_Locinfo::_Timevec _Tnames;	
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id time_put<_Elem, _OutIt>::id;

		

template<class _OutIt>
	class  time_put<wchar_t, _OutIt>
		: public locale::facet
	{	
public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef ctype<_Elem> _Ctype;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 832);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 833);
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Iosbase.getloc());

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				*_Dest++ = *_Fmtfirst;	
			else if (++_Fmtfirst == _Fmtlast)
				{	
				*_Dest++ = _Fmtfirst[-1];
				break;
				}
			else
				{	
				char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier != 'E' && _Specifier != 'O'
					&& _Specifier != 'Q' && _Specifier != '#')
					;	
				else if (++_Fmtfirst == _Fmtlast)
					{	
					*_Dest++ = _Percent;
					*_Dest++ = _Specifier;
					break;
					}
				else
					{	
					_Modifier = _Specifier;
					_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
					}

				_Dest = do_put(_Dest, _Iosbase, _Fill, _Pt,
					_Specifier, _Modifier);	
				}
		return (_Dest);
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
		char _Specifier, char _Modifier = '\0') const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}

	 static locale::id id;	

	explicit  time_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new time_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (5);
		}

protected:
	virtual  ~time_put() noexcept
		{	
		}

	 time_put(const char *_Locname, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Tnames = _Lobj._W_Gettnames();
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base&, _Elem, const tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 925);
		_Debug_pointer(_Pt, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime", 926);

		wchar_t _Fmt[5] = L"!%x\0";	
		size_t _Count, _Num;
		wstring _Str;

		if (_Modifier == '\0')
			_Fmt[2] = (_Elem)_Specifier;	
		else
			{	
			_Fmt[2] = (_Elem)_Modifier;
			_Fmt[3] = (_Elem)_Specifier;
			}

		for (_Num = 16; ; _Num *= 2)
			{	
			_Str.append(_Num, '\0');
			if (0 < (_Count = _Wcsftime(&*_Str.begin(), _Str.size(),
				_Fmt, _Pt, _Tnames._Getptr())))
				break;
			}
		return (::std:: copy(&_Str[1], &_Str[_Count], _Dest));
		}

private:
	_Locinfo::_Timevec _Tnames;	
	};

		
template<class _OutIt>
	 locale::id time_put<wchar_t, _OutIt>::id;

 














































































































































		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put_byname
		: public time_put<_Elem, _OutIt>
	{	
public:
	explicit time_put_byname(const char *_Locname, size_t _Refs = 0)
		: time_put<_Elem, _OutIt>(_Locname, _Refs)
		{	
		}

	explicit time_put_byname(const string& _Str, size_t _Refs = 0)
		: time_put<_Elem, _OutIt>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~time_put_byname() noexcept
		{	
		}
	};

 



















#line 1145 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime"
#line 1152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xloctime"






#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iomanip"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	struct _Fillobj
	{	
	_Fillobj(_Elem _Ch)
		: _Fill(_Ch)
		{	
		}

	_Elem _Fill;	
	};

		
template<class _Elem> inline
	_Fillobj<_Elem> setfill(_Elem _Ch)
	{	
	return (_Fillobj<_Elem>(_Ch));
	}

template<class _Elem,
	class _Traits,
	class _Elem2> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>& _Istr,
			const _Fillobj<_Elem2>& _Manip)
	{	
	static_assert(is_same<_Elem, _Elem2>::value,
		"wrong character type for setfill");

	_Istr.fill(_Manip._Fill);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Elem2> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const _Fillobj<_Elem2>& _Manip)
	{	
	static_assert(is_same<_Elem, _Elem2>::value,
		"wrong character type for setfill");

	_Ostr.fill(_Manip._Fill);
	return (_Ostr);
	}

		
template<class _Money>
	struct _Monobj
	{	
	_Monobj(_Money& _Val_arg, bool _Intl_arg)
		: _Val(_Val_arg), _Intl(_Intl_arg)
		{	
		}

	_Money& _Val;	
	bool _Intl;		

	private:
		_Monobj& operator=(const _Monobj&);
	};

		
template<class _Money> inline
	_Monobj<_Money> get_money(_Money& _Val_arg,
		bool _Intl_arg = false)
	{	
	return (_Monobj<_Money>(_Val_arg, _Intl_arg));
	}

template<class _Elem,
	class _Traits,
	class _Money> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>& _Istr,
			const _Monobj<_Money>& _Manip)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef money_get<_Elem, _Iter> _Mymget;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Mymget& _Mget_fac = use_facet< _Mymget >(_Istr.getloc());
		try {
		_Mget_fac.get(_Iter(_Istr.rdbuf()), _Iter(0), _Manip._Intl,
			_Istr, _State, _Manip._Val);
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

		
template<class _Money> inline
	_Monobj<const _Money>
		put_money(const _Money& _Val_arg,
			bool _Intl_arg = false)
	{	
	return (_Monobj<const _Money>(_Val_arg, _Intl_arg));
	}

template<class _Elem,
	class _Traits,
	class _Money> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const _Monobj<_Money>& _Manip)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef money_put<_Elem, _Iter> _Mymput;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const _Mymput& _Mput_fac = use_facet< _Mymput >(_Ostr.getloc());
		try {
		if (_Mput_fac.put(_Iter(_Ostr.rdbuf()), _Manip._Intl,
			_Ostr, _Ostr.fill(), _Manip._Val).failed())
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		
template<class _Elem,
	class _Ptr>
	struct _Timeobj
	{	
	_Timeobj(_Ptr _Tptr_arg, const _Elem *_Fmt_arg)
		: _Tptr(_Tptr_arg), _Fmtfirst(_Fmt_arg)
		{	
		for (_Fmtlast = _Fmtfirst; *_Fmtlast != 0; ++_Fmtlast)
			;	
		}

	_Ptr _Tptr;	
	const _Elem *_Fmtfirst;	
	const _Elem *_Fmtlast;	
	};

		
template<class _Elem> inline
	_Timeobj<_Elem, struct tm *>
		get_time(struct tm *_Tptr_arg, const _Elem *_Fmt_arg)
	{	
	return (_Timeobj<_Elem, struct tm *>(_Tptr_arg, _Fmt_arg));
	}

template<class _Elem,
	class _Traits,
	class _Elem2> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>& _Istr,
			const _Timeobj<_Elem2, struct tm *>& _Manip)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef time_get<_Elem2, _Iter> _Mytget;

	static_assert(is_same<_Elem, _Elem2>::value,
		"wrong character type for get_time");

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Mytget& _Tget_fac = use_facet< _Mytget >(_Istr.getloc());
		try {
		_Tget_fac.get(_Iter(_Istr.rdbuf()), _Iter(0), _Istr, _State,
			_Manip._Tptr, _Manip._Fmtfirst, _Manip._Fmtlast);
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

		
template<class _Elem> inline
	_Timeobj<_Elem, const struct tm *>
		put_time(const struct tm *_Tptr_arg, const _Elem *_Fmt_arg)
	{	
	return (_Timeobj<_Elem, const struct tm *>(_Tptr_arg, _Fmt_arg));
	}

template<class _Elem,
	class _Traits,
	class _Elem2> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const _Timeobj<_Elem2, const struct tm *>& _Manip)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef time_put<_Elem2, _Iter> _Mytput;

	static_assert(is_same<_Elem, _Elem2>::value,
		"wrong character type for put_time");

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const _Mytput& _Tput_fac = use_facet< _Mytput >(_Ostr.getloc());
		try {
		if (_Tput_fac.put(_Iter(_Ostr.rdbuf()), _Ostr, _Ostr.fill(),
			_Manip._Tptr, _Manip._Fmtfirst, _Manip._Fmtlast).failed())
			_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}
		
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct _Quote_in
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	_Quote_in(_Mystr& _Str_obj,
		_Elem _Delim_obj, _Elem _Escape_obj)
		: _Str(_Str_obj),
			_Delim(_Delim_obj), _Escape(_Escape_obj)
		{	
		}

	_Mystr& _Str;	
	_Elem _Delim;	
	_Elem _Escape;	

	_Quote_in& operator=(const _Quote_in&) = delete;
	};

		
template<class _Elem,
	class _Traits,
	class _Sizet>
	struct _Quote_out
	{	
	_Quote_out(const _Elem *_Ptr_obj, _Sizet _Size_obj,
		_Elem _Delim_obj, _Elem _Escape_obj)
		: _Ptr(_Ptr_obj), _Size(_Size_obj),
			_Delim(_Delim_obj), _Escape(_Escape_obj)
		{	
		}

	const _Elem *_Ptr;	
	_Sizet _Size;	
	_Elem _Delim;	
	_Elem _Escape;	

	_Quote_out& operator=(const _Quote_out&) = delete;
	};

		
template<class _Elem> inline
	_Quote_out<_Elem, void, size_t>
		quoted(const _Elem *_Ptr,
			_Elem _Delim = _Elem('"'),
			_Elem _Escape = _Elem('\\'))
	{	
	size_t _Size = 0;
	for (; _Ptr[_Size] != _Elem(0); ++_Size)
		;
	return (_Quote_out<_Elem, void, size_t>(_Ptr, _Size, _Delim, _Escape));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_Quote_out<_Elem, _Traits,
		typename basic_string<_Elem, _Traits, _Alloc>::size_type>
		quoted(const basic_string<_Elem, _Traits, _Alloc>& _Str,
			_Elem _Delim = _Elem('"'),
			_Elem _Escape = _Elem('\\'))
	{	
	typedef _Quote_out<_Elem, _Traits,
		typename basic_string<_Elem, _Traits, _Alloc>::size_type> _Qobj;
	return (_Qobj(_Str.c_str(), _Str.size(), _Delim, _Escape));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_Quote_in<_Elem, _Traits, _Alloc>
		quoted(basic_string<_Elem, _Traits, _Alloc>& _Str,
			_Elem _Delim = _Elem('"'),
			_Elem _Escape = _Elem('\\'))
	{	
	return (_Quote_in<_Elem, _Traits, _Alloc>(_Str, _Delim, _Escape));
	}

	
template<class _Elem,
	class _Traits,
	class _QuTraits,
	class _Sizet> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const _Quote_out<_Elem, _QuTraits, _Sizet>& _Manip)
	{	
	static_assert(is_void<_QuTraits>::value
		|| is_same<_QuTraits, _Traits>::value,
		"quoted() traits must match basic_ostream traits");

	typedef basic_ostream<_Elem, _Traits> _Myos;

	const _Elem *const _Last = _Manip._Ptr + _Manip._Size;

	_Sizet _Size = _Manip._Size + 2;	
	for (const _Elem *_Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr)
		if (_Traits::eq(*_Ptr, _Manip._Delim)
			|| _Traits::eq(*_Ptr, _Manip._Escape))
			++_Size;	

	ios_base::iostate _State = ios_base::goodbit;
	_Sizet _Pad = _Ostr.width() <= 0 || (_Sizet)_Ostr.width() <= _Size
		? 0 : (_Sizet)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Manip._Delim)))	
			_State |= ios_base::badbit;

		for (const _Elem *_Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr)
			{	
			if ((_Traits::eq(*_Ptr, _Manip._Delim)
				|| _Traits::eq(*_Ptr, _Manip._Escape))
				&& _State == ios_base::goodbit
				&& _Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Manip._Escape)))	
				{	
				_State |= ios_base::badbit;
				break;
				}
			if (_State == ios_base::goodbit
				&& _Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(*_Ptr)))	
				{	
				_State |= ios_base::badbit;
				break;
				}
			}
		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Manip._Delim)))	
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
		const _Quote_in<_Elem, _Traits, _Alloc>& _Manip)
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	const _Mystr& _Ref = _Manip._Str;
	return (_Ostr << ::std:: quoted(_Ref, _Manip._Delim, _Manip._Escape));
	}

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		const _Quote_in<_Elem, _Traits, _Alloc>& _Manip)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Sizet;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	while (_Ok)
		{	
		try {
		_Sizet _Size = 0 < _Istr.width()
			&& (_Sizet)_Istr.width() < _Manip._Str.max_size()
				? (_Sizet)_Istr.width() : _Manip._Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
		typename _Traits::int_type _Delim =
			_Traits::to_int_type(_Manip._Delim);
		typename _Traits::int_type _Escape =
			_Traits::to_int_type(_Manip._Escape);

		if (!_Traits::eq_int_type(_Meta, _Delim))	
			return (_Istr >> _Manip._Str);
		_Manip._Str.clear();
		_Meta = _Istr.rdbuf()->snextc();	

		for (; !_Traits::eq_int_type(_Meta, _Delim) && 0 < _Size;
			_Meta = _Istr.rdbuf()->snextc(), --_Size)
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (!_Traits::eq_int_type(_Meta, _Escape))
				_Manip._Str.append(1,
					_Traits::to_char_type(_Meta));	
			else if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Istr.rdbuf()->snextc()))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else
				_Manip._Str.append(1,
					_Traits::to_char_type(_Meta));	

		if (!_Traits::eq_int_type(_Meta, _Delim))
			_State |= ios_base::failbit;	
		else
			{	
			_Changed = true;
			_Istr.rdbuf()->snextc();
			}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		break;
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

		
template<class _Arg>
	struct _Smanip
	{	
	_Smanip(void (__cdecl *_Left)(ios_base&, _Arg), _Arg _Val)
		: _Pfun(_Left), _Manarg(_Val)
		{	
		}

	void (__cdecl *_Pfun)(ios_base&, _Arg);	
	_Arg _Manarg;	
	};

template<class _Elem,
	class _Traits,
	class _Arg> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, const _Smanip<_Arg>& _Manip)
	{	
	(*_Manip._Pfun)(_Istr, _Manip._Manarg);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Arg> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Smanip<_Arg>& _Manip)
	{	
	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);
	return (_Ostr);
	}

		
 _Smanip<ios_base::fmtflags> __cdecl resetiosflags(ios_base::fmtflags);
 _Smanip<ios_base::fmtflags> __cdecl setiosflags(ios_base::fmtflags);
 _Smanip<int> __cdecl setbase(int);
 _Smanip<streamsize> __cdecl setprecision(streamsize);
 _Smanip<streamsize> __cdecl setw(streamsize);
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 542 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iomanip"
#line 543 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iomanip"





#line 57 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"

#pragma once






#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
namespace std {
		
template<class _Mytree,
	class _Base = _Iterator_base0>
	class _Tree_unchecked_const_iterator
		: public _Iterator012<bidirectional_iterator_tag,
			typename _Mytree::value_type,
			typename _Mytree::difference_type,
			typename _Mytree::const_pointer,
			typename _Mytree::const_reference,
			_Base>
	{	
public:
	typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_unchecked_const_iterator()
		: _Ptr(0)
		{	
		}

	_Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Ptr(_Pnode)
		{	
		this->_Adopt(_Plist);
		}

	reference operator*() const
		{	
		return (_Mytree::_Myval(_Ptr));
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		if (_Mytree::_Isnil(_Ptr))
			;	
		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
			_Ptr = _Mytree::_Min(
				_Mytree::_Right(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Right(_Pnode))
				_Ptr = _Pnode;	
			_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		if (_Mytree::_Isnil(_Ptr))
			_Ptr = _Mytree::_Right(_Ptr);	
		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
			_Ptr = _Mytree::_Max(
				_Mytree::_Left(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Left(_Pnode))
				_Ptr = _Pnode;	
			if (_Mytree::_Isnil(_Ptr))
				;	
			else
				_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	_Nodeptr _Mynode() const
		{	
		return (_Ptr);
		}

	_Nodeptr _Ptr;	
	};

	
template<class _Mytree>
	class _Tree_unchecked_iterator
		: public _Tree_unchecked_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_unchecked_iterator()
		{	
		}

	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

	
template<class _Mytree>
	class _Tree_const_iterator
		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
	{	
public:
	typedef _Tree_const_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_const_iterator()
		: _Mybase()
		{	
		}

	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
			{	
			_Debug_message(L"map/set iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 237);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 238, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 238, 0); };
			}

 



#line 246 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (_Mytree::_Myval(this->_Ptr));
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| _Mytree::_Isnil(this->_Ptr))
			{	
			_Debug_message(L"map/set iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 262);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 263, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 263, 0); };
			}

 


#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0)
			{	
			_Debug_message(L"map/set iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 288);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 289, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 289, 0); };
			}

		_Nodeptr _Ptrsav = this->_Ptr;
		--(*(_Mybase *)this);
		if (_Ptrsav == this->_Ptr)
			{	
			_Debug_message(L"map/set iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 296);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 297, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 297, 0); };
			}

 








#line 310 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
 
		if (this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"map/set iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 326);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 327, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 327, 0); };
			}

 

#line 333 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}
	};

template<class _Mytree> inline
	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_const_iterator<_Mytree>&
		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
			typename _Tree_const_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

	
template<class _Mytree>
	class _Tree_iterator
		: public _Tree_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_iterator<_Mytree> _Myiter;
	typedef _Tree_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;

	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_iterator()
		{	
		}

	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

template<class _Mytree> inline
	typename _Tree_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_iterator<_Mytree>&
		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
			typename _Tree_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Nodeptr_type>
	struct _Tree_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	typedef _Nodeptr_type _Nodeptr;
	};

template<class _Value_type,
	class _Voidptr>
	struct _Tree_node
		{	
		_Voidptr _Left;	
		_Voidptr _Parent;	
		_Voidptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Value_type>
	struct _Tree_node<_Value_type, void *>
		{	
		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
		_Nodeptr _Left;	
		_Nodeptr _Parent;	
		_Nodeptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Ty>
	struct _Tree_simple_types
		: public _Simple_types<_Ty>
	{	
	typedef _Tree_node<_Ty, void *> _Node;
	typedef _Node *_Nodeptr;
	};

template<class _Ty,
	class _Alloc0>
	struct _Tree_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Tree_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
		_Voidptr;
	typedef _Tree_node<typename _Alty::value_type,
		_Voidptr> _Node;

	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
	typedef typename _Alnod_type::pointer _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Tree_simple_types<typename _Alty::value_type>,
		_Tree_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference,
			_Nodeptr> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Tree_val
		: public _Container_base
	{	
public:
	typedef _Tree_val<_Val_types> _Myt;

	typedef typename _Val_types::_Nodeptr _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Tree_const_iterator<_Myt> const_iterator;
	typedef _Tree_iterator<_Myt> iterator;

	_Tree_val()
		{	
		this->_Myhead = 0;
		this->_Mysize = 0;
		}

	enum _Redbl
		{	
		_Red, _Black};

	static char& _Color(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Color);
		}

	static char& _Isnil(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Isnil);
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Right);
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return ((reference)_Pnode->_Myval);
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

		
template<class _Traits>
	class _Tree_comp_alloc
	{	
public:
	typedef _Tree_comp_alloc<_Traits> _Myt;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	typedef _Tree_base_types<typename _Traits::value_type,
		allocator_type> _Alloc_types;

	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alnod_type _Alty;
	typedef typename _Alloc_types::_Node _Node;
	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Tree_const_iterator<_Tree_val<_Val_types> > const_iterator;
	typedef _Tree_iterator<_Tree_val<_Val_types> > iterator;

	enum _Redbl
		{	
		_Red, _Black
		};

	static char& _Color(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Color(_Pnode));
		}

	static char& _Isnil(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Left(_Pnode));
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Parent(_Pnode));
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Right(_Pnode));
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Myval(_Pnode));
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Max(_Pnode));
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Min(_Pnode));
		}

	_Tree_comp_alloc(const key_compare& _Parg, const allocator_type& _Al)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_One_then_variadic_args_t(), _Al)
		{	
		_Construct();
		}

	_Tree_comp_alloc(const key_compare& _Parg, allocator_type&& _Al)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_One_then_variadic_args_t(), ::std:: move(_Al))
		{	
		_Construct();
		}

 

























#line 741 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
	void _Construct()
		{	
		_Myhead() = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(_Myhead());
		throw;
		}
		}

	~_Tree_comp_alloc() noexcept
		{	
		_Freeheadnode(_Myhead());
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Pocs(_Getal(), _Right._Getal());
		_Swap_adl(_Myproxy(), _Right._Myproxy());
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Alproxy.allocate(1);
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Myproxy(), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 812 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Nodeptr _Buyheadnode()
		{	
		_Nodeptr _Pnode = _Getal().allocate(1);

		try {
		_Getal().construct(
			::std:: addressof(_Left(_Pnode)), _Pnode);
		_Getal().construct(
			::std:: addressof(_Parent(_Pnode)), _Pnode);
		_Getal().construct(
			::std:: addressof(_Right(_Pnode)), _Pnode);
		} catch (...) {
		_Getal().deallocate(_Pnode, 1);
		throw;
		}

		_Color(_Pnode) = _Black;
		_Isnil(_Pnode) = true;
		return (_Pnode);
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	
		_Getal().destroy(
			::std:: addressof(_Left(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Parent(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Right(_Pnode)));
		_Getal().deallocate(_Pnode, 1);
		}

	_Nodeptr _Buynode0()
		{	
		_Nodeptr _Pnode = _Getal().allocate(1);

		try {
		_Getal().construct(
			::std:: addressof(_Left(_Pnode)), _Myhead());
		_Getal().construct(
			::std:: addressof(_Parent(_Pnode)), _Myhead());
		_Getal().construct(
			::std:: addressof(_Right(_Pnode)), _Myhead());
		} catch (...) {
		_Getal().deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}

	void _Freenode0(_Nodeptr _Pnode)
		{	
		_Getal().destroy(
			::std:: addressof(_Left(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Parent(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Right(_Pnode)));
		_Getal().deallocate(_Pnode, 1);
		}

	template<class... _Valty>
		_Nodeptr _Buynode(_Valty&&... _Val)
		{	
		_Nodeptr _Pnode = _Buynode0();

		this->_Color(_Pnode) = _Red;
		this->_Isnil(_Pnode) = false;

		try {
		this->_Getal().construct(
			::std:: addressof(_Myval(_Pnode)),
				::std:: forward<_Valty>(_Val)...);
		} catch (...) {
		_Freenode0(_Pnode);
		throw;
		}

		return (_Pnode);
		}


	key_compare& _Getcomp() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const key_compare& _Getcomp() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_second()._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_second()._Get_first());
		}

	_Tree_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second()._Get_second());
		}

	const _Tree_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second()._Get_second());
		}

	_Nodeptr& _Myhead() noexcept
		{	
		return (_Get_data()._Myhead);
		}

	const _Nodeptr& _Myhead() const noexcept
		{	
		return (_Get_data()._Myhead);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

private:
	_Compressed_pair<key_compare,
		_Compressed_pair<_Alty, _Tree_val<_Val_types> > > _Mypair;
	};

		
template<class _Traits>
	class _Tree
		: public _Tree_comp_alloc<_Traits>
	{	
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_comp_alloc<_Traits> _Mybase;

	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::value_compare value_compare;
	enum
		{	
		_Multi = _Traits::_Multi};

	typedef typename _Mybase::_Node _Node;
	typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::key_compare key_compare;
	typedef typename _Mybase::allocator_type allocator_type;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _If<is_same<key_type, value_type>::value,
		typename _Mybase::const_iterator,
		typename _Mybase::iterator>::type iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	struct _Copy_tag
		{	
		};
	struct _Move_tag
		{	
		};

	_Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		}

	_Tree(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	
		try {
		_Copy(_Right, _Copy_tag());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(_Myt&& _Right)
		: _Mybase(_Right.key_comp(), ::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	_Tree(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all(_Right);
		_Swap_adl(this->_Getcomp(), _Right._Getcomp());
		_Swap_adl(this->_Myhead(), _Right._Myhead());
		::std:: swap(this->_Mysize(), _Right._Mysize());
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Copy(_Right, _Move_tag());
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	_Pairib insert(value_type&& _Val)
		{	
		return (_Insert_nohint(false,
			::std:: forward<value_type>(_Val), _Nil()));
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	
		return (_Insert_hint(_Where,
			::std:: forward<value_type>(_Val), _Nil()));
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			_Pairib>::type
		insert(_Valty&& _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
		return (_Insert_nohint(false,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(const_iterator _Where, _Valty&& _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
		return (_Insert_hint(_Where,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class... _Valty>
		_Pairib emplace(_Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_nohint(false,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class... _Valty>
		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_hint(_Where,
			this->_Myval(_Newnode), _Newnode));
		}


	~_Tree() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				this->_Copy_alloc(_Right._Getal());

			this->_Getcomp() = _Right._Getcomp();
			_Copy(_Right, _Copy_tag());
			}
		return (*this);
		}

	iterator begin() noexcept
		{	
		return (iterator(_Lmost(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(_Lmost(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Myhead(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Myhead(), &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (size() == 0);
		}

	allocator_type get_allocator() const noexcept
		{	
		return (this->_Getal());
		}

	key_compare key_comp() const
		{	
		return (this->_Getcomp());
		}

	value_compare value_comp() const
		{	
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{	
		return (_Insert_nohint(false,
			_Val, _Nil()));
		}

	iterator insert(const_iterator _Where,
		const value_type& _Val)
		{	
		return (_Insert_hint(_Where,
			_Val, _Nil()));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1251);
		for (; _First != _Last; ++_First)

			emplace_hint(end(), *_First);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		insert(_Ilist.begin(), _Ilist.end());
		}

	iterator erase(const_iterator _Where)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| this->_Isnil(_Where._Mynode()))
			_Debug_message(L"map/set erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1267);
		_Nodeptr _Erasednode = _Where._Mynode();	
		++_Where;	
		_Orphan_ptr(_Erasednode);

 


#line 1276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		_Nodeptr _Fixnode;	
		_Nodeptr _Fixnodeparent;	
		_Nodeptr _Pnode = _Erasednode;

		if (this->_Isnil(this->_Left(_Pnode)))
			_Fixnode = this->_Right(_Pnode);	
		else if (this->_Isnil(this->_Right(_Pnode)))
			_Fixnode = this->_Left(_Pnode);	
		else
			{	
			_Pnode = _Where._Mynode();	
			_Fixnode = this->_Right(_Pnode);	
			}

		if (_Pnode == _Erasednode)
			{	
			_Fixnodeparent = this->_Parent(_Erasednode);
			if (!this->_Isnil(_Fixnode))
				this->_Parent(_Fixnode) = _Fixnodeparent;	

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;	
			else if (this->_Left(_Fixnodeparent) == _Erasednode)
				this->_Left(_Fixnodeparent) = _Fixnode;	
			else
				this->_Right(_Fixnodeparent) =
					_Fixnode;	

			if (_Lmost() == _Erasednode)
				_Lmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Min(_Fixnode);	

			if (_Rmost() == _Erasednode)
				_Rmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Max(_Fixnode);	
			}
		else
			{	
			this->_Parent(this->_Left(_Erasednode)) =
				_Pnode;	
			this->_Left(_Pnode) =
				this->_Left(_Erasednode);	

			if (_Pnode == this->_Right(_Erasednode))
				_Fixnodeparent = _Pnode;	
			else
				{	
				_Fixnodeparent =
					this->_Parent(_Pnode);	
				if (!this->_Isnil(_Fixnode))
					this->_Parent(_Fixnode) = _Fixnodeparent;	
				this->_Left(_Fixnodeparent) = _Fixnode;	
				this->_Right(_Pnode) =
					this->_Right(_Erasednode);	
				this->_Parent(this->_Right(_Erasednode)) =
					_Pnode;	
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;	
			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
				this->_Left(this->_Parent(_Erasednode)) =
					_Pnode;	
			else
				this->_Right(this->_Parent(_Erasednode)) =
					_Pnode;	

			this->_Parent(_Pnode) =
				this->_Parent(_Erasednode);	
			::std:: swap(this->_Color(_Pnode),
				this->_Color(_Erasednode));	
			}

		if (this->_Color(_Erasednode) == this->_Black)
			{	
			for (; _Fixnode != _Root()
				&& this->_Color(_Fixnode) == this->_Black;
				_Fixnodeparent = this->_Parent(_Fixnode))
				if (_Fixnode == this->_Left(_Fixnodeparent))
					{	
					_Pnode = this->_Right(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = this->_Right(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Right(_Pnode))
							== this->_Black)
							{	
							this->_Color(this->_Left(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Rrotate(_Pnode);
							_Pnode = this->_Right(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Right(_Pnode)) = this->_Black;
						_Lrotate(_Fixnodeparent);
						break;	
						}
					}
				else
					{	
					_Pnode = this->_Left(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = this->_Left(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Right(_Pnode)) ==
						this->_Black
						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
							{	
							this->_Color(this->_Right(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Lrotate(_Pnode);
							_Pnode = this->_Left(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Left(_Pnode)) = this->_Black;
						_Rrotate(_Fixnodeparent);
						break;	
						}
					}

			this->_Color(_Fixnode) = this->_Black;	
			}

		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Erasednode)));	

		this->_Getal().deallocate(_Erasednode, 1);

		if (0 < this->_Mysize())
			--this->_Mysize();

		return (iterator(_Where._Ptr,
			&this->_Get_data()));	
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (begin());
			}
		else
			{	
			while (_First != _Last)
				erase(_First++);
			return (iterator(_First._Ptr, &this->_Get_data()));
			}
		}

	size_type erase(const key_type& _Keyval)
		{	
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void clear() noexcept
		{	
 
		this->_Orphan_ptr(0);
 #line 1476 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		_Erase(_Root());
		_Root() = this->_Myhead();
		_Lmost() = this->_Myhead();
		_Rmost() = this->_Myhead();
		this->_Mysize() = 0;
		}

	iterator find(const key_type& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1489)
#line 1490 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1498)
#line 1499 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator find(const _Other& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1510)
#line 1511 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator find(const _Other& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1522)
#line 1523 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		size_type count(const _Other& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator lower_bound(const _Other& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator lower_bound(const _Other& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	iterator upper_bound(const key_type& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator upper_bound(const _Other& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator upper_bound(const _Other& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	
		return (_Eqrange(_Keyval));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		_Pairii equal_range(const _Other& _Keyval)
		{	
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		_Paircc equal_range(const _Other& _Keyval) const
		{	
		return (_Eqrange(_Keyval));
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
			_Swap_adl(this->_Myhead(), _Right._Myhead());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
			_Swap_adl(this->_Myhead(), _Right._Myhead());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			}

		else
			{	
 
			_Debug_message(L"map/set containers incompatible for swap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1646);

 

#line 1651 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
			}
		}

protected:
	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
		{	
		return (_Node);
		}

	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
		{	
		return (this->_Buynode(::std:: forward<_Valty>(_Val)));
		}

	void _Destroy_if_not_nil(_Nodeptr _Newnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Newnode)));

		this->_Getal().deallocate(_Newnode, 1);
		}

	void _Destroy_if_not_nil(_Nil)
		{	
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_hint(const_iterator _Where,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		const_iterator _Next;
		bool _Leftish = false;	

		try {

 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"map/set insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1691);
 #line 1693 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		if (size() == 0)
			return (_Insert_at(true, this->_Myhead(),
				::std:: forward<_Valty>(_Val), _Newnode));	
		else if (this->_Multi)
			{	
			if (_Where == begin())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1702))
#line 1703 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				_Leftish = true;	
				}
			else if (_Where == end())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Rmost()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1710))
#line 1711 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1715)
#line 1716 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& !_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1718))
#line 1719 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1728)
#line 1729 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Next._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1731)))
#line 1732 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else
				_Leftish = true;	
			}
		else
			{	
			if (_Where == begin())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1748))
#line 1749 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Where == end())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Rmost()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1755))
#line 1756 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1760)
#line 1761 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& _Debug_lt_pred(this->_Getcomp(), this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1763))
#line 1764 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1773)
#line 1774 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Next._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1776)))
#line 1777 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}

		return (_Insert_nohint(_Leftish,
			::std:: forward<_Valty>(_Val), _Newnode).first);
		}

	template<class _Valty,
		class _Nodety>
		_Pairib _Insert_nohint(bool _Leftish,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		try {
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();
		bool _Addleft = true;	

		while (!this->_Isnil(_Trynode))
			{	
			_Wherenode = _Trynode;
			if (_Leftish)
				_Addleft = !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Trynode), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1811);	
#line 1812 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
			else
				_Addleft = _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Trynode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1815);	
#line 1816 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
			_Trynode = _Addleft ? this->_Left(_Trynode)
				: this->_Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
				::std:: forward<_Valty>(_Val), _Newnode), true));
		else
			{	
			iterator _Where = iterator(_Wherenode, &this->_Get_data());
			if (!_Addleft)
				;	
			else if (_Where == begin())
				return (_Pairib(_Insert_at(true, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				--_Where;	

			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1836))
#line 1837 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				{	
				_Destroy_if_not_nil(_Newnode);
				return (_Pairib(_Where, false));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
		_Valty&& _Val, _Nodety _Node)
		{	
		if (max_size() - 1 <= this->_Mysize())
			{	
			_Destroy_if_not_nil(_Node);
			_Xlength_error("map/set<T> too long");
			}
		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
			::std:: forward<_Valty>(_Val));

		++this->_Mysize();
		_Newnode->_Parent = _Wherenode;

		if (_Wherenode == this->_Myhead())
			{	
			_Root() = _Newnode;
			_Lmost() = _Newnode;
			_Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	
			this->_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	
			this->_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode;
			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
			if (this->_Parent(_Pnode)
				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
				{	
				_Wherenode =
					this->_Right(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode)))
						= this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}
			else
				{	
				_Wherenode =
					this->_Left(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}

		this->_Color(_Root()) = this->_Black;	
		return (iterator(_Newnode, &this->_Get_data()));
		}

	template<class _Moveit>
		void _Copy(const _Myt& _Right, _Moveit _Movefl)
		{	
		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
		this->_Mysize() = _Right.size();
		if (!this->_Isnil(_Root()))
			{	
			_Lmost() = this->_Min(_Root());
			_Rmost() = this->_Max(_Root());
			}
		else
			{	
			_Lmost() = this->_Myhead();
			_Rmost() = this->_Myhead();
			}
		}

	template<class _Ty,
		class _Is_set>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
		{	
		return (this->_Buynode(_Val));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
		{	
		return (this->_Buynode(::std:: move(_Val)));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
		{	
		return (this->_Buynode(
			::std:: move(const_cast<key_type&>(_Val.first)),
			::std:: move(_Val.second)));
		}

	template<class _Moveit>
		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
			_Moveit _Movefl)
		{	
		_Nodeptr _Newroot = this->_Myhead();	

		if (!this->_Isnil(_Rootnode))
			{	
			typename is_same<key_type, value_type>::type _Is_set;
			_Nodeptr _Pnode = _Copy_or_move(
				this->_Myval(_Rootnode), _Movefl, _Is_set);
			_Pnode->_Parent = _Wherenode;
			_Pnode->_Color = this->_Color(_Rootnode);
			if (this->_Isnil(_Newroot))
				_Newroot = _Pnode;	

			try {
			this->_Left(_Pnode) =
				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
			this->_Right(_Pnode) =
				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
			} catch (...) {
			_Erase(_Newroot);	
			throw;
			}
			}

		return (_Newroot);	
		}

	template<class _Other>
		_Paircc _Eqrange(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Lonode = this->_Myhead();	
		_Nodeptr _Hinode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2022))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				if (this->_Isnil(_Hinode)
						&& _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2028))
#line 2029 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					_Hinode = _Pnode;	
				_Lonode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		_Pnode = this->_Isnil(_Hinode) ? _Root()
			: this->_Left(_Hinode);	
		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2037))
				{	
				_Hinode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
		return (_Paircc(_First, _Last));
		}

	template<class _Other>
		_Pairii _Eqrange(const _Other& _Keyval)
		{	
		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
		return (_Pairii(_First, _Last));
		}

	void _Erase(_Nodeptr _Rootnode)
		{	
		for (_Nodeptr _Pnode = _Rootnode;
			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
			{	
			_Erase(this->_Right(_Pnode));
			_Pnode = this->_Left(_Pnode);
			this->_Getal().destroy(
				::std:: addressof(this->_Myval(_Rootnode)));

			this->_Getal().deallocate(_Rootnode, 1);
			}
		}

	bool _Compare(const key_type& _Left, const key_type& _Right) const
		{	
		return (_Debug_lt_pred(this->_Getcomp(), _Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2075));
		}

	template<class _Ty1,
		class _Ty2>
		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
		{	
		return (this->_Getcomp()(_Left, _Right));
		}

	template<class _Other>
		_Nodeptr _Lbound(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Compare(this->_Key(_Pnode), _Keyval))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		return (_Wherenode);	
		}

	_Nodeptr& _Lmost() const
		{	
		return (this->_Left(this->_Myhead()));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Right(_Wherenode);
		this->_Right(_Wherenode) = this->_Left(_Pnode);

		if (!this->_Isnil(this->_Left(_Pnode)))
			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

		this->_Left(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr& _Rmost() const
		{	
		return (this->_Right(this->_Myhead()));
		}

	_Nodeptr& _Root() const
		{	
		return (this->_Parent(this->_Myhead()));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Left(_Wherenode);
		this->_Left(_Wherenode) = this->_Right(_Pnode);

		if (!this->_Isnil(this->_Right(_Pnode)))
			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

		this->_Right(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	template<class _Other>
		_Nodeptr _Ubound(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Compare(_Keyval, this->_Key(_Pnode)))
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		return (_Wherenode);	
		}

 
	void _Orphan_ptr(_Nodeptr _Ptr)
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr == this->_Myhead()
					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
		}
 #line 2193 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

	void _Tidy()
		{	
		erase(begin(), end());
		}

	const key_type& _Kfn(const value_type& _Val) const
		{	
		return (_Traits::_Kfn(_Val));
		}

	const key_type& _Key(_Nodeptr _Pnode) const
		{	
		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
		}
	};

		
template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left < _Right));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2254 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
#line 2255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"






#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
		
template<class _Kty,	
	class _Ty,	
	class _Pr,	
	class _Alloc,	
	bool _Mfl>	
	class _Tmap_traits
	{	
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef _Alloc allocator_type;

	enum
		{	
		_Multi = _Mfl};

	class value_compare
		{	
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		typedef value_type first_argument_type;
		typedef value_type second_argument_type;
		typedef bool result_type;

		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	
			}

	protected:
		key_compare comp;	
		};

	template<class _Ty1,
		class _Ty2>
		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
		{	
		return (_Val.first);
		}
	};

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{	
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Pairib _Pairib;

	map()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit map(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	map(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	map(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	map(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	map(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 174 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	mapped_type& operator[](key_type&& _Keyval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))

			_Where = _Mybase::emplace_hint(_Where,
				piecewise_construct,
				::std:: forward_as_tuple(::std:: move(_Keyval)),
				tuple<>());


		return (_Where->second);
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && noexcept(_Swap_adl( ::std:: declval<_Pr&>(), ::std:: declval<_Pr&>())))
#line 198 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::swap(_Right);
		}

	template<class _Keyty,
		class... _Mappedty>
		_Pairib _Try_emplace(_Keyty&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map", 210))
#line 211 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					piecewise_construct,
					::std:: forward_as_tuple(
						::std:: forward<_Keyty>(_Keyval)),
					::std:: forward_as_tuple(
						::std:: forward<_Mappedty>(_Mapval)...)),
				true));
		else
			return (_Pairib(_Where, false));
		}

	template<class... _Mappedty>
		_Pairib try_emplace(const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(_Keyval, ::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class... _Mappedty>
		_Pairib try_emplace(key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class _Keyty,
		class _Mappedty>
		_Pairib _Insert_or_assign(_Keyty&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map", 262))
#line 263 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					::std:: forward<_Keyty>(_Keyval),
					::std:: forward<_Mappedty>(_Mapval)),
				true));
		else
			{	
			_Where->second = ::std:: forward<_Mappedty>(_Mapval);
			return (_Pairib(_Where, false));
			}
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	map(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		_Mybase::clear();
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}






	mapped_type& operator[](const key_type& _Keyval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))

			_Where = _Mybase::emplace_hint(_Where,
				piecewise_construct,
				::std:: forward_as_tuple(_Keyval),
				tuple<>());


		return (_Where->second);
		}

	mapped_type& at(const key_type& _Keyval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}

	const mapped_type& at(const key_type& _Keyval) const
		{	
		const_iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{	
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;

	multimap()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit multimap(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	multimap(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	multimap(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	multimap(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	multimap(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 491 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(_Valty&& _Val)
		{	
		return (_Mybase::insert(::std:: forward<_Valty>(_Val)).first);
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(const_iterator _Where, _Valty&& _Val)
		{	
		return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
		}

	template<class... _Valty>
		iterator emplace(_Valty&&... _Val)
		{	
		return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
		}


	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && noexcept(_Swap_adl( ::std:: declval<_Pr&>(), ::std:: declval<_Pr&>())))
#line 523 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::swap(_Right);
		}

	multimap(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		_Mybase::clear();
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		_Mybase::insert(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const value_type& _Val)
		{	
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(const_iterator _Where, const value_type& _Val)
		{	
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Mybase::insert(_First, _Last);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 591 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
#line 592 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"





#line 59 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
		
template<class _Kty,	
	class _Pr,	
	class _Alloc,	
	bool _Mfl>	
	class _Tset_traits
	{	
public:
	typedef _Kty key_type;
	typedef _Kty value_type;
	typedef _Pr key_compare;
	typedef _Alloc allocator_type;

	enum
		{	
		_Multi = _Mfl};

	typedef key_compare value_compare;

	static const _Kty& _Kfn(const value_type& _Val)
		{	
		return (_Val);
		}
	};

		
template<class _Kty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<_Kty> >
	class set
		: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >
	{	
public:
	typedef set<_Kty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::_Pairib _Pairib;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;

	set()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit set(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	set(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	set(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit set(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	set(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_First, _Last);
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_First, _Last);
		}

	template<class _Iter>
		set(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	set(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	set(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 144 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	_Pairib insert(value_type&& _Val)
		{	
		return (_Mybase::insert(::std:: forward<value_type>(_Val)));
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	
		return (_Mybase::insert(_Where, ::std:: forward<value_type>(_Val)));
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && noexcept(_Swap_adl(::std:: declval<_Pr&>(), ::std:: declval<_Pr&>())))
#line 163 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"
		{	
		_Mybase::swap(_Right);
		}

	set(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	set(::std:: initializer_list<value_type> _Ilist,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	set(::std:: initializer_list<value_type> _Ilist,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		this->clear();
		this->insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	_Pairib insert(const value_type& _Val)
		{	
		return (_Mybase::insert(_Val));
		}

	iterator insert(const_iterator _Where, const value_type& _Val)
		{	
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set", 212);
		for (; _First != _Last; ++_First)

			this->emplace(*_First);
		}
	};

template<class _Kty,
	class _Pr,
	class _Alloc> inline
	void swap(set<_Kty, _Pr, _Alloc>& _Left,
		set<_Kty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

		
template<class _Kty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<_Kty> >
	class multiset
		: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >
	{	
public:
	typedef multiset<_Kty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;

	multiset()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit multiset(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	multiset(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	multiset(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit multiset(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	multiset(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		multiset(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_First, _Last);
		}

	template<class _Iter>
		multiset(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_First, _Last);
		}

	template<class _Iter>
		multiset(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	multiset(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	multiset(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 334 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	iterator insert(value_type&& _Val)
		{	
		return (_Mybase::insert(::std:: forward<value_type>(_Val)).first);
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	
		return (_Mybase::insert(_Where, ::std:: forward<value_type>(_Val)));
		}

	template<class... _Valty>
		iterator emplace(_Valty&&... _Val)
		{	
		return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
		}


	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && noexcept(_Swap_adl(::std:: declval<_Pr&>(), ::std:: declval<_Pr&>())))
#line 360 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"
		{	
		_Mybase::swap(_Right);
		}

	multiset(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	multiset(::std:: initializer_list<value_type> _Ilist,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	multiset(::std:: initializer_list<value_type> _Ilist,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		this->clear();
		this->insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const value_type& _Val)
		{	
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(const_iterator _Where, const value_type& _Val)
		{	
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set", 409);
		for (; _First != _Last; ++_First)

			this->emplace(*_First);
		}
	};

template<class _Kty,
	class _Pr,
	class _Alloc> inline
	void swap(multiset<_Kty, _Pr, _Alloc>& _Left,
		multiset<_Kty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 430 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"
#line 431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\set"





#line 60 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"



#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"






















































void operator<<(const testing::internal::Secret&, int);

namespace testing {



























class  Message {
 private:
  
  
  typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);

 public:
  
  Message();

  
  Message(const Message& msg) : ss_(new ::std::stringstream) {  
    *ss_ << msg.GetString();
  }

  
  explicit Message(const char* str) : ss_(new ::std::stringstream) {
    *ss_ << str;
  }








#line 113 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"
  
  template <typename T>
  inline Message& operator <<(const T& val) {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    using ::operator <<;
    *ss_ << val;
    return *this;
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  template <typename T>
  inline Message& operator <<(T* const& pointer) {  
    if (pointer == 0) {
      *ss_ << "(null)";
    } else {
      *ss_ << pointer;
    }
    return *this;
  }
#line 158 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"

  
  
  
  
  
  
  Message& operator <<(BasicNarrowIoManip val) {
    *ss_ << val;
    return *this;
  }

  
  Message& operator <<(bool b) {
    return *this << (b ? "true" : "false");
  }

  
  
  Message& operator <<(const wchar_t* wide_c_str);
  Message& operator <<(wchar_t* wide_c_str);


  
  
  Message& operator <<(const ::std::wstring& wstr);
#line 185 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"





#line 191 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"

  
  
  
  
  std::string GetString() const;

 private:






















#line 222 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"

  
  const internal::scoped_ptr< ::std::stringstream> ss_;

  
  
  void operator=(const Message&);
};


inline std::ostream& operator <<(std::ostream& os, const Message& sb) {
  return os << sb.GetString();
}

namespace internal {





template <typename T>
std::string StreamableToString(const T& streamable) {
  return (Message() << streamable).GetString();
}

}  
}  

#line 251 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-message.h"
#line 64 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-string.h"





















































namespace testing {
namespace internal {


class  String {
 public:
  

  
  
  
  
  
  
  
  static const char* CloneCString(const char* c_str);

























#line 96 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-string.h"

  
  
  
  
  
  static bool CStringEquals(const char* lhs, const char* rhs);

  
  
  
  
  static std::string ShowWideCString(const wchar_t* wide_c_str);

  
  
  
  
  
  
  static bool WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs);

  
  
  
  
  
  
  static bool CaseInsensitiveCStringEquals(const char* lhs,
                                           const char* rhs);

  
  
  
  
  
  
  
  
  
  
  
  
  static bool CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
                                               const wchar_t* rhs);

  
  
  static bool EndsWithCaseInsensitive(
      const std::string& str, const std::string& suffix);

  
  static std::string FormatIntWidth2(int value);  

  
  static std::string FormatHexInt(int value);

  
  static std::string FormatByte(unsigned char value);

 private:
  String();  
};  



 std::string StringStreamToString(::std::stringstream* stream);

}  
}  

#line 168 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-string.h"
#line 65 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-filepath.h"












































namespace testing {
namespace internal {












class  FilePath {
 public:
  FilePath() : pathname_("") { }
  FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) { }

  explicit FilePath(const std::string& pathname) : pathname_(pathname) {
    Normalize();
  }

  FilePath& operator=(const FilePath& rhs) {
    Set(rhs);
    return *this;
  }

  void Set(const FilePath& rhs) {
    pathname_ = rhs.pathname_;
  }

  const std::string& string() const { return pathname_; }
  const char* c_str() const { return pathname_.c_str(); }

  
  static FilePath GetCurrentDir();

  
  
  
  
  static FilePath MakeFileName(const FilePath& directory,
                               const FilePath& base_name,
                               int number,
                               const char* extension);

  
  
  
  static FilePath ConcatPaths(const FilePath& directory,
                              const FilePath& relative_path);

  
  
  
  
  
  
  
  
  static FilePath GenerateUniqueFileName(const FilePath& directory,
                                         const FilePath& base_name,
                                         const char* extension);

  
  bool IsEmpty() const { return pathname_.empty(); }

  
  
  
  FilePath RemoveTrailingPathSeparator() const;

  
  
  
  
  
  
  FilePath RemoveDirectoryName() const;

  
  
  
  
  
  
  FilePath RemoveFileName() const;

  
  
  
  
  FilePath RemoveExtension(const char* extension) const;

  
  
  
  
  bool CreateDirectoriesRecursively() const;

  
  
  
  
  bool CreateFolder() const;

  
  
  bool FileOrDirectoryExists() const;

  
  
  bool DirectoryExists() const;

  
  
  
  bool IsDirectory() const;

  
  
  bool IsRootDirectory() const;

  
  bool IsAbsolutePath() const;

 private:
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  void Normalize();

  
  
  
  const char* FindLastPathSeparator() const;

  std::string pathname_;
};  

}  
}  

#line 207 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-filepath.h"
#line 66 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"




















































#line 54 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"

#line 56 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"

namespace testing {
namespace internal {




template <typename T>
std::string GetTypeName() {


  const char* const name = typeid(T).name();











#line 80 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"
  return name;
#line 82 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"





#line 88 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"
}







template <typename T1, typename T2>
struct AssertTypeEq;

template <typename T>
struct AssertTypeEq<T, T> {
  typedef bool type;
};





struct None {};









struct Types0 {};



template <typename T1>
struct Types1 {
  typedef T1 Head;
  typedef Types0 Tail;
};
template <typename T1, typename T2>
struct Types2 {
  typedef T1 Head;
  typedef Types1<T2> Tail;
};

template <typename T1, typename T2, typename T3>
struct Types3 {
  typedef T1 Head;
  typedef Types2<T2, T3> Tail;
};

template <typename T1, typename T2, typename T3, typename T4>
struct Types4 {
  typedef T1 Head;
  typedef Types3<T2, T3, T4> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct Types5 {
  typedef T1 Head;
  typedef Types4<T2, T3, T4, T5> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
struct Types6 {
  typedef T1 Head;
  typedef Types5<T2, T3, T4, T5, T6> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
struct Types7 {
  typedef T1 Head;
  typedef Types6<T2, T3, T4, T5, T6, T7> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
struct Types8 {
  typedef T1 Head;
  typedef Types7<T2, T3, T4, T5, T6, T7, T8> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
struct Types9 {
  typedef T1 Head;
  typedef Types8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
struct Types10 {
  typedef T1 Head;
  typedef Types9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
struct Types11 {
  typedef T1 Head;
  typedef Types10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
struct Types12 {
  typedef T1 Head;
  typedef Types11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
struct Types13 {
  typedef T1 Head;
  typedef Types12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
struct Types14 {
  typedef T1 Head;
  typedef Types13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
struct Types15 {
  typedef T1 Head;
  typedef Types14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
struct Types16 {
  typedef T1 Head;
  typedef Types15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
struct Types17 {
  typedef T1 Head;
  typedef Types16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
struct Types18 {
  typedef T1 Head;
  typedef Types17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
struct Types19 {
  typedef T1 Head;
  typedef Types18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
struct Types20 {
  typedef T1 Head;
  typedef Types19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
struct Types21 {
  typedef T1 Head;
  typedef Types20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
struct Types22 {
  typedef T1 Head;
  typedef Types21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
struct Types23 {
  typedef T1 Head;
  typedef Types22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
struct Types24 {
  typedef T1 Head;
  typedef Types23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
struct Types25 {
  typedef T1 Head;
  typedef Types24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
struct Types26 {
  typedef T1 Head;
  typedef Types25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
struct Types27 {
  typedef T1 Head;
  typedef Types26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
struct Types28 {
  typedef T1 Head;
  typedef Types27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
struct Types29 {
  typedef T1 Head;
  typedef Types28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
struct Types30 {
  typedef T1 Head;
  typedef Types29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
struct Types31 {
  typedef T1 Head;
  typedef Types30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
struct Types32 {
  typedef T1 Head;
  typedef Types31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
struct Types33 {
  typedef T1 Head;
  typedef Types32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
struct Types34 {
  typedef T1 Head;
  typedef Types33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
struct Types35 {
  typedef T1 Head;
  typedef Types34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
struct Types36 {
  typedef T1 Head;
  typedef Types35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
struct Types37 {
  typedef T1 Head;
  typedef Types36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
struct Types38 {
  typedef T1 Head;
  typedef Types37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
struct Types39 {
  typedef T1 Head;
  typedef Types38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
struct Types40 {
  typedef T1 Head;
  typedef Types39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
struct Types41 {
  typedef T1 Head;
  typedef Types40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
struct Types42 {
  typedef T1 Head;
  typedef Types41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
struct Types43 {
  typedef T1 Head;
  typedef Types42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
struct Types44 {
  typedef T1 Head;
  typedef Types43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
struct Types45 {
  typedef T1 Head;
  typedef Types44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
struct Types46 {
  typedef T1 Head;
  typedef Types45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
struct Types47 {
  typedef T1 Head;
  typedef Types46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
struct Types48 {
  typedef T1 Head;
  typedef Types47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
struct Types49 {
  typedef T1 Head;
  typedef Types48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48, T49> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
struct Types50 {
  typedef T1 Head;
  typedef Types49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48, T49, T50> Tail;
};


}  














template <typename T1 = internal::None, typename T2 = internal::None,
    typename T3 = internal::None, typename T4 = internal::None,
    typename T5 = internal::None, typename T6 = internal::None,
    typename T7 = internal::None, typename T8 = internal::None,
    typename T9 = internal::None, typename T10 = internal::None,
    typename T11 = internal::None, typename T12 = internal::None,
    typename T13 = internal::None, typename T14 = internal::None,
    typename T15 = internal::None, typename T16 = internal::None,
    typename T17 = internal::None, typename T18 = internal::None,
    typename T19 = internal::None, typename T20 = internal::None,
    typename T21 = internal::None, typename T22 = internal::None,
    typename T23 = internal::None, typename T24 = internal::None,
    typename T25 = internal::None, typename T26 = internal::None,
    typename T27 = internal::None, typename T28 = internal::None,
    typename T29 = internal::None, typename T30 = internal::None,
    typename T31 = internal::None, typename T32 = internal::None,
    typename T33 = internal::None, typename T34 = internal::None,
    typename T35 = internal::None, typename T36 = internal::None,
    typename T37 = internal::None, typename T38 = internal::None,
    typename T39 = internal::None, typename T40 = internal::None,
    typename T41 = internal::None, typename T42 = internal::None,
    typename T43 = internal::None, typename T44 = internal::None,
    typename T45 = internal::None, typename T46 = internal::None,
    typename T47 = internal::None, typename T48 = internal::None,
    typename T49 = internal::None, typename T50 = internal::None>
struct Types {
  typedef internal::Types50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50> type;
};

template <>
struct Types<internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types0 type;
};
template <typename T1>
struct Types<T1, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types1<T1> type;
};
template <typename T1, typename T2>
struct Types<T1, T2, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types2<T1, T2> type;
};
template <typename T1, typename T2, typename T3>
struct Types<T1, T2, T3, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types3<T1, T2, T3> type;
};
template <typename T1, typename T2, typename T3, typename T4>
struct Types<T1, T2, T3, T4, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types4<T1, T2, T3, T4> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct Types<T1, T2, T3, T4, T5, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types5<T1, T2, T3, T4, T5> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
struct Types<T1, T2, T3, T4, T5, T6, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types6<T1, T2, T3, T4, T5, T6> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
struct Types<T1, T2, T3, T4, T5, T6, T7, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types7<T1, T2, T3, T4, T5, T6, T7> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types8<T1, T2, T3, T4, T5, T6, T7, T8> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, internal::None, internal::None, internal::None> {
  typedef internal::Types47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, T48, internal::None, internal::None> {
  typedef internal::Types48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, T48, T49, internal::None> {
  typedef internal::Types49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49> type;
};

namespace internal {











template <template <typename T> class Tmpl>
struct TemplateSel {
  template <typename T>
  struct Bind {
    typedef Tmpl<T> type;
  };
};








template <typename T>
struct NoneT {};









struct Templates0 {};



template <template <typename T> class T1>
struct Templates1 {
  typedef TemplateSel<T1> Head;
  typedef Templates0 Tail;
};
template <template <typename T> class T1, template <typename T> class T2>
struct Templates2 {
  typedef TemplateSel<T1> Head;
  typedef Templates1<T2> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3>
struct Templates3 {
  typedef TemplateSel<T1> Head;
  typedef Templates2<T2, T3> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4>
struct Templates4 {
  typedef TemplateSel<T1> Head;
  typedef Templates3<T2, T3, T4> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5>
struct Templates5 {
  typedef TemplateSel<T1> Head;
  typedef Templates4<T2, T3, T4, T5> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6>
struct Templates6 {
  typedef TemplateSel<T1> Head;
  typedef Templates5<T2, T3, T4, T5, T6> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7>
struct Templates7 {
  typedef TemplateSel<T1> Head;
  typedef Templates6<T2, T3, T4, T5, T6, T7> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8>
struct Templates8 {
  typedef TemplateSel<T1> Head;
  typedef Templates7<T2, T3, T4, T5, T6, T7, T8> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9>
struct Templates9 {
  typedef TemplateSel<T1> Head;
  typedef Templates8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10>
struct Templates10 {
  typedef TemplateSel<T1> Head;
  typedef Templates9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11>
struct Templates11 {
  typedef TemplateSel<T1> Head;
  typedef Templates10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12>
struct Templates12 {
  typedef TemplateSel<T1> Head;
  typedef Templates11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13>
struct Templates13 {
  typedef TemplateSel<T1> Head;
  typedef Templates12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14>
struct Templates14 {
  typedef TemplateSel<T1> Head;
  typedef Templates13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15>
struct Templates15 {
  typedef TemplateSel<T1> Head;
  typedef Templates14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16>
struct Templates16 {
  typedef TemplateSel<T1> Head;
  typedef Templates15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17>
struct Templates17 {
  typedef TemplateSel<T1> Head;
  typedef Templates16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18>
struct Templates18 {
  typedef TemplateSel<T1> Head;
  typedef Templates17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19>
struct Templates19 {
  typedef TemplateSel<T1> Head;
  typedef Templates18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20>
struct Templates20 {
  typedef TemplateSel<T1> Head;
  typedef Templates19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21>
struct Templates21 {
  typedef TemplateSel<T1> Head;
  typedef Templates20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22>
struct Templates22 {
  typedef TemplateSel<T1> Head;
  typedef Templates21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23>
struct Templates23 {
  typedef TemplateSel<T1> Head;
  typedef Templates22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24>
struct Templates24 {
  typedef TemplateSel<T1> Head;
  typedef Templates23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25>
struct Templates25 {
  typedef TemplateSel<T1> Head;
  typedef Templates24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26>
struct Templates26 {
  typedef TemplateSel<T1> Head;
  typedef Templates25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27>
struct Templates27 {
  typedef TemplateSel<T1> Head;
  typedef Templates26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28>
struct Templates28 {
  typedef TemplateSel<T1> Head;
  typedef Templates27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29>
struct Templates29 {
  typedef TemplateSel<T1> Head;
  typedef Templates28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30>
struct Templates30 {
  typedef TemplateSel<T1> Head;
  typedef Templates29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31>
struct Templates31 {
  typedef TemplateSel<T1> Head;
  typedef Templates30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32>
struct Templates32 {
  typedef TemplateSel<T1> Head;
  typedef Templates31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33>
struct Templates33 {
  typedef TemplateSel<T1> Head;
  typedef Templates32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34>
struct Templates34 {
  typedef TemplateSel<T1> Head;
  typedef Templates33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35>
struct Templates35 {
  typedef TemplateSel<T1> Head;
  typedef Templates34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36>
struct Templates36 {
  typedef TemplateSel<T1> Head;
  typedef Templates35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37>
struct Templates37 {
  typedef TemplateSel<T1> Head;
  typedef Templates36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38>
struct Templates38 {
  typedef TemplateSel<T1> Head;
  typedef Templates37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39>
struct Templates39 {
  typedef TemplateSel<T1> Head;
  typedef Templates38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40>
struct Templates40 {
  typedef TemplateSel<T1> Head;
  typedef Templates39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41>
struct Templates41 {
  typedef TemplateSel<T1> Head;
  typedef Templates40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42>
struct Templates42 {
  typedef TemplateSel<T1> Head;
  typedef Templates41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43>
struct Templates43 {
  typedef TemplateSel<T1> Head;
  typedef Templates42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44>
struct Templates44 {
  typedef TemplateSel<T1> Head;
  typedef Templates43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45>
struct Templates45 {
  typedef TemplateSel<T1> Head;
  typedef Templates44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46>
struct Templates46 {
  typedef TemplateSel<T1> Head;
  typedef Templates45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47>
struct Templates47 {
  typedef TemplateSel<T1> Head;
  typedef Templates46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48>
struct Templates48 {
  typedef TemplateSel<T1> Head;
  typedef Templates47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49>
struct Templates49 {
  typedef TemplateSel<T1> Head;
  typedef Templates48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48, T49> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49, template <typename T> class T50>
struct Templates50 {
  typedef TemplateSel<T1> Head;
  typedef Templates49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48, T49, T50> Tail;
};















template <template <typename T> class T1 = NoneT, template <typename T> class T2 = NoneT,
    template <typename T> class T3 = NoneT, template <typename T> class T4 = NoneT,
    template <typename T> class T5 = NoneT, template <typename T> class T6 = NoneT,
    template <typename T> class T7 = NoneT, template <typename T> class T8 = NoneT,
    template <typename T> class T9 = NoneT, template <typename T> class T10 = NoneT,
    template <typename T> class T11 = NoneT, template <typename T> class T12 = NoneT,
    template <typename T> class T13 = NoneT, template <typename T> class T14 = NoneT,
    template <typename T> class T15 = NoneT, template <typename T> class T16 = NoneT,
    template <typename T> class T17 = NoneT, template <typename T> class T18 = NoneT,
    template <typename T> class T19 = NoneT, template <typename T> class T20 = NoneT,
    template <typename T> class T21 = NoneT, template <typename T> class T22 = NoneT,
    template <typename T> class T23 = NoneT, template <typename T> class T24 = NoneT,
    template <typename T> class T25 = NoneT, template <typename T> class T26 = NoneT,
    template <typename T> class T27 = NoneT, template <typename T> class T28 = NoneT,
    template <typename T> class T29 = NoneT, template <typename T> class T30 = NoneT,
    template <typename T> class T31 = NoneT, template <typename T> class T32 = NoneT,
    template <typename T> class T33 = NoneT, template <typename T> class T34 = NoneT,
    template <typename T> class T35 = NoneT, template <typename T> class T36 = NoneT,
    template <typename T> class T37 = NoneT, template <typename T> class T38 = NoneT,
    template <typename T> class T39 = NoneT, template <typename T> class T40 = NoneT,
    template <typename T> class T41 = NoneT, template <typename T> class T42 = NoneT,
    template <typename T> class T43 = NoneT, template <typename T> class T44 = NoneT,
    template <typename T> class T45 = NoneT, template <typename T> class T46 = NoneT,
    template <typename T> class T47 = NoneT, template <typename T> class T48 = NoneT,
    template <typename T> class T49 = NoneT, template <typename T> class T50 = NoneT>
struct Templates {
  typedef Templates50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48, T49, T50> type;
};

template <>
struct Templates<NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates0 type;
};
template <template <typename T> class T1>
struct Templates<T1, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates1<T1> type;
};
template <template <typename T> class T1, template <typename T> class T2>
struct Templates<T1, T2, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates2<T1, T2> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3>
struct Templates<T1, T2, T3, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates3<T1, T2, T3> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4>
struct Templates<T1, T2, T3, T4, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates4<T1, T2, T3, T4> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5>
struct Templates<T1, T2, T3, T4, T5, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates5<T1, T2, T3, T4, T5> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6>
struct Templates<T1, T2, T3, T4, T5, T6, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates6<T1, T2, T3, T4, T5, T6> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7>
struct Templates<T1, T2, T3, T4, T5, T6, T7, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates7<T1, T2, T3, T4, T5, T6, T7> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates8<T1, T2, T3, T4, T5, T6, T7, T8> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, NoneT, NoneT, NoneT> {
  typedef Templates47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, T48, NoneT, NoneT> {
  typedef Templates48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, T48, T49, NoneT> {
  typedef Templates49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48, T49> type;
};





template <typename T>
struct TypeList {
  typedef Types1<T> type;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
struct TypeList<Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49, T50> > {
  typedef typename Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::type type;
};

#line 3327 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"

}  
}  

#line 3332 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-type-util.h"

#line 67 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"












class ProtocolMessage;
namespace proto2 { class Message; }

namespace testing {



class AssertionResult;                 
class Message;                         
class Test;                            
class TestInfo;                        
class TestPartResult;                  
class UnitTest;                        

template <typename T>
::std::string PrintToString(const T& value);

namespace internal {

struct TraceInfo;                      
class ScopedTrace;                     
class TestInfoImpl;                    
class UnitTestImpl;                    



 extern const char kStackTraceMarker[];















char IsNullLiteralHelper(Secret* p);
char (&IsNullLiteralHelper(...))[2];  











#line 135 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"


 std::string AppendUserMessage(
    const std::string& gtest_msg, const Message& user_msg);









class  GoogleTestFailureException : public ::std::runtime_error {
 public:
  explicit GoogleTestFailureException(const TestPartResult& failure);
};

#line 154 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"


class  ScopedTrace {
 public:
  
  
  ScopedTrace(const char* file, int line, const Message& message);

  
  
  
  
  ~ScopedTrace();

 private:
  ScopedTrace(ScopedTrace const &); void operator=(ScopedTrace const &);
} ;  
                            
                            

namespace edit_distance {





enum EditType { kMatch, kAdd, kRemove, kReplace };
 std::vector<EditType> CalculateOptimalEdits(
    const std::vector<size_t>& left, const std::vector<size_t>& right);


 std::vector<EditType> CalculateOptimalEdits(
    const std::vector<std::string>& left,
    const std::vector<std::string>& right);


 std::string CreateUnifiedDiff(const std::vector<std::string>& left,
                                         const std::vector<std::string>& right,
                                         size_t context = 2);

}  





 std::string DiffStrings(const std::string& left,
                                   const std::string& right,
                                   size_t* total_line_count);
















 AssertionResult EqFailure(const char* expected_expression,
                                     const char* actual_expression,
                                     const std::string& expected_value,
                                     const std::string& actual_value,
                                     bool ignoring_case);


 std::string GetBoolAssertionFailureMessage(
    const AssertionResult& assertion_result,
    const char* expression_text,
    const char* actual_predicate_value,
    const char* expected_predicate_value);






























template <typename RawType>
class FloatingPoint {
 public:
  
  
  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;

  

  
  static const size_t kBitCount = 8*sizeof(RawType);

  
  static const size_t kFractionBitCount =
    std::numeric_limits<RawType>::digits - 1;

  
  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;

  
  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);

  
  static const Bits kFractionBitMask =
    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);

  
  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);

  
  
  
  
  
  
  
  
  
  
  
  
  static const size_t kMaxUlps = 4;

  
  
  
  
  
  
  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }

  

  
  
  
  static RawType ReinterpretBits(const Bits bits) {
    FloatingPoint fp(0);
    fp.u_.bits_ = bits;
    return fp.u_.value_;
  }

  
  static RawType Infinity() {
    return ReinterpretBits(kExponentBitMask);
  }

  
  static RawType Max();

  

  
  const Bits &bits() const { return u_.bits_; }

  
  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }

  
  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }

  
  Bits sign_bit() const { return kSignBitMask & u_.bits_; }

  
  bool is_nan() const {
    
    
    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);
  }

  
  
  
  
  
  
  bool AlmostEquals(const FloatingPoint& rhs) const {
    
    
    if (is_nan() || rhs.is_nan()) return false;

    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
        <= kMaxUlps;
  }

 private:
  
  union FloatingPointUnion {
    RawType value_;  
    Bits bits_;      
  };

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  static Bits SignAndMagnitudeToBiased(const Bits &sam) {
    if (kSignBitMask & sam) {
      
      return ~sam + 1;
    } else {
      
      return kSignBitMask | sam;
    }
  }

  
  
  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,
                                                     const Bits &sam2) {
    const Bits biased1 = SignAndMagnitudeToBiased(sam1);
    const Bits biased2 = SignAndMagnitudeToBiased(sam2);
    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);
  }

  FloatingPointUnion u_;
};



template <>
inline float FloatingPoint<float>::Max() { return 3.402823466e+38F; }
template <>
inline double FloatingPoint<double>::Max() { return 1.7976931348623158e+308; }



typedef FloatingPoint<float> Float;
typedef FloatingPoint<double> Double;







typedef const void* TypeId;

template <typename T>
class TypeIdHelper {
 public:
  
  
  
  static bool dummy_;
};

template <typename T>
bool TypeIdHelper<T>::dummy_ = false;




template <typename T>
TypeId GetTypeId() {
  
  
  
  
  return &(TypeIdHelper<T>::dummy_);
}






 TypeId GetTestTypeId();



class TestFactoryBase {
 public:
  virtual ~TestFactoryBase() {}

  
  
  virtual Test* CreateTest() = 0;

 protected:
  TestFactoryBase() {}

 private:
  TestFactoryBase(TestFactoryBase const &); void operator=(TestFactoryBase const &);
};



template <class TestClass>
class TestFactoryImpl : public TestFactoryBase {
 public:
  virtual Test* CreateTest() { return new TestClass; }
};







 AssertionResult IsHRESULTSuccess(const char* expr,
                                            long hr);  
 AssertionResult IsHRESULTFailure(const char* expr,
                                            long hr);  

#line 499 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"


typedef void (*SetUpTestCaseFunc)();
typedef void (*TearDownTestCaseFunc)();

struct CodeLocation {
  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}

  string file;
  int line;
};



















 TestInfo* MakeAndRegisterTestInfo(
    const char* test_case_name,
    const char* name,
    const char* type_param,
    const char* value_param,
    CodeLocation code_location,
    TypeId fixture_class_id,
    SetUpTestCaseFunc set_up_tc,
    TearDownTestCaseFunc tear_down_tc,
    TestFactoryBase* factory);




 bool SkipPrefix(const char* prefix, const char** pstr);




class  TypedTestCasePState {
 public:
  TypedTestCasePState() : registered_(false) {}

  
  
  
  bool AddTestName(const char* file, int line, const char* case_name,
                   const char* test_name) {
    if (registered_) {
      fprintf((__acrt_iob_func(2)), "%s Test %s must be defined before "
              "REGISTER_TYPED_TEST_CASE_P(%s, ...).\n",
              FormatFileLocation(file, line).c_str(), test_name, case_name);
      fflush((__acrt_iob_func(2)));
      posix::Abort();
    }
    registered_tests_.insert(
        ::std::make_pair(test_name, CodeLocation(file, line)));
    return true;
  }

  bool TestExists(const std::string& test_name) const {
    return registered_tests_.count(test_name) > 0;
  }

  const CodeLocation& GetCodeLocation(const std::string& test_name) const {
    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);
    switch (0) case 0: default: if (::testing::internal::IsTrue(it != registered_tests_.end())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h", 575).GetStream() << "Condition " "it != registered_tests_.end()" " failed. ";
    return it->second;
  }

  
  
  
  const char* VerifyRegisteredTestNames(
      const char* file, int line, const char* registered_tests);

 private:
  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;

  bool registered_;
  RegisteredTestsMap registered_tests_;
};



inline const char* SkipComma(const char* str) {
  const char* comma = strchr(str, ',');
  if (comma == 0) {
    return 0;
  }
  while (IsSpace(*(++comma))) {}
  return comma;
}



inline std::string GetPrefixUntilComma(const char* str) {
  const char* comma = strchr(str, ',');
  return comma == 0 ? str : std::string(str, comma);
}



void SplitString(const ::std::string& str, char delimiter,
                 ::std::vector< ::std::string>* dest);








template <template <typename T> class Fixture, class TestSel, typename Types>
class TypeParameterizedTest {
 public:
  
  
  
  
  static bool Register(const char* prefix,
                       CodeLocation code_location,
                       const char* case_name, const char* test_names,
                       int index) {
    typedef typename Types::Head Type;
    typedef Fixture<Type> FixtureClass;
    typedef typename TestSel::template Bind<Type>::type TestClass;

    
    
    MakeAndRegisterTestInfo(
        (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name + "/"
         + StreamableToString(index)).c_str(),
        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),
        GetTypeName<Type>().c_str(),
        0,  
        code_location,
        GetTypeId<FixtureClass>(),
        TestClass::SetUpTestCase,
        TestClass::TearDownTestCase,
        new TestFactoryImpl<TestClass>);

    
    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>
        ::Register(prefix, code_location, case_name, test_names, index + 1);
  }
};


template <template <typename T> class Fixture, class TestSel>
class TypeParameterizedTest<Fixture, TestSel, Types0> {
 public:
  static bool Register(const char* , CodeLocation,
                       const char* , const char* ,
                       int ) {
    return true;
  }
};





template <template <typename T> class Fixture, typename Tests, typename Types>
class TypeParameterizedTestCase {
 public:
  static bool Register(const char* prefix, CodeLocation code_location,
                       const TypedTestCasePState* state,
                       const char* case_name, const char* test_names) {
    std::string test_name = StripTrailingSpaces(
        GetPrefixUntilComma(test_names));
    if (!state->TestExists(test_name)) {
      fprintf((__acrt_iob_func(2)), "Failed to get code location for test %s.%s at %s.",
              case_name, test_name.c_str(),
              FormatFileLocation(code_location.file.c_str(),
                                 code_location.line).c_str());
      fflush((__acrt_iob_func(2)));
      posix::Abort();
    }
    const CodeLocation& test_location = state->GetCodeLocation(test_name);

    typedef typename Tests::Head Head;

    
    TypeParameterizedTest<Fixture, Head, Types>::Register(
        prefix, test_location, case_name, test_names, 0);

    
    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>
        ::Register(prefix, code_location, state,
                   case_name, SkipComma(test_names));
  }
};


template <template <typename T> class Fixture, typename Types>
class TypeParameterizedTestCase<Fixture, Templates0, Types> {
 public:
  static bool Register(const char* , CodeLocation,
                       const TypedTestCasePState* ,
                       const char* , const char* ) {
    return true;
  }
};

#line 715 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"











 std::string GetCurrentOsStackTraceExceptTop(
    UnitTest* unit_test, int skip_count);





 bool AlwaysTrue();


inline bool AlwaysFalse() { return !AlwaysTrue(); }




struct  ConstCharPtr {
  ConstCharPtr(const char* str) : value(str) {}
  operator bool() const { return true; }
  const char* value;
};






class  Random {
 public:
  static const UInt32 kMaxRange = 1u << 31;

  explicit Random(UInt32 seed) : state_(seed) {}

  void Reseed(UInt32 seed) { state_ = seed; }

  
  
  UInt32 Generate(UInt32 range);

 private:
  UInt32 state_;
  Random(Random const &); void operator=(Random const &);
};



template <typename T1, typename T2>
struct CompileAssertTypesEqual;

template <typename T>
struct CompileAssertTypesEqual<T, T> {
};




template <typename T>
struct RemoveReference { typedef T type; };  
template <typename T>
struct RemoveReference<T&> { typedef T type; };  









template <typename T>
struct RemoveConst { typedef T type; };  
template <typename T>
struct RemoveConst<const T> { typedef T type; };  




template <typename T, size_t N>
struct RemoveConst<const T[N]> {
  typedef typename RemoveConst<T>::type type[N];
};









#line 816 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"













template <typename T>
struct AddReference { typedef T& type; };  
template <typename T>
struct AddReference<T&> { typedef T& type; };  





















template <typename From, typename To>
class ImplicitlyConvertible {
 private:
  
  

  
  
  
  static typename AddReference<From>::type MakeFrom();

  
  
  
  
  
  
  
  
  
  
  static char Helper(To);
  static char (&Helper(...))[2];  

  
  
 public:





#line 887 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
  
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4244))
  static const bool value =
      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
  __pragma(warning(pop))
#line 895 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"
};
template <typename From, typename To>
const bool ImplicitlyConvertible<From, To>::value;




template <typename T>
struct IsAProtocolMessage
    : public bool_constant<
  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||
  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {
};






















typedef int IsContainer;
template <class C>
IsContainer IsContainerTest(int ,
                            typename C::iterator*  = 0,
                            typename C::const_iterator*  = 0) {
  return 0;
}

typedef char IsNotContainer;
template <class C>
IsNotContainer IsContainerTest(long ) { return '\0'; }





template<bool> struct EnableIf;
template<> struct EnableIf<true> { typedef void type; };  







template <typename T, typename U>
bool ArrayEq(const T* lhs, size_t size, const U* rhs);


template <typename T, typename U>
inline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }


template <typename T, typename U, size_t N>
inline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {
  return internal::ArrayEq(lhs, N, rhs);
}




template <typename T, typename U>
bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
  for (size_t i = 0; i != size; i++) {
    if (!internal::ArrayEq(lhs[i], rhs[i]))
      return false;
  }
  return true;
}



template <typename Iter, typename Element>
Iter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {
  for (Iter it = begin; it != end; ++it) {
    if (internal::ArrayEq(*it, elem))
      return it;
  }
  return end;
}





template <typename T, typename U>
void CopyArray(const T* from, size_t size, U* to);


template <typename T, typename U>
inline void CopyArray(const T& from, U* to) { *to = from; }


template <typename T, typename U, size_t N>
inline void CopyArray(const T(&from)[N], U(*to)[N]) {
  internal::CopyArray(from, N, *to);
}




template <typename T, typename U>
void CopyArray(const T* from, size_t size, U* to) {
  for (size_t i = 0; i != size; i++) {
    internal::CopyArray(from[i], to + i);
  }
}





struct RelationToSourceReference {};
struct RelationToSourceCopy {};









template <typename Element>
class NativeArray {
 public:
  
  typedef Element value_type;
  typedef Element* iterator;
  typedef const Element* const_iterator;

  
  NativeArray(const Element* array, size_t count, RelationToSourceReference) {
    InitRef(array, count);
  }

  
  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {
    InitCopy(array, count);
  }

  
  NativeArray(const NativeArray& rhs) {
    (this->*rhs.clone_)(rhs.array_, rhs.size_);
  }

  ~NativeArray() {
    if (clone_ != &NativeArray::InitRef)
      delete[] array_;
  }

  
  size_t size() const { return size_; }
  const_iterator begin() const { return array_; }
  const_iterator end() const { return array_ + size_; }
  bool operator==(const NativeArray& rhs) const {
    return size() == rhs.size() &&
        ArrayEq(begin(), size(), rhs.begin());
  }

 private:
  enum {
    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<
        Element, typename ::testing::internal::RemoveConst<typename ::testing::internal::RemoveReference<Element>::type>::type>::value,
  };

  
  void InitCopy(const Element* array, size_t a_size) {
    Element* const copy = new Element[a_size];
    CopyArray(array, a_size, copy);
    array_ = copy;
    size_ = a_size;
    clone_ = &NativeArray::InitCopy;
  }

  
  void InitRef(const Element* array, size_t a_size) {
    array_ = array;
    size_ = a_size;
    clone_ = &NativeArray::InitRef;
  }

  const Element* array_;
  size_t size_;
  void (NativeArray::*clone_)(const Element*, size_t);

  void operator=(NativeArray const &);
};

}  
}  








































































































































#line 1238 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-internal.h"


#line 59 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"








































#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-death-test-internal.h"











































namespace testing {
namespace internal {

 extern ::std::string FLAGS_gtest_internal_run_death_test;


const char kDeathTestStyleFlag[] = "death_test_style";
const char kDeathTestUseFork[] = "death_test_use_fork";
const char kInternalRunDeathTestFlag[] = "internal_run_death_test";
















class  DeathTest {
 public:
  
  
  
  
  
  
  
  
  static bool Create(const char* statement, const RE* regex,
                     const char* file, int line, DeathTest** test);
  DeathTest();
  virtual ~DeathTest() { }

  
  class ReturnSentinel {
   public:
    explicit ReturnSentinel(DeathTest* test) : test_(test) { }
    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }
   private:
    DeathTest* const test_;
    ReturnSentinel(ReturnSentinel const &); void operator=(ReturnSentinel const &);
  } ;

  
  
  
  
  
  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };

  
  enum AbortReason {
    TEST_ENCOUNTERED_RETURN_STATEMENT,
    TEST_THREW_EXCEPTION,
    TEST_DID_NOT_DIE
  };

  
  virtual TestRole AssumeRole() = 0;

  
  virtual int Wait() = 0;

  
  
  
  
  
  
  
  virtual bool Passed(bool exit_status_ok) = 0;

  
  virtual void Abort(AbortReason reason) = 0;

  
  
  static const char* LastMessage();

  static void set_last_death_test_message(const std::string& message);

 private:
  
  static std::string last_death_test_message_;

  DeathTest(DeathTest const &); void operator=(DeathTest const &);
};


class DeathTestFactory {
 public:
  virtual ~DeathTestFactory() { }
  virtual bool Create(const char* statement, const RE* regex,
                      const char* file, int line, DeathTest** test) = 0;
};


class DefaultDeathTestFactory : public DeathTestFactory {
 public:
  virtual bool Create(const char* statement, const RE* regex,
                      const char* file, int line, DeathTest** test);
};



 bool ExitedUnsuccessfully(int exit_status);
























#line 182 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-death-test-internal.h"




















































class InternalRunDeathTestFlag {
 public:
  InternalRunDeathTestFlag(const std::string& a_file,
                           int a_line,
                           int an_index,
                           int a_write_fd)
      : file_(a_file), line_(a_line), index_(an_index),
        write_fd_(a_write_fd) {}

  ~InternalRunDeathTestFlag() {
    if (write_fd_ >= 0)
      posix::Close(write_fd_);
  }

  const std::string& file() const { return file_; }
  int line() const { return line_; }
  int index() const { return index_; }
  int write_fd() const { return write_fd_; }

 private:
  std::string file_;
  int line_;
  int index_;
  int write_fd_;

  InternalRunDeathTestFlag(InternalRunDeathTestFlag const &); void operator=(InternalRunDeathTestFlag const &);
};




InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();
















































#line 315 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-death-test-internal.h"

}  
}  

#line 320 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-death-test-internal.h"
#line 42 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"

namespace testing {






 extern ::std::string FLAGS_gtest_death_test_style;



namespace internal {






 bool InDeathTestChild();

}  






























































































































class  ExitedWithCode {
 public:
  explicit ExitedWithCode(int exit_code);
  bool operator()(int exit_status) const;
 private:
  
  void operator=(const ExitedWithCode& other);

  const int exit_code_;
};











#line 212 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"




























































#line 273 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"
#line 274 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"
















#line 291 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"

}  

#line 295 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-death-test.h"
#line 61 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"



















































































































































































#line 181 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"





#line 187 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"





#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"






































#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Container>
	class back_insert_iterator
		: public _Outit
	{	
public:
	typedef back_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	explicit back_insert_iterator(_Container& _Cont)
		: container(::std:: addressof(_Cont))
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_back(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_back(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<back_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	
	return (back_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class front_insert_iterator
		: public _Outit
	{	
public:
	typedef front_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	explicit front_insert_iterator(_Container& _Cont)
		: container(::std:: addressof(_Cont))
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_front(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_front(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<front_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{	
	return (front_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class insert_iterator
		: public _Outit
	{	
public:
	typedef insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(::std:: addressof(_Cont)), iter(_Where)
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
		++iter;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	typename _Container::iterator iter;	
	};

template<class _Container>
	struct _Is_checked_helper<insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	insert_iterator<_Container> inserter(_Container& _Cont,
		typename _Container::iterator _Where)
	{	
	return (insert_iterator<_Container>(_Cont, _Where));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
		: public iterator<input_iterator_tag, _Ty, _Diff,
			const _Ty *, const _Ty&>
	{	
	typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef const _Ty *pointer;

	constexpr istream_iterator()
		: _Myistr(0), _Myval()
		{	
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(&_Istr)
		{	
		_Getval();
		}

	const _Ty& operator*() const
		{	
		return (_Myval);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		_Getval();
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{	
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{	
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			_Myistr = 0;
		}

	istream_type *_Myistr;	
	_Ty _Myval;	
	};

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
		: public true_type
	{	
	};

		
template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (!(_Left == _Right));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
		: public _Outit
	{	
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostream_iterator(ostream_type& _Ostr,
		const _Elem *_Delim = 0)
		: _Myostr(&_Ostr), _Mydelim(_Delim)
		{	
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
		{	
		*_Myostr << _Val;
		if (_Mydelim != 0)
			*_Myostr << _Mydelim;
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
		{	
		return (*this);
		}

protected:
	const _Elem *_Mydelim;	
	ostream_type *_Myostr;	
	};

template<class _Ty,
	class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
		: public true_type
	{	
	};
}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

		
template<class _Iterator>
	class checked_array_iterator
	{	
public:
	typedef checked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	checked_array_iterator()
		: _Myarray(), _Mysize(0), _Myindex(0)
		{	
		}

	checked_array_iterator(_Iterator _Array, size_t _Size,
		size_t _Index = 0)
		: _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
		{	
		{ if (!(_Index <= _Size)) { (void)( (!!(("_Index <= _Size" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 383, 0, L"%ls", L"\"_Index <= _Size\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 383, 0); } ; };
		}

	_Iterator base() const
		{	
		return (_Myarray + _Myindex);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myindex = _Right - _Myarray;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { (void)( (!!(("_Myarray != 0 && _Myindex < _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 407, 0, L"%ls", L"\"_Myarray != 0 && _Myindex < _Mysize\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 407, 0); } ; };
#line 408 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"
		return (_Myarray[_Myindex]);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { (void)( (!!(("_Myarray != 0 && _Myindex < _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 419, 0, L"%ls", L"\"_Myarray != 0 && _Myindex < _Mysize\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 419, 0); } ; };
#line 420 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"
		++_Myindex;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		{ if (!(_Myarray != 0 && 0 < _Myindex)) { (void)( (!!(("_Myarray != 0 && 0 < _Myindex" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 434, 0, L"%ls", L"\"_Myarray != 0 && 0 < _Myindex\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 434, 0); } ; };
#line 435 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"
		--_Myindex;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		{ if (!(_Myarray != 0 && _Myindex + _Off <= _Mysize)) { (void)( (!!(("_Myarray != 0 && _Myindex + _Off <= _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 449, 0, L"%ls", L"\"_Myarray != 0 && _Myindex + _Off <= _Mysize\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 449, 0); } ; };
#line 450 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"
		_Myindex += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void)( (!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 473, 0, L"%ls", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 473, 0); } ; };
		return (_Myindex - _Right._Myindex);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void)( (!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 484, 0, L"%ls", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 484, 0); } ; };
		return (_Myindex == _Right._Myindex);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void)( (!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 495, 0, L"%ls", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator", 495, 0); } ; };
		return (_Myindex < _Right._Myindex);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myarray;	
	size_t _Mysize;	
	size_t _Myindex;	
	};

template<class _Iterator> inline
	typename checked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(checked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator>&
		_Rechecked(checked_array_iterator<_Iterator>& _Iter,
			typename checked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> operator+(
		typename checked_array_iterator<_Iterator>::difference_type _Off,
		checked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> make_checked_array_iterator(
		_Iterator _Array, size_t _Size, size_t _Index = 0)
	{	
	return (checked_array_iterator<_Iterator>(_Array, _Size, _Index));
	}

		
template<class _Iterator>
	class unchecked_array_iterator
	{	
public:
	typedef unchecked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	unchecked_array_iterator()
		: _Myptr()
		{	
		}

	explicit unchecked_array_iterator(_Iterator _Ptr)
		: _Myptr(_Ptr)
		{	
		}

	_Iterator base() const
		{	
		return (_Myptr);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		return (*_Myptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myptr;	
	};

template<class _Iterator> inline
	typename unchecked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(unchecked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator>&
		_Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
			typename unchecked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> operator+(
		typename unchecked_array_iterator<_Iterator>::difference_type _Off,
		unchecked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> make_unchecked_array_iterator(
		_Iterator _Ptr)
	{	
	return (unchecked_array_iterator<_Iterator>(_Ptr));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 736 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"
#line 737 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iterator"





#line 40 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"








#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h"







































































#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"









#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 73 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h"



namespace testing {
namespace internal {


 extern ::testing::internal::Mutex g_linked_ptr_mutex;








class linked_ptr_internal {
 public:
  
  void join_new() {
    next_ = this;
  }

  
  
  
  
  
  
  
  
  
  

  
  void join(linked_ptr_internal const* ptr)
       {
    MutexLock lock(&g_linked_ptr_mutex);

    linked_ptr_internal const* p = ptr;
    while (p->next_ != ptr) {
      (void)( (!!(p->next_ != this && "Trying to join() a linked ring we are already in. " "Is GMock thread safety enabled?")) || (_wassert(L"p->next_ != this && \"Trying to join() a linked ring we are already in. \" \"Is GMock thread safety enabled?\"", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h", (unsigned)(116)), 0) );
#line 117 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h"
      p = p->next_;
    }
    p->next_ = this;
    next_ = ptr;
  }

  
  
  bool depart()
       {
    MutexLock lock(&g_linked_ptr_mutex);

    if (next_ == this) return true;
    linked_ptr_internal const* p = next_;
    while (p->next_ != this) {
      (void)( (!!(p->next_ != next_ && "Trying to depart() a linked ring we are not in. " "Is GMock thread safety enabled?")) || (_wassert(L"p->next_ != next_ && \"Trying to depart() a linked ring we are not in. \" \"Is GMock thread safety enabled?\"", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h", (unsigned)(134)), 0) );
#line 135 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h"
      p = p->next_;
    }
    p->next_ = next_;
    return false;
  }

 private:
  mutable linked_ptr_internal const* next_;
};

template <typename T>
class linked_ptr {
 public:
  typedef T element_type;

  
  
  explicit linked_ptr(T* ptr = 0) { capture(ptr); }
  ~linked_ptr() { depart(); }

  
  template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }
  linked_ptr(linked_ptr const& ptr) {  
    (void)( (!!(&ptr != this)) || (_wassert(L"&ptr != this", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h", (unsigned)(158)), 0) );
    copy(&ptr);
  }

  
  template <typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {
    depart();
    copy(&ptr);
    return *this;
  }

  linked_ptr& operator=(linked_ptr const& ptr) {
    if (&ptr != this) {
      depart();
      copy(&ptr);
    }
    return *this;
  }

  
  void reset(T* ptr = 0) {
    depart();
    capture(ptr);
  }
  T* get() const { return value_; }
  T* operator->() const { return value_; }
  T& operator*() const { return *value_; }

  bool operator==(T* p) const { return value_ == p; }
  bool operator!=(T* p) const { return value_ != p; }
  template <typename U>
  bool operator==(linked_ptr<U> const& ptr) const {
    return value_ == ptr.get();
  }
  template <typename U>
  bool operator!=(linked_ptr<U> const& ptr) const {
    return value_ != ptr.get();
  }

 private:
  template <typename U>
  friend class linked_ptr;

  T* value_;
  linked_ptr_internal link_;

  void depart() {
    if (link_.depart()) delete value_;
  }

  void capture(T* ptr) {
    value_ = ptr;
    link_.join_new();
  }

  template <typename U> void copy(linked_ptr<U> const* ptr) {
    value_ = ptr->get();
    if (value_)
      link_.join(&ptr->link_);
    else
      link_.join_new();
  }
};

template<typename T> inline
bool operator==(T* ptr, const linked_ptr<T>& x) {
  return ptr == x.get();
}

template<typename T> inline
bool operator!=(T* ptr, const linked_ptr<T>& x) {
  return ptr != x.get();
}




template <typename T>
linked_ptr<T> make_linked_ptr(T* ptr) {
  return linked_ptr<T>(ptr);
}

}  
}  

#line 244 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-linked_ptr.h"
#line 49 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"

#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"











































































































#line 109 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

namespace testing {



namespace internal2 {



 void PrintBytesInObjectTo(const unsigned char* obj_bytes,
                                     size_t count,
                                     ::std::ostream* os);



enum TypeKind {
  kProtobuf,              
  kConvertibleToInteger,  
                          
  kOtherType              
};





template <typename T, TypeKind kTypeKind>
class TypeWithoutFormatter {
 public:
  
  static void PrintValue(const T& value, ::std::ostream* os) {
    PrintBytesInObjectTo(reinterpret_cast<const unsigned char*>(&value),
                         sizeof(value), os);
  }
};




const size_t kProtobufOneLinerMaxLength = 50;

template <typename T>
class TypeWithoutFormatter<T, kProtobuf> {
 public:
  static void PrintValue(const T& value, ::std::ostream* os) {
    const ::testing::internal::string short_str = value.ShortDebugString();
    const ::testing::internal::string pretty_str =
        short_str.length() <= kProtobufOneLinerMaxLength ?
        short_str : ("\n" + value.DebugString());
    *os << ("<" + pretty_str + ">");
  }
};

template <typename T>
class TypeWithoutFormatter<T, kConvertibleToInteger> {
 public:
  
  
  
  
  
  
  
  static void PrintValue(const T& value, ::std::ostream* os) {
    const internal::BiggestInt kBigInt = value;
    *os << kBigInt;
  }
};

























template <typename Char, typename CharTraits, typename T>
::std::basic_ostream<Char, CharTraits>& operator<<(
    ::std::basic_ostream<Char, CharTraits>& os, const T& x) {
  TypeWithoutFormatter<T,
      (internal::IsAProtocolMessage<T>::value ? kProtobuf :
       internal::ImplicitlyConvertible<const T&, internal::BiggestInt>::value ?
       kConvertibleToInteger : kOtherType)>::PrintValue(x, &os);
  return os;
}

}  
}  



namespace testing_internal {



template <typename T>
void DefaultPrintNonContainerTo(const T& value, ::std::ostream* os) {
  
  
  
  
  
  
  
  
  
  
  
  using namespace ::testing::internal2;  

  
  
  
  
  
  
  
  
  
  
  
  
  
  *os << value;
}

}  

namespace testing {
namespace internal {
















template <typename ToPrint, typename OtherOperand>
class FormatForComparison {
 public:
  static ::std::string Format(const ToPrint& value) {
    return ::testing::PrintToString(value);
  }
};


template <typename ToPrint, size_t N, typename OtherOperand>
class FormatForComparison<ToPrint[N], OtherOperand> {
 public:
  static ::std::string Format(const ToPrint* value) {
    return FormatForComparison<const ToPrint*, OtherOperand>::Format(value);
  }
};













template <typename OtherOperand> class FormatForComparison<char*, OtherOperand> { public: static ::std::string Format(char* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<const char*, OtherOperand> { public: static ::std::string Format(const char* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<wchar_t*, OtherOperand> { public: static ::std::string Format(wchar_t* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<const wchar_t*, OtherOperand> { public: static ::std::string Format(const wchar_t* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };















template <> class FormatForComparison<char*, ::std::string> { public: static ::std::string Format(char* value) { return ::testing::PrintToString(value); } };
template <> class FormatForComparison<const char*, ::std::string> { public: static ::std::string Format(const char* value) { return ::testing::PrintToString(value); } };




#line 327 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"




#line 332 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"


template <> class FormatForComparison<wchar_t*, ::std::wstring> { public: static ::std::string Format(wchar_t* value) { return ::testing::PrintToString(value); } };
template <> class FormatForComparison<const wchar_t*, ::std::wstring> { public: static ::std::string Format(const wchar_t* value) { return ::testing::PrintToString(value); } };
#line 337 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"











template <typename T1, typename T2>
std::string FormatForComparisonFailureMessage(
    const T1& value, const T2& ) {
  return FormatForComparison<T1, T2>::Format(value);
}








template <typename T>
class UniversalPrinter;

template <typename T>
void UniversalPrint(const T& value, ::std::ostream* os);



template <typename C>
void DefaultPrintTo(IsContainer ,
                    false_type ,
                    const C& container, ::std::ostream* os) {
  const size_t kMaxCount = 32;  
  *os << '{';
  size_t count = 0;
  for (typename C::const_iterator it = container.begin();
       it != container.end(); ++it, ++count) {
    if (count > 0) {
      *os << ',';
      if (count == kMaxCount) {  
        *os << " ...";
        break;
      }
    }
    *os << ' ';
    
    
    internal::UniversalPrint(*it, os);
  }

  if (count > 0) {
    *os << ' ';
  }
  *os << '}';
}







template <typename T>
void DefaultPrintTo(IsNotContainer ,
                    true_type ,
                    T* p, ::std::ostream* os) {
  if (p == 0) {
    *os << "NULL";
  } else {
    
    
    
    
    
    if (IsTrue(ImplicitlyConvertible<T*, const void*>::value)) {
      
      
      
      *os << p;
    } else {
      
      
      
      
      
      
      *os << reinterpret_cast<const void*>(
          reinterpret_cast<internal::UInt64>(p));
    }
  }
}



template <typename T>
void DefaultPrintTo(IsNotContainer ,
                    false_type ,
                    const T& value, ::std::ostream* os) {
  ::testing_internal::DefaultPrintNonContainerTo(value, os);
}












template <typename T>
void PrintTo(const T& value, ::std::ostream* os) {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  DefaultPrintTo(IsContainerTest<T>(0), is_pointer<T>(), value, os);
}






 void PrintTo(unsigned char c, ::std::ostream* os);
 void PrintTo(signed char c, ::std::ostream* os);
inline void PrintTo(char c, ::std::ostream* os) {
  
  
  
  PrintTo(static_cast<unsigned char>(c), os);
}


inline void PrintTo(bool x, ::std::ostream* os) {
  *os << (x ? "true" : "false");
}








 void PrintTo(wchar_t wc, ::std::ostream* os);


 void PrintTo(const char* s, ::std::ostream* os);
inline void PrintTo(char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const char*>(s), os);
}



inline void PrintTo(const signed char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(signed char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(const unsigned char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(unsigned char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}








 void PrintTo(const wchar_t* s, ::std::ostream* os);
inline void PrintTo(wchar_t* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const wchar_t*>(s), os);
}
#line 541 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"






template <typename T>
void PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {
  UniversalPrint(a[0], os);
  for (size_t i = 1; i != count; i++) {
    *os << ", ";
    UniversalPrint(a[i], os);
  }
}







#line 563 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

 void PrintStringTo(const ::std::string&s, ::std::ostream* os);
inline void PrintTo(const ::std::string& s, ::std::ostream* os) {
  PrintStringTo(s, os);
}







#line 576 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"


 void PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);
inline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {
  PrintWideStringTo(s, os);
}
#line 583 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"




template <typename T>
void PrintTupleTo(const T& t, ::std::ostream* os);
#line 590 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"










inline void PrintTo(const ::std::tr1::tuple<>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1>
void PrintTo(const ::std::tr1::tuple<T1>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2>
void PrintTo(const ::std::tr1::tuple<T1, T2>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5>& t,
             ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
          typename T6>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6>& t,
             ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
          typename T6, typename T7>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7>& t,
             ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
          typename T6, typename T7, typename T8>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8>& t,
             ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
          typename T6, typename T7, typename T8, typename T9>
void PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>& t,
             ::std::ostream* os) {
  PrintTupleTo(t, os);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
          typename T6, typename T7, typename T8, typename T9, typename T10>
void PrintTo(
    const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>& t,
    ::std::ostream* os) {
  PrintTupleTo(t, os);
}
#line 666 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"






#line 673 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"


template <typename T1, typename T2>
void PrintTo(const ::std::pair<T1, T2>& value, ::std::ostream* os) {
  *os << '(';
  
  
  UniversalPrinter<T1>::Print(value.first, os);
  *os << ", ";
  UniversalPrinter<T2>::Print(value.second, os);
  *os << ')';
}



template <typename T>
class UniversalPrinter {
 public:
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4180))

  
  
  
  static void Print(const T& value, ::std::ostream* os) {
    
    
    
    
    
    
    
    
    PrintTo(value, os);
  }

  __pragma(warning(pop))
};



template <typename T>
void UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {
  if (len == 0) {
    *os << "{}";
  } else {
    *os << "{ ";
    const size_t kThreshold = 18;
    const size_t kChunkSize = 8;
    
    
    
    
    if (len <= kThreshold) {
      PrintRawArrayTo(begin, len, os);
    } else {
      PrintRawArrayTo(begin, kChunkSize, os);
      *os << ", ..., ";
      PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);
    }
    *os << " }";
  }
}

 void UniversalPrintArray(
    const char* begin, size_t len, ::std::ostream* os);


 void UniversalPrintArray(
    const wchar_t* begin, size_t len, ::std::ostream* os);


template <typename T, size_t N>
class UniversalPrinter<T[N]> {
 public:
  
  
  static void Print(const T (&a)[N], ::std::ostream* os) {
    UniversalPrintArray(a, N, os);
  }
};


template <typename T>
class UniversalPrinter<T&> {
 public:
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4180))

  static void Print(const T& value, ::std::ostream* os) {
    
    
    *os << "@" << reinterpret_cast<const void*>(&value) << " ";

    
    UniversalPrint(value, os);
  }

  __pragma(warning(pop))
};





template <typename T>
class UniversalTersePrinter {
 public:
  static void Print(const T& value, ::std::ostream* os) {
    UniversalPrint(value, os);
  }
};
template <typename T>
class UniversalTersePrinter<T&> {
 public:
  static void Print(const T& value, ::std::ostream* os) {
    UniversalPrint(value, os);
  }
};
template <typename T, size_t N>
class UniversalTersePrinter<T[N]> {
 public:
  static void Print(const T (&value)[N], ::std::ostream* os) {
    UniversalPrinter<T[N]>::Print(value, os);
  }
};
template <>
class UniversalTersePrinter<const char*> {
 public:
  static void Print(const char* str, ::std::ostream* os) {
    if (str == 0) {
      *os << "NULL";
    } else {
      UniversalPrint(string(str), os);
    }
  }
};
template <>
class UniversalTersePrinter<char*> {
 public:
  static void Print(char* str, ::std::ostream* os) {
    UniversalTersePrinter<const char*>::Print(str, os);
  }
};


template <>
class UniversalTersePrinter<const wchar_t*> {
 public:
  static void Print(const wchar_t* str, ::std::ostream* os) {
    if (str == 0) {
      *os << "NULL";
    } else {
      UniversalPrint(::std::wstring(str), os);
    }
  }
};
#line 833 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

template <>
class UniversalTersePrinter<wchar_t*> {
 public:
  static void Print(wchar_t* str, ::std::ostream* os) {
    UniversalTersePrinter<const wchar_t*>::Print(str, os);
  }
};

template <typename T>
void UniversalTersePrint(const T& value, ::std::ostream* os) {
  UniversalTersePrinter<T>::Print(value, os);
}





template <typename T>
void UniversalPrint(const T& value, ::std::ostream* os) {
  
  
  typedef T T1;
  UniversalPrinter<T1>::Print(value, os);
}

typedef ::std::vector<string> Strings;








template <typename TupleT>
struct TuplePolicy;


template <typename TupleT>
struct TuplePolicy {
  typedef TupleT Tuple;
  static const size_t tuple_size = ::std::tr1::tuple_size<Tuple>::value;

  template <size_t I>
  struct tuple_element : ::std::tr1::tuple_element<I, Tuple> {};

  template <size_t I>
  static typename AddReference<
      const typename ::std::tr1::tuple_element<I, Tuple>::type>::type get(
      const Tuple& tuple) {
    return ::std::tr1::get<I>(tuple);
  }
};
template <typename TupleT>
const size_t TuplePolicy<TupleT>::tuple_size;
#line 890 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"


















#line 909 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"










template <size_t N>
struct TuplePrefixPrinter {
  
  template <typename Tuple>
  static void PrintPrefixTo(const Tuple& t, ::std::ostream* os) {
    TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);
    __pragma(warning(push)) __pragma(warning(disable: 4127))
    if (N > 1) {
    __pragma(warning(pop))
      *os << ", ";
    }
    UniversalPrinter<
        typename TuplePolicy<Tuple>::template tuple_element<N - 1>::type>
        ::Print(TuplePolicy<Tuple>::template get<N - 1>(t), os);
  }

  
  
  template <typename Tuple>
  static void TersePrintPrefixToStrings(const Tuple& t, Strings* strings) {
    TuplePrefixPrinter<N - 1>::TersePrintPrefixToStrings(t, strings);
    ::std::stringstream ss;
    UniversalTersePrint(TuplePolicy<Tuple>::template get<N - 1>(t), &ss);
    strings->push_back(ss.str());
  }
};


template <>
struct TuplePrefixPrinter<0> {
  template <typename Tuple>
  static void PrintPrefixTo(const Tuple&, ::std::ostream*) {}

  template <typename Tuple>
  static void TersePrintPrefixToStrings(const Tuple&, Strings*) {}
};



template <typename Tuple>
void PrintTupleTo(const Tuple& t, ::std::ostream* os) {
  *os << "(";
  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::PrintPrefixTo(t, os);
  *os << ")";
}




template <typename Tuple>
Strings UniversalTersePrintTupleFieldsToStrings(const Tuple& value) {
  Strings result;
  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::
      TersePrintPrefixToStrings(value, &result);
  return result;
}
#line 976 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

}  

template <typename T>
::std::string PrintToString(const T& value) {
  ::std::stringstream ss;
  internal::UniversalTersePrinter<T>::Print(value, &ss);
  return ss.str();
}

}  




#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\custom\\gtest-printers.h"









































#line 43 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\custom\\gtest-printers.h"
#line 992 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

#line 994 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-printers.h"

#line 51 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"



namespace testing {



template <class ParamType>
struct TestParamInfo {
  TestParamInfo(const ParamType& a_param, size_t an_index) :
    param(a_param),
    index(an_index) {}
  ParamType param;
  size_t index;
};



struct PrintToStringParamName {
  template <class ParamType>
  std::string operator()(const TestParamInfo<ParamType>& info) const {
    return PrintToString(info.param);
  }
};

namespace internal {







 void ReportInvalidTestCaseType(const char* test_case_name,
                                          CodeLocation code_location);

template <typename> class ParamGeneratorInterface;
template <typename> class ParamGenerator;



template <typename T>
class ParamIteratorInterface {
 public:
  virtual ~ParamIteratorInterface() {}
  
  
  
  virtual const ParamGeneratorInterface<T>* BaseGenerator() const = 0;
  
  
  
  
  virtual void Advance() = 0;
  
  
  virtual ParamIteratorInterface* Clone() const = 0;
  
  
  
  
  virtual const T* Current() const = 0;
  
  
  
  virtual bool Equals(const ParamIteratorInterface& other) const = 0;
};




template <typename T>
class ParamIterator {
 public:
  typedef T value_type;
  typedef const T& reference;
  typedef ptrdiff_t difference_type;

  
  ParamIterator(const ParamIterator& other) : impl_(other.impl_->Clone()) {}
  ParamIterator& operator=(const ParamIterator& other) {
    if (this != &other)
      impl_.reset(other.impl_->Clone());
    return *this;
  }

  const T& operator*() const { return *impl_->Current(); }
  const T* operator->() const { return impl_->Current(); }
  
  ParamIterator& operator++() {
    impl_->Advance();
    return *this;
  }
  
  ParamIterator operator++(int ) {
    ParamIteratorInterface<T>* clone = impl_->Clone();
    impl_->Advance();
    return ParamIterator(clone);
  }
  bool operator==(const ParamIterator& other) const {
    return impl_.get() == other.impl_.get() || impl_->Equals(*other.impl_);
  }
  bool operator!=(const ParamIterator& other) const {
    return !(*this == other);
  }

 private:
  friend class ParamGenerator<T>;
  explicit ParamIterator(ParamIteratorInterface<T>* impl) : impl_(impl) {}
  scoped_ptr<ParamIteratorInterface<T> > impl_;
};



template <typename T>
class ParamGeneratorInterface {
 public:
  typedef T ParamType;

  virtual ~ParamGeneratorInterface() {}

  
  virtual ParamIteratorInterface<T>* Begin() const = 0;
  virtual ParamIteratorInterface<T>* End() const = 0;
};






template<typename T>
class ParamGenerator {
 public:
  typedef ParamIterator<T> iterator;

  explicit ParamGenerator(ParamGeneratorInterface<T>* impl) : impl_(impl) {}
  ParamGenerator(const ParamGenerator& other) : impl_(other.impl_) {}

  ParamGenerator& operator=(const ParamGenerator& other) {
    impl_ = other.impl_;
    return *this;
  }

  iterator begin() const { return iterator(impl_->Begin()); }
  iterator end() const { return iterator(impl_->End()); }

 private:
  linked_ptr<const ParamGeneratorInterface<T> > impl_;
};





template <typename T, typename IncrementT>
class RangeGenerator : public ParamGeneratorInterface<T> {
 public:
  RangeGenerator(T begin, T end, IncrementT step)
      : begin_(begin), end_(end),
        step_(step), end_index_(CalculateEndIndex(begin, end, step)) {}
  virtual ~RangeGenerator() {}

  virtual ParamIteratorInterface<T>* Begin() const {
    return new Iterator(this, begin_, 0, step_);
  }
  virtual ParamIteratorInterface<T>* End() const {
    return new Iterator(this, end_, end_index_, step_);
  }

 private:
  class Iterator : public ParamIteratorInterface<T> {
   public:
    Iterator(const ParamGeneratorInterface<T>* base, T value, int index,
             IncrementT step)
        : base_(base), value_(value), index_(index), step_(step) {}
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {
      return base_;
    }
    virtual void Advance() {
      value_ = static_cast<T>(value_ + step_);
      index_++;
    }
    virtual ParamIteratorInterface<T>* Clone() const {
      return new Iterator(*this);
    }
    virtual const T* Current() const { return &value_; }
    virtual bool Equals(const ParamIteratorInterface<T>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h", 243).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const int other_index =
          CheckedDowncastToActualType<const Iterator>(&other)->index_;
      return index_ == other_index;
    }

   private:
    Iterator(const Iterator& other)
        : ParamIteratorInterface<T>(),
          base_(other.base_), value_(other.value_), index_(other.index_),
          step_(other.step_) {}

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<T>* const base_;
    T value_;
    int index_;
    const IncrementT step_;
  };  

  static int CalculateEndIndex(const T& begin,
                               const T& end,
                               const IncrementT& step) {
    int end_index = 0;
    for (T i = begin; i < end; i = static_cast<T>(i + step))
      end_index++;
    return end_index;
  }

  
  void operator=(const RangeGenerator& other);

  const T begin_;
  const T end_;
  const IncrementT step_;
  
  
  const int end_index_;
};  






template <typename T>
class ValuesInIteratorRangeGenerator : public ParamGeneratorInterface<T> {
 public:
  template <typename ForwardIterator>
  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)
      : container_(begin, end) {}
  virtual ~ValuesInIteratorRangeGenerator() {}

  virtual ParamIteratorInterface<T>* Begin() const {
    return new Iterator(this, container_.begin());
  }
  virtual ParamIteratorInterface<T>* End() const {
    return new Iterator(this, container_.end());
  }

 private:
  typedef typename ::std::vector<T> ContainerType;

  class Iterator : public ParamIteratorInterface<T> {
   public:
    Iterator(const ParamGeneratorInterface<T>* base,
             typename ContainerType::const_iterator iterator)
        : base_(base), iterator_(iterator) {}
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {
      return base_;
    }
    virtual void Advance() {
      ++iterator_;
      value_.reset();
    }
    virtual ParamIteratorInterface<T>* Clone() const {
      return new Iterator(*this);
    }
    
    
    
    
    
    
    
    virtual const T* Current() const {
      if (value_.get() == 0)
        value_.reset(new T(*iterator_));
      return value_.get();
    }
    virtual bool Equals(const ParamIteratorInterface<T>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h", 341).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      return iterator_ ==
          CheckedDowncastToActualType<const Iterator>(&other)->iterator_;
    }

   private:
    Iterator(const Iterator& other)
          
          
        : ParamIteratorInterface<T>(),
          base_(other.base_),
          iterator_(other.iterator_) {}

    const ParamGeneratorInterface<T>* const base_;
    typename ContainerType::const_iterator iterator_;
    
    
    
    
    
    mutable scoped_ptr<const T> value_;
  };  

  
  void operator=(const ValuesInIteratorRangeGenerator& other);

  const ContainerType container_;
};  





template <class ParamType>
std::string DefaultParamName(const TestParamInfo<ParamType>& info) {
  Message name_stream;
  name_stream << info.index;
  return name_stream.GetString();
}






template <class ParamType, class ParamNameGenFunctor>
ParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) {
  return func;
}

template <class ParamType>
struct ParamNameGenFunc {
  typedef std::string Type(const TestParamInfo<ParamType>&);
};

template <class ParamType>
typename ParamNameGenFunc<ParamType>::Type *GetParamNameGen() {
  return DefaultParamName;
}





template <class TestClass>
class ParameterizedTestFactory : public TestFactoryBase {
 public:
  typedef typename TestClass::ParamType ParamType;
  explicit ParameterizedTestFactory(ParamType parameter) :
      parameter_(parameter) {}
  virtual Test* CreateTest() {
    TestClass::SetParam(&parameter_);
    return new TestClass();
  }

 private:
  const ParamType parameter_;

  ParameterizedTestFactory(ParameterizedTestFactory const &); void operator=(ParameterizedTestFactory const &);
};





template <class ParamType>
class TestMetaFactoryBase {
 public:
  virtual ~TestMetaFactoryBase() {}

  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;
};









template <class TestCase>
class TestMetaFactory
    : public TestMetaFactoryBase<typename TestCase::ParamType> {
 public:
  typedef typename TestCase::ParamType ParamType;

  TestMetaFactory() {}

  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) {
    return new ParameterizedTestFactory<TestCase>(parameter);
  }

 private:
  TestMetaFactory(TestMetaFactory const &); void operator=(TestMetaFactory const &);
};











class ParameterizedTestCaseInfoBase {
 public:
  virtual ~ParameterizedTestCaseInfoBase() {}

  
  virtual const string& GetTestCaseName() const = 0;
  
  virtual TypeId GetTestCaseTypeId() const = 0;
  
  
  
  
  virtual void RegisterTests() = 0;

 protected:
  ParameterizedTestCaseInfoBase() {}

 private:
  ParameterizedTestCaseInfoBase(ParameterizedTestCaseInfoBase const &); void operator=(ParameterizedTestCaseInfoBase const &);
};








template <class TestCase>
class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {
 public:
  
  
  
  typedef typename TestCase::ParamType ParamType;
  
  typedef ParamGenerator<ParamType>(GeneratorCreationFunc)();
  typedef typename ParamNameGenFunc<ParamType>::Type ParamNameGeneratorFunc;

  explicit ParameterizedTestCaseInfo(
      const char* name, CodeLocation code_location)
      : test_case_name_(name), code_location_(code_location) {}

  
  virtual const string& GetTestCaseName() const { return test_case_name_; }
  
  virtual TypeId GetTestCaseTypeId() const { return GetTypeId<TestCase>(); }
  
  
  
  
  
  
  void AddTestPattern(const char* test_case_name,
                      const char* test_base_name,
                      TestMetaFactoryBase<ParamType>* meta_factory) {
    tests_.push_back(linked_ptr<TestInfo>(new TestInfo(test_case_name,
                                                       test_base_name,
                                                       meta_factory)));
  }
  
  
  int AddTestCaseInstantiation(const string& instantiation_name,
                               GeneratorCreationFunc* func,
                               ParamNameGeneratorFunc* name_func,
                               const char* file,
                               int line) {
    instantiations_.push_back(
        InstantiationInfo(instantiation_name, func, name_func, file, line));
    return 0;  
  }
  
  
  
  
  
  virtual void RegisterTests() {
    for (typename TestInfoContainer::iterator test_it = tests_.begin();
         test_it != tests_.end(); ++test_it) {
      linked_ptr<TestInfo> test_info = *test_it;
      for (typename InstantiationContainer::iterator gen_it =
               instantiations_.begin(); gen_it != instantiations_.end();
               ++gen_it) {
        const string& instantiation_name = gen_it->name;
        ParamGenerator<ParamType> generator((*gen_it->generator)());
        ParamNameGeneratorFunc* name_func = gen_it->name_func;
        const char* file = gen_it->file;
        int line = gen_it->line;

        string test_case_name;
        if ( !instantiation_name.empty() )
          test_case_name = instantiation_name + "/";
        test_case_name += test_info->test_case_base_name;

        size_t i = 0;
        std::set<std::string> test_param_names;
        for (typename ParamGenerator<ParamType>::iterator param_it =
                 generator.begin();
             param_it != generator.end(); ++param_it, ++i) {
          Message test_name_stream;

          std::string param_name = name_func(
              TestParamInfo<ParamType>(*param_it, i));

          switch (0) case 0: default: if (::testing::internal::IsTrue(IsValidParamName(param_name))) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h", 574).GetStream() << "Condition " "IsValidParamName(param_name)" " failed. "
              << "Parameterized test name '" << param_name
              << "' is invalid, in " << file
              << " line " << line << std::endl;

          switch (0) case 0: default: if (::testing::internal::IsTrue(test_param_names.count(param_name) == 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h", 579).GetStream() << "Condition " "test_param_names.count(param_name) == 0" " failed. "
              << "Duplicate parameterized test name '" << param_name
              << "', in " << file << " line " << line << std::endl;

          test_param_names.insert(param_name);

          test_name_stream << test_info->test_base_name << "/" << param_name;
          MakeAndRegisterTestInfo(
              test_case_name.c_str(),
              test_name_stream.GetString().c_str(),
              0,  
              PrintToString(*param_it).c_str(),
              code_location_,
              GetTestCaseTypeId(),
              TestCase::SetUpTestCase,
              TestCase::TearDownTestCase,
              test_info->test_meta_factory->CreateTestFactory(*param_it));
        }  
      }  
    }  
  }  

 private:
  
  
  struct TestInfo {
    TestInfo(const char* a_test_case_base_name,
             const char* a_test_base_name,
             TestMetaFactoryBase<ParamType>* a_test_meta_factory) :
        test_case_base_name(a_test_case_base_name),
        test_base_name(a_test_base_name),
        test_meta_factory(a_test_meta_factory) {}

    const string test_case_base_name;
    const string test_base_name;
    const scoped_ptr<TestMetaFactoryBase<ParamType> > test_meta_factory;
  };
  typedef ::std::vector<linked_ptr<TestInfo> > TestInfoContainer;
  
  
  
  struct InstantiationInfo {
      InstantiationInfo(const std::string &name_in,
                        GeneratorCreationFunc* generator_in,
                        ParamNameGeneratorFunc* name_func_in,
                        const char* file_in,
                        int line_in)
          : name(name_in),
            generator(generator_in),
            name_func(name_func_in),
            file(file_in),
            line(line_in) {}

      std::string name;
      GeneratorCreationFunc* generator;
      ParamNameGeneratorFunc* name_func;
      const char* file;
      int line;
  };
  typedef ::std::vector<InstantiationInfo> InstantiationContainer;

  static bool IsValidParamName(const std::string& name) {
    
    if (name.empty())
      return false;

    
    for (std::string::size_type index = 0; index < name.size(); ++index) {
      if (!isalnum(name[index]) && name[index] != '_')
        return false;
    }

    return true;
  }

  const string test_case_name_;
  CodeLocation code_location_;
  TestInfoContainer tests_;
  InstantiationContainer instantiations_;

  ParameterizedTestCaseInfo(ParameterizedTestCaseInfo const &); void operator=(ParameterizedTestCaseInfo const &);
};  







class ParameterizedTestCaseRegistry {
 public:
  ParameterizedTestCaseRegistry() {}
  ~ParameterizedTestCaseRegistry() {
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      delete *it;
    }
  }

  
  
  template <class TestCase>
  ParameterizedTestCaseInfo<TestCase>* GetTestCasePatternHolder(
      const char* test_case_name,
      CodeLocation code_location) {
    ParameterizedTestCaseInfo<TestCase>* typed_test_info = 0;
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      if ((*it)->GetTestCaseName() == test_case_name) {
        if ((*it)->GetTestCaseTypeId() != GetTypeId<TestCase>()) {
          
          
          
          ReportInvalidTestCaseType(test_case_name, code_location);
          posix::Abort();
        } else {
          
          
          
          typed_test_info = CheckedDowncastToActualType<
              ParameterizedTestCaseInfo<TestCase> >(*it);
        }
        break;
      }
    }
    if (typed_test_info == 0) {
      typed_test_info = new ParameterizedTestCaseInfo<TestCase>(
          test_case_name, code_location);
      test_case_infos_.push_back(typed_test_info);
    }
    return typed_test_info;
  }
  void RegisterTests() {
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      (*it)->RegisterTests();
    }
  }

 private:
  typedef ::std::vector<ParameterizedTestCaseInfoBase*> TestCaseInfoContainer;

  TestCaseInfoContainer test_case_infos_;

  ParameterizedTestCaseRegistry(ParameterizedTestCaseRegistry const &); void operator=(ParameterizedTestCaseRegistry const &);
};

}  
}  

#line 730 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"

#line 732 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util.h"
#line 193 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h"
























































namespace testing {



template <typename ForwardIterator>
internal::ParamGenerator<
  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
ValuesIn(ForwardIterator begin, ForwardIterator end);

template <typename T, size_t N>
internal::ParamGenerator<T> ValuesIn(const T (&array)[N]);

template <class Container>
internal::ParamGenerator<typename Container::value_type> ValuesIn(
    const Container& container);

namespace internal {


template <typename T1>
class ValueArray1 {
 public:
  explicit ValueArray1(T1 v1) : v1_(v1) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray1& other);

  const T1 v1_;
};

template <typename T1, typename T2>
class ValueArray2 {
 public:
  ValueArray2(T1 v1, T2 v2) : v1_(v1), v2_(v2) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray2& other);

  const T1 v1_;
  const T2 v2_;
};

template <typename T1, typename T2, typename T3>
class ValueArray3 {
 public:
  ValueArray3(T1 v1, T2 v2, T3 v3) : v1_(v1), v2_(v2), v3_(v3) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray3& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
};

template <typename T1, typename T2, typename T3, typename T4>
class ValueArray4 {
 public:
  ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray4& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5>
class ValueArray5 {
 public:
  ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray5& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
class ValueArray6 {
 public:
  ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray6& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
class ValueArray7 {
 public:
  ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray7& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
class ValueArray8 {
 public:
  ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
      T8 v8) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray8& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
class ValueArray9 {
 public:
  ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
      T9 v9) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray9& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
class ValueArray10 {
 public:
  ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray10& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
class ValueArray11 {
 public:
  ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray11& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
class ValueArray12 {
 public:
  ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray12& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
class ValueArray13 {
 public:
  ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray13& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
class ValueArray14 {
 public:
  ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray14& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
class ValueArray15 {
 public:
  ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray15& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
class ValueArray16 {
 public:
  ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray16& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
class ValueArray17 {
 public:
  ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
      T17 v17) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray17& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
class ValueArray18 {
 public:
  ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray18& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
class ValueArray19 {
 public:
  ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray19& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
class ValueArray20 {
 public:
  ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray20& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
class ValueArray21 {
 public:
  ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray21& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
class ValueArray22 {
 public:
  ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray22& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
class ValueArray23 {
 public:
  ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray23& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
class ValueArray24 {
 public:
  ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray24& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
class ValueArray25 {
 public:
  ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
      T25 v25) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray25& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
class ValueArray26 {
 public:
  ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray26& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
class ValueArray27 {
 public:
  ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray27& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
class ValueArray28 {
 public:
  ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray28& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
class ValueArray29 {
 public:
  ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray29& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
class ValueArray30 {
 public:
  ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray30& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
class ValueArray31 {
 public:
  ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray31& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
class ValueArray32 {
 public:
  ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray32& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
class ValueArray33 {
 public:
  ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,
      T33 v33) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray33& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
class ValueArray34 {
 public:
  ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray34& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
class ValueArray35 {
 public:
  ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),
      v32_(v32), v33_(v33), v34_(v34), v35_(v35) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray35& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
class ValueArray36 {
 public:
  ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),
      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray36& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
class ValueArray37 {
 public:
  ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),
      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),
      v36_(v36), v37_(v37) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray37& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
class ValueArray38 {
 public:
  ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray38& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
class ValueArray39 {
 public:
  ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray39& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
class ValueArray40 {
 public:
  ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),
      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),
      v40_(v40) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray40& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
class ValueArray41 {
 public:
  ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,
      T41 v41) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray41& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
class ValueArray42 {
 public:
  ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray42& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
class ValueArray43 {
 public:
  ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),
      v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37),
      v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray43& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
class ValueArray44 {
 public:
  ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),
      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36),
      v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42),
      v43_(v43), v44_(v44) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray44& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
class ValueArray45 {
 public:
  ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),
      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),
      v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41),
      v42_(v42), v43_(v43), v44_(v44), v45_(v45) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray45& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
class ValueArray46 {
 public:
  ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),
      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray46& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
class ValueArray47 {
 public:
  ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),
      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46),
      v47_(v47) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray47& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
class ValueArray48 {
 public:
  ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),
      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),
      v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45),
      v46_(v46), v47_(v47), v48_(v48) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray48& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
class ValueArray49 {
 public:
  ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48,
      T49 v49) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),
      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_), static_cast<T>(v49_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray49& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
  const T49 v49_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
class ValueArray50 {
 public:
  ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49,
      T50 v50) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),
      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49), v50_(v50) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_), static_cast<T>(v49_), static_cast<T>(v50_)};
    return ValuesIn(array);
  }

 private:
  
  void operator=(const ValueArray50& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
  const T49 v49_;
  const T50 v50_;
};







template <typename T1, typename T2>
class CartesianProductGenerator2
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2> > {
 public:
  typedef ::testing::tuple<T1, T2> ParamType;

  CartesianProductGenerator2(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2)
      : g1_(g1), g2_(g2) {}
  virtual ~CartesianProductGenerator2() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3200)), 0) );
      ++current2_;
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 3215).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator2& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
};  


template <typename T1, typename T2, typename T3>
class CartesianProductGenerator3
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3> > {
 public:
  typedef ::testing::tuple<T1, T2, T3> ParamType;

  CartesianProductGenerator3(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3)
      : g1_(g1), g2_(g2), g3_(g3) {}
  virtual ~CartesianProductGenerator3() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3319)), 0) );
      ++current3_;
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 3338).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator3& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
};  


template <typename T1, typename T2, typename T3, typename T4>
class CartesianProductGenerator4
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4> ParamType;

  CartesianProductGenerator4(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}
  virtual ~CartesianProductGenerator4() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3456)), 0) );
      ++current4_;
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 3479).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator4& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5>
class CartesianProductGenerator5
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5> ParamType;

  CartesianProductGenerator5(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}
  virtual ~CartesianProductGenerator5() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3610)), 0) );
      ++current5_;
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 3637).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator5& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
class CartesianProductGenerator6
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5,
        T6> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6> ParamType;

  CartesianProductGenerator6(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}
  virtual ~CartesianProductGenerator6() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3783)), 0) );
      ++current6_;
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 3814).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator6& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
class CartesianProductGenerator7
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> ParamType;

  CartesianProductGenerator7(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}
  virtual ~CartesianProductGenerator7() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(3973)), 0) );
      ++current7_;
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 4008).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator7& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
class CartesianProductGenerator8
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> ParamType;

  CartesianProductGenerator8(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),
          g8_(g8) {}
  virtual ~CartesianProductGenerator8() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(4182)), 0) );
      ++current8_;
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 4221).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator8& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
class CartesianProductGenerator9
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8, T9> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> ParamType;

  CartesianProductGenerator9(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9) {}
  virtual ~CartesianProductGenerator9() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end(), g9_, g9_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8,
      const ParamGenerator<T9>& g9,
      const typename ParamGenerator<T9>::iterator& current9)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),
          begin9_(g9.begin()), end9_(g9.end()), current9_(current9)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(4407)), 0) );
      ++current9_;
      if (current9_ == end9_) {
        current9_ = begin9_;
        ++current8_;
      }
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 4450).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_ &&
          current9_ == typed_other->current9_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_),
        begin9_(other.begin9_),
        end9_(other.end9_),
        current9_(other.current9_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_,
            *current9_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_ ||
          current9_ == end9_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    const typename ParamGenerator<T9>::iterator begin9_;
    const typename ParamGenerator<T9>::iterator end9_;
    typename ParamGenerator<T9>::iterator current9_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator9& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
  const ParamGenerator<T9> g9_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
class CartesianProductGenerator10
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8, T9, T10> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ParamType;

  CartesianProductGenerator10(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9,
      const ParamGenerator<T10>& g10)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9), g10_(g10) {}
  virtual ~CartesianProductGenerator10() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin(), g10_, g10_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end(), g9_, g9_.end(), g10_, g10_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8,
      const ParamGenerator<T9>& g9,
      const typename ParamGenerator<T9>::iterator& current9,
      const ParamGenerator<T10>& g10,
      const typename ParamGenerator<T10>::iterator& current10)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),
          begin9_(g9.begin()), end9_(g9.end()), current9_(current9),
          begin10_(g10.begin()), end10_(g10.end()), current10_(current10)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      (void)( (!!(!AtEnd())) || (_wassert(L"!AtEnd()", L"d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", (unsigned)(4650)), 0) );
      ++current10_;
      if (current10_ == end10_) {
        current10_ = begin10_;
        ++current9_;
      }
      if (current9_ == end9_) {
        current9_ = begin9_;
        ++current8_;
      }
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return &current_value_; }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h", 4697).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_ &&
          current9_ == typed_other->current9_ &&
          current10_ == typed_other->current10_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_),
        begin9_(other.begin9_),
        end9_(other.end9_),
        current9_(other.current9_),
        begin10_(other.begin10_),
        end10_(other.end10_),
        current10_(other.current10_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_ = ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_,
            *current9_, *current10_);
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_ ||
          current9_ == end9_ ||
          current10_ == end10_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    const typename ParamGenerator<T9>::iterator begin9_;
    const typename ParamGenerator<T9>::iterator end9_;
    typename ParamGenerator<T9>::iterator current9_;
    const typename ParamGenerator<T10>::iterator begin10_;
    const typename ParamGenerator<T10>::iterator end10_;
    typename ParamGenerator<T10>::iterator current10_;
    ParamType current_value_;
  };  

  
  void operator=(const CartesianProductGenerator10& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
  const ParamGenerator<T9> g9_;
  const ParamGenerator<T10> g10_;
};  








template <class Generator1, class Generator2>
class CartesianProductHolder2 {
 public:
CartesianProductHolder2(const Generator1& g1, const Generator2& g2)
      : g1_(g1), g2_(g2) {}
  template <typename T1, typename T2>
  operator ParamGenerator< ::testing::tuple<T1, T2> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2> >(
        new CartesianProductGenerator2<T1, T2>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_)));
  }

 private:
  
  void operator=(const CartesianProductHolder2& other);

  const Generator1 g1_;
  const Generator2 g2_;
};  

template <class Generator1, class Generator2, class Generator3>
class CartesianProductHolder3 {
 public:
CartesianProductHolder3(const Generator1& g1, const Generator2& g2,
    const Generator3& g3)
      : g1_(g1), g2_(g2), g3_(g3) {}
  template <typename T1, typename T2, typename T3>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3> >(
        new CartesianProductGenerator3<T1, T2, T3>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_)));
  }

 private:
  
  void operator=(const CartesianProductHolder3& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4>
class CartesianProductHolder4 {
 public:
CartesianProductHolder4(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}
  template <typename T1, typename T2, typename T3, typename T4>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >(
        new CartesianProductGenerator4<T1, T2, T3, T4>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_)));
  }

 private:
  
  void operator=(const CartesianProductHolder4& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5>
class CartesianProductHolder5 {
 public:
CartesianProductHolder5(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >(
        new CartesianProductGenerator5<T1, T2, T3, T4, T5>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_)));
  }

 private:
  
  void operator=(const CartesianProductHolder5& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6>
class CartesianProductHolder6 {
 public:
CartesianProductHolder6(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >(
        new CartesianProductGenerator6<T1, T2, T3, T4, T5, T6>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_)));
  }

 private:
  
  void operator=(const CartesianProductHolder6& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7>
class CartesianProductHolder7 {
 public:
CartesianProductHolder7(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6,
      T7> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> >(
        new CartesianProductGenerator7<T1, T2, T3, T4, T5, T6, T7>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_)));
  }

 private:
  
  void operator=(const CartesianProductHolder7& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8>
class CartesianProductHolder8 {
 public:
CartesianProductHolder8(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),
          g8_(g8) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7,
      T8> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> >(
        new CartesianProductGenerator8<T1, T2, T3, T4, T5, T6, T7, T8>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_)));
  }

 private:
  
  void operator=(const CartesianProductHolder8& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8, class Generator9>
class CartesianProductHolder9 {
 public:
CartesianProductHolder9(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8,
    const Generator9& g9)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8, typename T9>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,
      T9> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,
        T9> >(
        new CartesianProductGenerator9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_),
        static_cast<ParamGenerator<T9> >(g9_)));
  }

 private:
  
  void operator=(const CartesianProductHolder9& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
  const Generator9 g9_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8, class Generator9, class Generator10>
class CartesianProductHolder10 {
 public:
CartesianProductHolder10(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8,
    const Generator9& g9, const Generator10& g10)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9), g10_(g10) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8, typename T9, typename T10>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,
      T10> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,
        T10> >(
        new CartesianProductGenerator10<T1, T2, T3, T4, T5, T6, T7, T8, T9,
            T10>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_),
        static_cast<ParamGenerator<T9> >(g9_),
        static_cast<ParamGenerator<T10> >(g10_)));
  }

 private:
  
  void operator=(const CartesianProductHolder10& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
  const Generator9 g9_;
  const Generator10 g10_;
};  

#line 5140 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h"

}  
}  

#line 5145 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h"

#line 5147 "d:\\c++code\\googletest\\googletest\\include\\gtest\\internal\\gtest-param-util-generated.h"

#line 194 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"



namespace testing {











































template <typename T, typename IncrementT>
internal::ParamGenerator<T> Range(T start, T end, IncrementT step) {
  return internal::ParamGenerator<T>(
      new internal::RangeGenerator<T, IncrementT>(start, end, step));
}

template <typename T>
internal::ParamGenerator<T> Range(T start, T end) {
  return Range(start, end, 1);
}
























































template <typename ForwardIterator>
internal::ParamGenerator<
  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
ValuesIn(ForwardIterator begin, ForwardIterator end) {
  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>
      ::value_type ParamType;
  return internal::ParamGenerator<ParamType>(
      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));
}

template <typename T, size_t N>
internal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {
  return ValuesIn(array, array + N);
}

template <class Container>
internal::ParamGenerator<typename Container::value_type> ValuesIn(
    const Container& container) {
  return ValuesIn(container.begin(), container.end());
}




















template <typename T1>
internal::ValueArray1<T1> Values(T1 v1) {
  return internal::ValueArray1<T1>(v1);
}

template <typename T1, typename T2>
internal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {
  return internal::ValueArray2<T1, T2>(v1, v2);
}

template <typename T1, typename T2, typename T3>
internal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {
  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);
}

template <typename T1, typename T2, typename T3, typename T4>
internal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {
  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5>
internal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5) {
  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
internal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6) {
  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7) {
  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,
      v6, v7);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {
  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,
      v5, v6, v7, v8);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {
  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {
  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11) {
  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12) {
  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13) {
  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {
  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {
  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16) {
  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17) {
  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18) {
  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {
  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {
  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {
  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22) {
  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23) {
  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24) {
  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,
      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
      v19, v20, v21, v22, v23, v24);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,
    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,
    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {
  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,
      v18, v19, v20, v21, v22, v23, v24, v25);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26) {
  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27) {
  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28) {
  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,
      v28);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29) {
  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27, v28, v29);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {
  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,
      v26, v27, v28, v29, v30);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {
  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,
      v25, v26, v27, v28, v29, v30, v31);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32) {
  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33) {
  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,
    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,
    T31 v31, T32 v32, T33 v33, T34 v34) {
  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,
      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {
  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {
  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37) {
  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36, v37);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37, T38 v38) {
  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,
      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,
      v33, v34, v35, v36, v37, v38);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37, T38 v38, T39 v39) {
  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,
      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,
      v32, v33, v34, v35, v36, v37, v38, v39);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,
    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,
    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,
    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,
    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {
  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,
      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {
  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,
      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42) {
  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,
      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,
      v42);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42, T43 v43) {
  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,
      v41, v42, v43);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42, T43 v43, T44 v44) {
  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,
      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,
      v40, v41, v42, v43, v44);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,
    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,
    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {
  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,
      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,
      v39, v40, v41, v42, v43, v44, v45);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {
  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,
      v38, v39, v40, v41, v42, v43, v44, v45, v46);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {
  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,
      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,
    T48 v48) {
  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,
      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,
      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,
    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,
    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,
    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,
    T47 v47, T48 v48, T49 v49) {
  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,
      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,
    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,
    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {
  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,
      v48, v49, v50);
}





















inline internal::ParamGenerator<bool> Bool() {
  return Values(false, true);
}


















































template <typename Generator1, typename Generator2>
internal::CartesianProductHolder2<Generator1, Generator2> Combine(
    const Generator1& g1, const Generator2& g2) {
  return internal::CartesianProductHolder2<Generator1, Generator2>(
      g1, g2);
}

template <typename Generator1, typename Generator2, typename Generator3>
internal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3) {
  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(
      g1, g2, g3);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4>
internal::CartesianProductHolder4<Generator1, Generator2, Generator3,
    Generator4> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4) {
  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,
      Generator4>(
      g1, g2, g3, g4);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5>
internal::CartesianProductHolder5<Generator1, Generator2, Generator3,
    Generator4, Generator5> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5) {
  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,
      Generator4, Generator5>(
      g1, g2, g3, g4, g5);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6>
internal::CartesianProductHolder6<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6) {
  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6>(
      g1, g2, g3, g4, g5, g6);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7>
internal::CartesianProductHolder7<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7) {
  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7>(
      g1, g2, g3, g4, g5, g6, g7);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8>
internal::CartesianProductHolder8<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8) {
  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8>(
      g1, g2, g3, g4, g5, g6, g7, g8);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8, typename Generator9>
internal::CartesianProductHolder9<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8,
    Generator9> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8, const Generator9& g9) {
  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(
      g1, g2, g3, g4, g5, g6, g7, g8, g9);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8, typename Generator9,
    typename Generator10>
internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,
    Generator10> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8, const Generator9& g9,
        const Generator10& g10) {
  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,
      Generator10>(
      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);
}
#line 1377 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"































































}  

#line 1443 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"

#line 1445 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-param-test.h"

#line 63 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest_prod.h"

























































#line 59 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest_prod.h"
#line 65 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-test-part.h"








































namespace testing {





class  TestPartResult {
 public:
  
  
  enum Type {
    kSuccess,          
    kNonFatalFailure,  
    kFatalFailure      
  };

  
  
  
  TestPartResult(Type a_type,
                 const char* a_file_name,
                 int a_line_number,
                 const char* a_message)
      : type_(a_type),
        file_name_(a_file_name == 0 ? "" : a_file_name),
        line_number_(a_line_number),
        summary_(ExtractSummary(a_message)),
        message_(a_message) {
  }

  
  Type type() const { return type_; }

  
  
  const char* file_name() const {
    return file_name_.empty() ? 0 : file_name_.c_str();
  }

  
  
  int line_number() const { return line_number_; }

  
  const char* summary() const { return summary_.c_str(); }

  
  const char* message() const { return message_.c_str(); }

  
  bool passed() const { return type_ == kSuccess; }

  
  bool failed() const { return type_ != kSuccess; }

  
  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }

  
  bool fatally_failed() const { return type_ == kFatalFailure; }

 private:
  Type type_;

  
  
  static std::string ExtractSummary(const char* message);

  
  
  std::string file_name_;
  
  
  int line_number_;
  std::string summary_;  
  std::string message_;  
};


std::ostream& operator<<(std::ostream& os, const TestPartResult& result);





class  TestPartResultArray {
 public:
  TestPartResultArray() {}

  
  void Append(const TestPartResult& result);

  
  const TestPartResult& GetTestPartResult(int index) const;

  
  int size() const;

 private:
  std::vector<TestPartResult> array_;

  TestPartResultArray(TestPartResultArray const &); void operator=(TestPartResultArray const &);
};


class TestPartResultReporterInterface {
 public:
  virtual ~TestPartResultReporterInterface() {}

  virtual void ReportTestPartResult(const TestPartResult& result) = 0;
};

namespace internal {







class  HasNewFatalFailureHelper
    : public TestPartResultReporterInterface {
 public:
  HasNewFatalFailureHelper();
  virtual ~HasNewFatalFailureHelper();
  virtual void ReportTestPartResult(const TestPartResult& result);
  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }
 private:
  bool has_new_fatal_failure_;
  TestPartResultReporterInterface* original_reporter_;

  HasNewFatalFailureHelper(HasNewFatalFailureHelper const &); void operator=(HasNewFatalFailureHelper const &);
};

}  

}  

#line 180 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-test-part.h"
#line 66 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"




















































































#line 86 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"





























































#line 148 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"









































#line 190 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"







































































#line 262 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"

#line 264 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest-typed-test.h"
#line 67 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
















namespace testing {




 extern bool FLAGS_gtest_also_run_disabled_tests;


 extern bool FLAGS_gtest_break_on_failure;



 extern bool FLAGS_gtest_catch_exceptions;




 extern ::std::string FLAGS_gtest_color;



 extern ::std::string FLAGS_gtest_filter;



 extern bool FLAGS_gtest_list_tests;



 extern ::std::string FLAGS_gtest_output;



 extern bool FLAGS_gtest_print_time;


 extern ::testing::internal::Int32 FLAGS_gtest_random_seed;



 extern ::testing::internal::Int32 FLAGS_gtest_repeat;



 extern bool FLAGS_gtest_show_internal_stack_frames;


 extern bool FLAGS_gtest_shuffle;



 extern ::testing::internal::Int32 FLAGS_gtest_stack_trace_depth;




 extern bool FLAGS_gtest_throw_on_failure;




 extern ::std::string FLAGS_gtest_stream_result_to;


const int kMaxStackTraceDepth = 100;

namespace internal {

class AssertHelper;
class DefaultGlobalTestPartResultReporter;
class ExecDeathTest;
class NoExecDeathTest;
class FinalSuccessChecker;
class GTestFlagSaver;
class StreamingListenerTest;
class TestResultAccessor;
class TestEventListenersAccessor;
class TestEventRepeater;
class UnitTestRecordPropertyTestHelper;
class WindowsDeathTest;
class UnitTestImpl* GetUnitTestImpl();
void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
                                    const std::string& message);

}  




class Test;
class TestCase;
class TestInfo;
class UnitTest;
















































































class  AssertionResult {
 public:
  
  
  AssertionResult(const AssertionResult& other);

  __pragma(warning(push)) __pragma(warning(disable: 4800))

  
  
  
  
  
  
  
  template <typename T>
  explicit AssertionResult(
      const T& success,
      typename internal::EnableIf<
          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*
           = 0)
      : success_(success) {}

  __pragma(warning(pop))

  
  AssertionResult& operator=(AssertionResult other) {
    swap(other);
    return *this;
  }

  
  operator bool() const { return success_; }  

  
  AssertionResult operator!() const;

  
  
  
  
  const char* message() const {
    return message_.get() != 0 ?  message_->c_str() : "";
  }
  
  
  const char* failure_message() const { return message(); }

  
  template <typename T> AssertionResult& operator<<(const T& value) {
    AppendMessage(Message() << value);
    return *this;
  }

  
  
  AssertionResult& operator<<(
      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {
    AppendMessage(Message() << basic_manipulator);
    return *this;
  }

 private:
  
  void AppendMessage(const Message& a_message) {
    if (message_.get() == 0)
      message_.reset(new ::std::string);
    message_->append(a_message.GetString().c_str());
  }

  
  void swap(AssertionResult& other);

  
  bool success_;
  
  
  
  
  internal::scoped_ptr< ::std::string> message_;
};


 AssertionResult AssertionSuccess();


 AssertionResult AssertionFailure();



 AssertionResult AssertionFailure(const Message& msg);
























class  Test {
 public:
  friend class TestInfo;

  
  
  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;
  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;

  
  virtual ~Test();

  
  
  
  
  
  
  static void SetUpTestCase() {}

  
  
  
  
  
  
  static void TearDownTestCase() {}

  
  static bool HasFatalFailure();

  
  static bool HasNonfatalFailure();

  
  
  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }

  
  
  
  
  
  
  
  
  
  
  
  
  
  static void RecordProperty(const std::string& key, const std::string& value);
  static void RecordProperty(const std::string& key, int value);

 protected:
  
  Test();

  
  virtual void SetUp();

  
  virtual void TearDown();

 private:
  
  
  static bool HasSameFixtureClass();

  
  
  
  
  
  
  virtual void TestBody() = 0;

  
  void Run();

  
  
  void DeleteSelf_() { delete this; }

  const internal::scoped_ptr< ::testing::internal::GTestFlagSaver > gtest_flag_saver_;

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  struct Setup_should_be_spelled_SetUp {};
  virtual Setup_should_be_spelled_SetUp* Setup() { return 0; }

  
  Test(Test const &); void operator=(Test const &);
};

typedef internal::TimeInMillis TimeInMillis;





class TestProperty {
 public:
  
  
  
  TestProperty(const std::string& a_key, const std::string& a_value) :
    key_(a_key), value_(a_value) {
  }

  
  const char* key() const {
    return key_.c_str();
  }

  
  const char* value() const {
    return value_.c_str();
  }

  
  void SetValue(const std::string& new_value) {
    value_ = new_value;
  }

 private:
  
  std::string key_;
  
  std::string value_;
};







class  TestResult {
 public:
  
  TestResult();

  
  ~TestResult();

  
  
  int total_part_count() const;

  
  int test_property_count() const;

  
  bool Passed() const { return !Failed(); }

  
  bool Failed() const;

  
  bool HasFatalFailure() const;

  
  bool HasNonfatalFailure() const;

  
  TimeInMillis elapsed_time() const { return elapsed_time_; }

  
  
  
  const TestPartResult& GetTestPartResult(int i) const;

  
  
  
  const TestProperty& GetTestProperty(int i) const;

 private:
  friend class TestInfo;
  friend class TestCase;
  friend class UnitTest;
  friend class internal::DefaultGlobalTestPartResultReporter;
  friend class internal::ExecDeathTest;
  friend class internal::TestResultAccessor;
  friend class internal::UnitTestImpl;
  friend class internal::WindowsDeathTest;

  
  const std::vector<TestPartResult>& test_part_results() const {
    return test_part_results_;
  }

  
  const std::vector<TestProperty>& test_properties() const {
    return test_properties_;
  }

  
  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }

  
  
  
  
  
  
  void RecordProperty(const std::string& xml_element,
                      const TestProperty& test_property);

  
  
  
  static bool ValidateTestProperty(const std::string& xml_element,
                                   const TestProperty& test_property);

  
  void AddTestPartResult(const TestPartResult& test_part_result);

  
  int death_test_count() const { return death_test_count_; }

  
  int increment_death_test_count() { return ++death_test_count_; }

  
  void ClearTestPartResults();

  
  void Clear();

  
  
  internal::Mutex test_properites_mutex_;

  
  std::vector<TestPartResult> test_part_results_;
  
  std::vector<TestProperty> test_properties_;
  
  int death_test_count_;
  
  TimeInMillis elapsed_time_;

  
  TestResult(TestResult const &); void operator=(TestResult const &);
};  












class  TestInfo {
 public:
  
  
  ~TestInfo();

  
  const char* test_case_name() const { return test_case_name_.c_str(); }

  
  const char* name() const { return name_.c_str(); }

  
  
  const char* type_param() const {
    if (type_param_.get() != 0)
      return type_param_->c_str();
    return 0;
  }

  
  
  const char* value_param() const {
    if (value_param_.get() != 0)
      return value_param_->c_str();
    return 0;
  }

  
  const char* file() const { return location_.file.c_str(); }

  
  int line() const { return location_.line; }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  bool should_run() const { return should_run_; }

  
  bool is_reportable() const {
    
    
    
    return matches_filter_;
  }

  
  const TestResult* result() const { return &result_; }

 private:

  friend class internal::DefaultDeathTestFactory;
#line 711 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
  friend class Test;
  friend class TestCase;
  friend class internal::UnitTestImpl;
  friend class internal::StreamingListenerTest;
  friend TestInfo* internal::MakeAndRegisterTestInfo(
      const char* test_case_name,
      const char* name,
      const char* type_param,
      const char* value_param,
      internal::CodeLocation code_location,
      internal::TypeId fixture_class_id,
      Test::SetUpTestCaseFunc set_up_tc,
      Test::TearDownTestCaseFunc tear_down_tc,
      internal::TestFactoryBase* factory);

  
  
  TestInfo(const std::string& test_case_name,
           const std::string& name,
           const char* a_type_param,   
           const char* a_value_param,  
           internal::CodeLocation a_code_location,
           internal::TypeId fixture_class_id,
           internal::TestFactoryBase* factory);

  
  
  int increment_death_test_count() {
    return result_.increment_death_test_count();
  }

  
  
  void Run();

  static void ClearTestResult(TestInfo* test_info) {
    test_info->result_.Clear();
  }

  
  const std::string test_case_name_;     
  const std::string name_;               
  
  
  const internal::scoped_ptr<const ::std::string> type_param_;
  
  
  const internal::scoped_ptr<const ::std::string> value_param_;
  internal::CodeLocation location_;
  const internal::TypeId fixture_class_id_;   
  bool should_run_;                 
  bool is_disabled_;                
  bool matches_filter_;             
                                    
  internal::TestFactoryBase* const factory_;  
                                              

  
  
  TestResult result_;

  TestInfo(TestInfo const &); void operator=(TestInfo const &);
};




class  TestCase {
 public:
  
  
  
  
  
  
  
  
  
  
  
  
  TestCase(const char* name, const char* a_type_param,
           Test::SetUpTestCaseFunc set_up_tc,
           Test::TearDownTestCaseFunc tear_down_tc);

  
  virtual ~TestCase();

  
  const char* name() const { return name_.c_str(); }

  
  
  const char* type_param() const {
    if (type_param_.get() != 0)
      return type_param_->c_str();
    return 0;
  }

  
  bool should_run() const { return should_run_; }

  
  int successful_test_count() const;

  
  int failed_test_count() const;

  
  int reportable_disabled_test_count() const;

  
  int disabled_test_count() const;

  
  int reportable_test_count() const;

  
  int test_to_run_count() const;

  
  int total_test_count() const;

  
  bool Passed() const { return !Failed(); }

  
  bool Failed() const { return failed_test_count() > 0; }

  
  TimeInMillis elapsed_time() const { return elapsed_time_; }

  
  
  const TestInfo* GetTestInfo(int i) const;

  
  
  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }

 private:
  friend class Test;
  friend class internal::UnitTestImpl;

  
  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }

  
  const std::vector<TestInfo*>& test_info_list() const {
    return test_info_list_;
  }

  
  
  TestInfo* GetMutableTestInfo(int i);

  
  void set_should_run(bool should) { should_run_ = should; }

  
  
  void AddTestInfo(TestInfo * test_info);

  
  void ClearResult();

  
  static void ClearTestCaseResult(TestCase* test_case) {
    test_case->ClearResult();
  }

  
  void Run();

  
  
  void RunSetUpTestCase() { (*set_up_tc_)(); }

  
  
  void RunTearDownTestCase() { (*tear_down_tc_)(); }

  
  static bool TestPassed(const TestInfo* test_info) {
    return test_info->should_run() && test_info->result()->Passed();
  }

  
  static bool TestFailed(const TestInfo* test_info) {
    return test_info->should_run() && test_info->result()->Failed();
  }

  
  
  static bool TestReportableDisabled(const TestInfo* test_info) {
    return test_info->is_reportable() && test_info->is_disabled_;
  }

  
  static bool TestDisabled(const TestInfo* test_info) {
    return test_info->is_disabled_;
  }

  
  static bool TestReportable(const TestInfo* test_info) {
    return test_info->is_reportable();
  }

  
  static bool ShouldRunTest(const TestInfo* test_info) {
    return test_info->should_run();
  }

  
  void ShuffleTests(internal::Random* random);

  
  void UnshuffleTests();

  
  std::string name_;
  
  
  const internal::scoped_ptr<const ::std::string> type_param_;
  
  
  std::vector<TestInfo*> test_info_list_;
  
  
  
  std::vector<int> test_indices_;
  
  Test::SetUpTestCaseFunc set_up_tc_;
  
  Test::TearDownTestCaseFunc tear_down_tc_;
  
  bool should_run_;
  
  TimeInMillis elapsed_time_;
  
  
  TestResult ad_hoc_test_result_;

  
  TestCase(TestCase const &); void operator=(TestCase const &);
};















class Environment {
 public:
  
  virtual ~Environment() {}

  
  virtual void SetUp() {}

  
  virtual void TearDown() {}
 private:
  
  
  struct Setup_should_be_spelled_SetUp {};
  virtual Setup_should_be_spelled_SetUp* Setup() { return 0; }
};



class TestEventListener {
 public:
  virtual ~TestEventListener() {}

  
  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;

  
  
  
  virtual void OnTestIterationStart(const UnitTest& unit_test,
                                    int iteration) = 0;

  
  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;

  
  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;

  
  virtual void OnTestCaseStart(const TestCase& test_case) = 0;

  
  virtual void OnTestStart(const TestInfo& test_info) = 0;

  
  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;

  
  virtual void OnTestEnd(const TestInfo& test_info) = 0;

  
  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;

  
  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;

  
  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;

  
  virtual void OnTestIterationEnd(const UnitTest& unit_test,
                                  int iteration) = 0;

  
  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;
};






class EmptyTestEventListener : public TestEventListener {
 public:
  virtual void OnTestProgramStart(const UnitTest& ) {}
  virtual void OnTestIterationStart(const UnitTest& ,
                                    int ) {}
  virtual void OnEnvironmentsSetUpStart(const UnitTest& ) {}
  virtual void OnEnvironmentsSetUpEnd(const UnitTest& ) {}
  virtual void OnTestCaseStart(const TestCase& ) {}
  virtual void OnTestStart(const TestInfo& ) {}
  virtual void OnTestPartResult(const TestPartResult& ) {}
  virtual void OnTestEnd(const TestInfo& ) {}
  virtual void OnTestCaseEnd(const TestCase& ) {}
  virtual void OnEnvironmentsTearDownStart(const UnitTest& ) {}
  virtual void OnEnvironmentsTearDownEnd(const UnitTest& ) {}
  virtual void OnTestIterationEnd(const UnitTest& ,
                                  int ) {}
  virtual void OnTestProgramEnd(const UnitTest& ) {}
};


class  TestEventListeners {
 public:
  TestEventListeners();
  ~TestEventListeners();

  
  
  
  void Append(TestEventListener* listener);

  
  
  
  TestEventListener* Release(TestEventListener* listener);

  
  
  
  
  
  TestEventListener* default_result_printer() const {
    return default_result_printer_;
  }

  
  
  
  
  
  
  
  TestEventListener* default_xml_generator() const {
    return default_xml_generator_;
  }

 private:
  friend class TestCase;
  friend class TestInfo;
  friend class internal::DefaultGlobalTestPartResultReporter;
  friend class internal::NoExecDeathTest;
  friend class internal::TestEventListenersAccessor;
  friend class internal::UnitTestImpl;

  
  
  TestEventListener* repeater();

  
  
  
  
  
  void SetDefaultResultPrinter(TestEventListener* listener);

  
  
  
  
  
  void SetDefaultXmlGenerator(TestEventListener* listener);

  
  
  bool EventForwardingEnabled() const;
  void SuppressEventForwarding();

  
  internal::TestEventRepeater* repeater_;
  
  TestEventListener* default_result_printer_;
  
  TestEventListener* default_xml_generator_;

  
  TestEventListeners(TestEventListeners const &); void operator=(TestEventListeners const &);
};











class  UnitTest {
 public:
  
  
  
  static UnitTest* GetInstance();

  
  
  
  
  
  
  int Run() ;

  
  
  const char* original_working_dir() const;

  
  
  const TestCase* current_test_case() const
      ;

  
  
  const TestInfo* current_test_info() const
      ;

  
  int random_seed() const;


  
  
  
  
  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()
      ;
#line 1191 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

  
  int successful_test_case_count() const;

  
  int failed_test_case_count() const;

  
  int total_test_case_count() const;

  
  
  int test_case_to_run_count() const;

  
  int successful_test_count() const;

  
  int failed_test_count() const;

  
  int reportable_disabled_test_count() const;

  
  int disabled_test_count() const;

  
  int reportable_test_count() const;

  
  int total_test_count() const;

  
  int test_to_run_count() const;

  
  
  TimeInMillis start_timestamp() const;

  
  TimeInMillis elapsed_time() const;

  
  bool Passed() const;

  
  
  bool Failed() const;

  
  
  const TestCase* GetTestCase(int i) const;

  
  
  const TestResult& ad_hoc_test_result() const;

  
  
  TestEventListeners& listeners();

 private:
  
  
  
  
  
  
  
  
  
  Environment* AddEnvironment(Environment* env);

  
  
  
  
  void AddTestPartResult(TestPartResult::Type result_type,
                         const char* file_name,
                         int line_number,
                         const std::string& message,
                         const std::string& os_stack_trace)
      ;

  
  
  
  
  
  void RecordProperty(const std::string& key, const std::string& value);

  
  
  TestCase* GetMutableTestCase(int i);

  
  internal::UnitTestImpl* impl() { return impl_; }
  const internal::UnitTestImpl* impl() const { return impl_; }

  
  
  friend class Test;
  friend class internal::AssertHelper;
  friend class internal::ScopedTrace;
  friend class internal::StreamingListenerTest;
  friend class internal::UnitTestRecordPropertyTestHelper;
  friend Environment* AddGlobalTestEnvironment(Environment* env);
  friend internal::UnitTestImpl* internal::GetUnitTestImpl();
  friend void internal::ReportFailureInUnknownLocation(
      TestPartResult::Type result_type,
      const std::string& message);

  
  UnitTest();

  
  virtual ~UnitTest();

  
  
  void PushGTestTrace(const internal::TraceInfo& trace)
      ;

  
  void PopGTestTrace()
      ;

  
  
  mutable internal::Mutex mutex_;

  
  
  
  
  internal::UnitTestImpl* impl_;

  
  UnitTest(UnitTest const &); void operator=(UnitTest const &);
};



















inline Environment* AddGlobalTestEnvironment(Environment* env) {
  return UnitTest::GetInstance()->AddEnvironment(env);
}










 void InitGoogleTest(int* argc, char** argv);



 void InitGoogleTest(int* argc, wchar_t** argv);

namespace internal {




template <typename T1, typename T2>
AssertionResult CmpHelperEQFailure(const char* lhs_expression,
                                   const char* rhs_expression,
                                   const T1& lhs, const T2& rhs) {
  return EqFailure(lhs_expression,
                   rhs_expression,
                   FormatForComparisonFailureMessage(lhs, rhs),
                   FormatForComparisonFailureMessage(rhs, lhs),
                   false);
}


template <typename T1, typename T2>
AssertionResult CmpHelperEQ(const char* lhs_expression,
                            const char* rhs_expression,
                            const T1& lhs,
                            const T2& rhs) {
__pragma(warning(push)) __pragma(warning(disable: 4389))
  if (lhs == rhs) {
    return AssertionSuccess();
  }
__pragma(warning(pop))

  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);
}




 AssertionResult CmpHelperEQ(const char* lhs_expression,
                                       const char* rhs_expression,
                                       BiggestInt lhs,
                                       BiggestInt rhs);





template <bool lhs_is_null_literal>
class EqHelper {
 public:
  
  template <typename T1, typename T2>
  static AssertionResult Compare(const char* lhs_expression,
                                 const char* rhs_expression,
                                 const T1& lhs,
                                 const T2& rhs) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }

  
  
  
  
  
  
  static AssertionResult Compare(const char* lhs_expression,
                                 const char* rhs_expression,
                                 BiggestInt lhs,
                                 BiggestInt rhs) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }
};



template <>
class EqHelper<true> {
 public:
  
  
  
  
  template <typename T1, typename T2>
  static AssertionResult Compare(
      const char* lhs_expression,
      const char* rhs_expression,
      const T1& lhs,
      const T2& rhs,
      
      
      
      
      
      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }

  
  
  template <typename T>
  static AssertionResult Compare(
      const char* lhs_expression,
      const char* rhs_expression,
      
      
      
      
      
      
      Secret* ,
      T* rhs) {
    
    return CmpHelperEQ(lhs_expression, rhs_expression,
                       static_cast<T*>(0), rhs);
  }
};




template <typename T1, typename T2>
AssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,
                                   const T1& val1, const T2& val2,
                                   const char* op) {
  return AssertionFailure()
         << "Expected: (" << expr1 << ") " << op << " (" << expr2
         << "), actual: " << FormatForComparisonFailureMessage(val1, val2)
         << " vs " << FormatForComparisonFailureMessage(val2, val1);
}




























template <typename T1, typename T2>AssertionResult CmpHelperNE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 != val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "!="); }} AssertionResult CmpHelperNE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperLE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 <= val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "<="); }} AssertionResult CmpHelperLE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperLT(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 < val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "<"); }} AssertionResult CmpHelperLT( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperGE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 >= val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, ">="); }} AssertionResult CmpHelperGE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperGT(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 > val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, ">"); }} AssertionResult CmpHelperGT( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);






 AssertionResult CmpHelperSTREQ(const char* s1_expression,
                                          const char* s2_expression,
                                          const char* s1,
                                          const char* s2);




 AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,
                                              const char* s2_expression,
                                              const char* s1,
                                              const char* s2);




 AssertionResult CmpHelperSTRNE(const char* s1_expression,
                                          const char* s2_expression,
                                          const char* s1,
                                          const char* s2);




 AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
                                              const char* s2_expression,
                                              const char* s1,
                                              const char* s2);





 AssertionResult CmpHelperSTREQ(const char* s1_expression,
                                          const char* s2_expression,
                                          const wchar_t* s1,
                                          const wchar_t* s2);




 AssertionResult CmpHelperSTRNE(const char* s1_expression,
                                          const char* s2_expression,
                                          const wchar_t* s1,
                                          const wchar_t* s2);

}  









 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const char* needle, const char* haystack);
 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const wchar_t* needle, const wchar_t* haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const char* needle, const char* haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const wchar_t* needle, const wchar_t* haystack);
 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::string& needle, const ::std::string& haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::string& needle, const ::std::string& haystack);


 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::wstring& needle, const ::std::wstring& haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::wstring& needle, const ::std::wstring& haystack);
#line 1620 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

namespace internal {








template <typename RawType>
AssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,
                                         const char* rhs_expression,
                                         RawType lhs_value,
                                         RawType rhs_value) {
  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);

  if (lhs.AlmostEquals(rhs)) {
    return AssertionSuccess();
  }

  ::std::stringstream lhs_ss;
  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
         << lhs_value;

  ::std::stringstream rhs_ss;
  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
         << rhs_value;

  return EqFailure(lhs_expression,
                   rhs_expression,
                   StringStreamToString(&lhs_ss),
                   StringStreamToString(&rhs_ss),
                   false);
}




 AssertionResult DoubleNearPredFormat(const char* expr1,
                                                const char* expr2,
                                                const char* abs_error_expr,
                                                double val1,
                                                double val2,
                                                double abs_error);



class  AssertHelper {
 public:
  
  AssertHelper(TestPartResult::Type type,
               const char* file,
               int line,
               const char* message);
  ~AssertHelper();

  
  
  void operator=(const Message& message) const;

 private:
  
  
  
  
  struct AssertHelperData {
    AssertHelperData(TestPartResult::Type t,
                     const char* srcfile,
                     int line_num,
                     const char* msg)
        : type(t), file(srcfile), line(line_num), message(msg) { }

    TestPartResult::Type const type;
    const char* const file;
    int const line;
    std::string const message;

   private:
    AssertHelperData(AssertHelperData const &); void operator=(AssertHelperData const &);
  };

  AssertHelperData* const data_;

  AssertHelper(AssertHelper const &); void operator=(AssertHelper const &);
};

}  




































template <typename T>
class WithParamInterface {
 public:
  typedef T ParamType;
  virtual ~WithParamInterface() {}

  
  
  
  
  
  const ParamType& GetParam() const {
    switch (0) case 0: default: if (::testing::internal::IsTrue(parameter_ != 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h", 1756).GetStream() << "Condition " "parameter_ != NULL" " failed. "
        << "GetParam() can only be called inside a value-parameterized test "
        << "-- did you intend to write TEST_P instead of TEST_F?";
    return *parameter_;
  }

 private:
  
  
  static void SetParam(const ParamType* parameter) {
    parameter_ = parameter;
  }

  
  static const ParamType* parameter_;

  
  template <class TestClass> friend class internal::ParameterizedTestFactory;
};

template <typename T>
const T* WithParamInterface<T>::parameter_ = 0;




template <typename T>
class TestWithParam : public Test, public WithParamInterface<T> {
};

#line 1787 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"




































#line 1824 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"








#line 1833 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"









































#line 1 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest_pred_impl.h"




















































































template <typename Pred,
          typename T1>
AssertionResult AssertPred1Helper(const char* pred_text,
                                  const char* e1,
                                  Pred pred,
                                  const T1& v1) {
  if (pred(v1)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1;
}





























template <typename Pred,
          typename T1,
          typename T2>
AssertionResult AssertPred2Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2) {
  if (pred(v1, v2)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2;
}































template <typename Pred,
          typename T1,
          typename T2,
          typename T3>
AssertionResult AssertPred3Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3) {
  if (pred(v1, v2, v3)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3;
}

































template <typename Pred,
          typename T1,
          typename T2,
          typename T3,
          typename T4>
AssertionResult AssertPred4Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  const char* e4,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3,
                                  const T4& v4) {
  if (pred(v1, v2, v3, v4)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ", "
                            << e4 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3
                            << "\n" << e4 << " evaluates to " << v4;
}



































template <typename Pred,
          typename T1,
          typename T2,
          typename T3,
          typename T4,
          typename T5>
AssertionResult AssertPred5Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  const char* e4,
                                  const char* e5,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3,
                                  const T4& v4,
                                  const T5& v5) {
  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ", "
                            << e4 << ", "
                            << e5 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3
                            << "\n" << e4 << " evaluates to " << v4
                            << "\n" << e5 << " evaluates to " << v5;
}



































#line 359 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest_pred_impl.h"
#line 1875 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"


















































































#line 1958 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"



#line 1962 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"



#line 1966 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"



#line 1970 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"



#line 1974 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"



#line 1978 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"
















































































 AssertionResult FloatLE(const char* expr1, const char* expr2,
                                   float val1, float val2);
 AssertionResult DoubleLE(const char* expr1, const char* expr2,
                                    double val1, double val2);

























#line 2088 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"





























































template <typename T1, typename T2>
bool StaticAssertTypeEq() {
  (void)internal::StaticAssertTypeEqHelper<T1, T2>();
  return true;
}


































#line 2189 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"































}  









int RUN_ALL_TESTS() ;

inline int RUN_ALL_TESTS() {
  return ::testing::UnitTest::GetInstance()->Run();
}

#line 2237 "d:\\c++code\\googletest\\googletest\\include\\gtest\\gtest.h"

#line 2 "d:\\c++code\\robot\\gtest\\main.cpp"


int main(int argc, char* argv[])
{
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
