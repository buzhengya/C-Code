// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ss_game.proto

#ifndef PROTOBUF_ss_5fgame_2eproto__INCLUDED
#define PROTOBUF_ss_5fgame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ss_protoid.pb.h"
#include "cm_socialtype.pb.h"
#include "cm_roletype.pb.h"
#include "cs_errorcode.pb.h"
// @@protoc_insertion_point(includes)

namespace SProtoSpace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ss_5fgame_2eproto();
void protobuf_AssignDesc_ss_5fgame_2eproto();
void protobuf_ShutdownFile_ss_5fgame_2eproto();

class role_enter_game_server;
class gt_enter_game_ack;
class gs_create_scene_req;
class gs_create_scene_ack;
class gs_kick_role_req;
class gs_kick_role_ack;
class gs_broadcast_req;
class gs_change_name_req;
class gt_change_name_ret;
class gs_jump_to_cross_game_req;
class gt_kick_role_ntf;
class gs_player_num_ntf;
class gate_forward_search_req;
class log_gather_info;
class log_gather_player_register;
class log_gather_player_login;
class log_gather_player_logout;
class log_gather_money_flow;
class log_gather_item_flow;
class log_gather_item_money_flow;
class log_gather_player_exp_flow;
class log_gather_sns_flow;
class log_gather_round_flow;
class log_gather_role_info;
class log_gather_task_info;
class log_gather_honor_info;
class log_gather_level_up_info;
class log_gather_buy_info;
class allocate_chat_room_req;
class allocate_chat_room_ack;
class gs_get_role_position_req;
class gs_get_role_position_ack;
class red_pt_ss_ntf;
class get_other_role_fashion_ss_req;
class get_other_role_fashion_ss_ack;
class gs_chat_req;
class gs_chat_ack;
class user_event_track_ss_ntf;

enum ELogEventType {
  LogEvtTP_Base = 0,
  LogEvtTP_Task = 1,
  LogEvtTP_Honor = 2,
  LogEvtTP_Level = 3,
  LogEvtTP_Shop = 4
};
bool ELogEventType_IsValid(int value);
const ELogEventType ELogEventType_MIN = LogEvtTP_Base;
const ELogEventType ELogEventType_MAX = LogEvtTP_Shop;
const int ELogEventType_ARRAYSIZE = ELogEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ELogEventType_descriptor();
inline const ::std::string& ELogEventType_Name(ELogEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ELogEventType_descriptor(), value);
}
inline bool ELogEventType_Parse(
    const ::std::string& name, ELogEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ELogEventType>(
    ELogEventType_descriptor(), name, value);
}
enum EConomicAnalysisType {
  EConomicAnalysisType_None = 0,
  EConomicAnalysisType_PlayerRegister = 1,
  EConomicAnalysisType_PlayerLogin = 2,
  EConomicAnalysisType_PlayerLogout = 3,
  EConomicAnalysisType_MoneyFlow = 4,
  EConomicAnalysisType_ItemFlow = 5,
  EConomicAnalysisType_ItemMoneyFlow = 6,
  EConomicAnalysisType_PlayerExpFlow = 7,
  EConomicAnalysisType_SnsFlow = 8,
  EConomicAnalysisType_RoundFlow = 9
};
bool EConomicAnalysisType_IsValid(int value);
const EConomicAnalysisType EConomicAnalysisType_MIN = EConomicAnalysisType_None;
const EConomicAnalysisType EConomicAnalysisType_MAX = EConomicAnalysisType_RoundFlow;
const int EConomicAnalysisType_ARRAYSIZE = EConomicAnalysisType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EConomicAnalysisType_descriptor();
inline const ::std::string& EConomicAnalysisType_Name(EConomicAnalysisType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EConomicAnalysisType_descriptor(), value);
}
inline bool EConomicAnalysisType_Parse(
    const ::std::string& name, EConomicAnalysisType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EConomicAnalysisType>(
    EConomicAnalysisType_descriptor(), name, value);
}
enum EAddItemReasonLv1 {
  EAddItemReasonLv1_None = 0,
  EAddItemReasonLv1_AchievementFinish = 11,
  EAddItemReasonLv1_AchievementGetReward = 12,
  EAddItemReasonLv1_AchievementGetPtReward = 13,
  EAddItemReasonLv1_DrawCardFreeGoldSingle = 21,
  EAddItemReasonLv1_DrawCardChargeGoldSingle = 22,
  EAddItemReasonLv1_DrawCardChargeGoldConsecutive = 23,
  EAddItemReasonLv1_DrawCardFreeJadeSingle = 24,
  EAddItemReasonLv1_DrawCardChargeJadeSingle = 25,
  EAddItemReasonLv1_DrawCardChargeJadeConsecutive = 26,
  EAddItemReasonLv1_BuyGiftPackage = 31,
  EAddItemReasonLv1_BuyJade = 32,
  EAddItemReasonLv1_RoleFashionBuy = 41,
  EAddItemReasonLv1_RoleFashionWear = 42,
  EAddItemReasonLv1_SignIn = 51,
  EAddItemReasonLv1_SignMakeUp = 52,
  EAddItemReasonLv1_MainLineTaskFinish = 61,
  EAddItemReasonLv1_MainLineTaskGetReward = 62,
  EAddItemReasonLv1_SideLineTaskFinish = 63,
  EAddItemReasonLv1_SideLineTaskGetReward = 64,
  EAddItemReasonLv1_QiJuZhuFinishTask = 71,
  EAddItemReasonLv1_QiJuZhuGetTaskReward = 72,
  EAddItemReasonLv1_QiJuZhuGetActiviryReward = 73,
  EAddItemReasonLv1_BuyItem = 81,
  EAddItemReasonLv1_SnsSendGift = 91,
  EAddItemReasonLv1_SnsThumbUp = 92,
  EAddItemReasonLv1_SnsSendMail = 93,
  EAddItemReasonLv1_StageFirstPass = 101,
  EAddItemReasonLv1_StageRePass = 102,
  EAddItemReasonLv1_StageMopping = 103,
  EAddItemReasonLv1_StageFailPass = 104,
  EAddItemReasonLv1_StageGet3StarsReward = 105,
  EAddItemReasonLv1_EventTaskFinish = 111,
  EAddItemReasonLv1_EventTaskGetReward = 112,
  EAddItemReasonLv1_OfficeApply = 121,
  EAddItemReasonLv1_OfficePass = 122,
  EAddItemReasonLv1_OfficeFail = 123,
  EAddItemReasonLv1_TowerGetChest = 131,
  EAddItemReasonLv1_TowerPassQuestion = 132,
  EAddItemReasonLv1_TowerChallengeSucceed = 133,
  EAddItemReasonLv1_TowerChallengeFail = 134,
  EAddItemReasonLv1_Chat3DHangUp = 141,
  EAddItemReasonLv1_HeroAddExp = 161,
  EAddItemReasonLv1_HeroStarUp = 162,
  EAddItemReasonLv1_HeroQualityUp = 163,
  EAddItemReasonLv1_HeroTalismanUp = 164,
  EAddItemReasonLv1_RoyalWin = 171,
  EAddItemReasonLv1_RoyalLose = 172
};
bool EAddItemReasonLv1_IsValid(int value);
const EAddItemReasonLv1 EAddItemReasonLv1_MIN = EAddItemReasonLv1_None;
const EAddItemReasonLv1 EAddItemReasonLv1_MAX = EAddItemReasonLv1_RoyalLose;
const int EAddItemReasonLv1_ARRAYSIZE = EAddItemReasonLv1_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAddItemReasonLv1_descriptor();
inline const ::std::string& EAddItemReasonLv1_Name(EAddItemReasonLv1 value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAddItemReasonLv1_descriptor(), value);
}
inline bool EAddItemReasonLv1_Parse(
    const ::std::string& name, EAddItemReasonLv1* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAddItemReasonLv1>(
    EAddItemReasonLv1_descriptor(), name, value);
}
// ===================================================================

class role_enter_game_server : public ::google::protobuf::Message {
 public:
  role_enter_game_server();
  virtual ~role_enter_game_server();

  role_enter_game_server(const role_enter_game_server& from);

  inline role_enter_game_server& operator=(const role_enter_game_server& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_enter_game_server& default_instance();

  void Swap(role_enter_game_server* other);

  // implements Message ----------------------------------------------

  role_enter_game_server* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_enter_game_server& from);
  void MergeFrom(const role_enter_game_server& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_enter_game_server_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 role_id = 2;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional uint32 area_id = 3;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 area_id() const;
  inline void set_area_id(::google::protobuf::uint32 value);

  // optional uint64 db_svr_id = 4;
  inline bool has_db_svr_id() const;
  inline void clear_db_svr_id();
  static const int kDbSvrIdFieldNumber = 4;
  inline ::google::protobuf::uint64 db_svr_id() const;
  inline void set_db_svr_id(::google::protobuf::uint64 value);

  // optional bool is_reconnect = 5;
  inline bool has_is_reconnect() const;
  inline void clear_is_reconnect();
  static const int kIsReconnectFieldNumber = 5;
  inline bool is_reconnect() const;
  inline void set_is_reconnect(bool value);

  // optional bool is_switch_scene = 6 [default = false];
  inline bool has_is_switch_scene() const;
  inline void clear_is_switch_scene();
  static const int kIsSwitchSceneFieldNumber = 6;
  inline bool is_switch_scene() const;
  inline void set_is_switch_scene(bool value);

  // optional uint32 scene_id = 7 [default = 0];
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 7;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 scene_type = 8 [default = 0];
  inline bool has_scene_type() const;
  inline void clear_scene_type();
  static const int kSceneTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 scene_type() const;
  inline void set_scene_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.role_enter_game_server)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_db_svr_id();
  inline void clear_has_db_svr_id();
  inline void set_has_is_reconnect();
  inline void clear_has_is_reconnect();
  inline void set_has_is_switch_scene();
  inline void clear_has_is_switch_scene();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  int protoid_;
  ::google::protobuf::uint32 area_id_;
  ::google::protobuf::uint64 db_svr_id_;
  bool is_reconnect_;
  bool is_switch_scene_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 scene_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static role_enter_game_server* default_instance_;
};
// -------------------------------------------------------------------

class gt_enter_game_ack : public ::google::protobuf::Message {
 public:
  gt_enter_game_ack();
  virtual ~gt_enter_game_ack();

  gt_enter_game_ack(const gt_enter_game_ack& from);

  inline gt_enter_game_ack& operator=(const gt_enter_game_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_enter_game_ack& default_instance();

  void Swap(gt_enter_game_ack* other);

  // implements Message ----------------------------------------------

  gt_enter_game_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_enter_game_ack& from);
  void MergeFrom(const gt_enter_game_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_enter_game_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 role_id = 2;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 ret = 4;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 4;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_enter_game_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  int protoid_;
  ::google::protobuf::int32 ret_;
  ::std::string* role_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gt_enter_game_ack* default_instance_;
};
// -------------------------------------------------------------------

class gs_create_scene_req : public ::google::protobuf::Message {
 public:
  gs_create_scene_req();
  virtual ~gs_create_scene_req();

  gs_create_scene_req(const gs_create_scene_req& from);

  inline gs_create_scene_req& operator=(const gs_create_scene_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_create_scene_req& default_instance();

  void Swap(gs_create_scene_req* other);

  // implements Message ----------------------------------------------

  gs_create_scene_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_create_scene_req& from);
  void MergeFrom(const gs_create_scene_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_create_scene_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 create_type = 2;
  inline bool has_create_type() const;
  inline void clear_create_type();
  static const int kCreateTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 create_type() const;
  inline void set_create_type(::google::protobuf::uint32 value);

  // optional uint32 scene_id = 3;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 3;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 scene_type = 4;
  inline bool has_scene_type() const;
  inline void clear_scene_type();
  static const int kSceneTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 scene_type() const;
  inline void set_scene_type(::google::protobuf::uint32 value);

  // optional uint32 param = 5;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 5;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 last_time = 6;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_time() const;
  inline void set_last_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_create_scene_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_create_type();
  inline void clear_has_create_type();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_last_time();
  inline void clear_has_last_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 create_type_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 scene_type_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 last_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_create_scene_req* default_instance_;
};
// -------------------------------------------------------------------

class gs_create_scene_ack : public ::google::protobuf::Message {
 public:
  gs_create_scene_ack();
  virtual ~gs_create_scene_ack();

  gs_create_scene_ack(const gs_create_scene_ack& from);

  inline gs_create_scene_ack& operator=(const gs_create_scene_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_create_scene_ack& default_instance();

  void Swap(gs_create_scene_ack* other);

  // implements Message ----------------------------------------------

  gs_create_scene_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_create_scene_ack& from);
  void MergeFrom(const gs_create_scene_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_create_scene_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 create_type = 2;
  inline bool has_create_type() const;
  inline void clear_create_type();
  static const int kCreateTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 create_type() const;
  inline void set_create_type(::google::protobuf::uint32 value);

  // optional uint32 scene_id = 3;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 3;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 scene_type = 4;
  inline bool has_scene_type() const;
  inline void clear_scene_type();
  static const int kSceneTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 scene_type() const;
  inline void set_scene_type(::google::protobuf::uint32 value);

  // optional uint32 param = 5;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 5;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 last_time = 6;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_time() const;
  inline void set_last_time(::google::protobuf::uint32 value);

  // optional uint32 ret = 7;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 7;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_create_scene_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_create_type();
  inline void clear_has_create_type();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 create_type_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 scene_type_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 last_time_;
  ::google::protobuf::uint32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_create_scene_ack* default_instance_;
};
// -------------------------------------------------------------------

class gs_kick_role_req : public ::google::protobuf::Message {
 public:
  gs_kick_role_req();
  virtual ~gs_kick_role_req();

  gs_kick_role_req(const gs_kick_role_req& from);

  inline gs_kick_role_req& operator=(const gs_kick_role_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_kick_role_req& default_instance();

  void Swap(gs_kick_role_req* other);

  // implements Message ----------------------------------------------

  gs_kick_role_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_kick_role_req& from);
  void MergeFrom(const gs_kick_role_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_kick_role_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // optional uint32 scene_id = 3;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 3;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 scene_type = 4;
  inline bool has_scene_type() const;
  inline void clear_scene_type();
  static const int kSceneTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 scene_type() const;
  inline void set_scene_type(::google::protobuf::uint32 value);

  // optional uint64 game_id = 5;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 5;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_kick_role_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 scene_type_;
  ::google::protobuf::uint64 game_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_kick_role_req* default_instance_;
};
// -------------------------------------------------------------------

class gs_kick_role_ack : public ::google::protobuf::Message {
 public:
  gs_kick_role_ack();
  virtual ~gs_kick_role_ack();

  gs_kick_role_ack(const gs_kick_role_ack& from);

  inline gs_kick_role_ack& operator=(const gs_kick_role_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_kick_role_ack& default_instance();

  void Swap(gs_kick_role_ack* other);

  // implements Message ----------------------------------------------

  gs_kick_role_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_kick_role_ack& from);
  void MergeFrom(const gs_kick_role_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_kick_role_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // optional uint32 ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // optional uint32 scene_id = 4;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 4;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 scene_type = 5;
  inline bool has_scene_type() const;
  inline void clear_scene_type();
  static const int kSceneTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 scene_type() const;
  inline void set_scene_type(::google::protobuf::uint32 value);

  // optional uint64 game_id = 6;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 6;
  inline ::google::protobuf::uint64 game_id() const;
  inline void set_game_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_kick_role_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();
  inline void set_has_game_id();
  inline void clear_has_game_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint64 game_id_;
  ::google::protobuf::uint32 scene_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_kick_role_ack* default_instance_;
};
// -------------------------------------------------------------------

class gs_broadcast_req : public ::google::protobuf::Message {
 public:
  gs_broadcast_req();
  virtual ~gs_broadcast_req();

  gs_broadcast_req(const gs_broadcast_req& from);

  inline gs_broadcast_req& operator=(const gs_broadcast_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_broadcast_req& default_instance();

  void Swap(gs_broadcast_req* other);

  // implements Message ----------------------------------------------

  gs_broadcast_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_broadcast_req& from);
  void MergeFrom(const gs_broadcast_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_broadcast_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional bytes proto = 2;
  inline bool has_proto() const;
  inline void clear_proto();
  static const int kProtoFieldNumber = 2;
  inline const ::std::string& proto() const;
  inline void set_proto(const ::std::string& value);
  inline void set_proto(const char* value);
  inline void set_proto(const void* value, size_t size);
  inline ::std::string* mutable_proto();
  inline ::std::string* release_proto();
  inline void set_allocated_proto(::std::string* proto);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_broadcast_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_proto();
  inline void clear_has_proto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* proto_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_broadcast_req* default_instance_;
};
// -------------------------------------------------------------------

class gs_change_name_req : public ::google::protobuf::Message {
 public:
  gs_change_name_req();
  virtual ~gs_change_name_req();

  gs_change_name_req(const gs_change_name_req& from);

  inline gs_change_name_req& operator=(const gs_change_name_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_change_name_req& default_instance();

  void Swap(gs_change_name_req* other);

  // implements Message ----------------------------------------------

  gs_change_name_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_change_name_req& from);
  void MergeFrom(const gs_change_name_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_change_name_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string new_name = 2;
  inline bool has_new_name() const;
  inline void clear_new_name();
  static const int kNewNameFieldNumber = 2;
  inline const ::std::string& new_name() const;
  inline void set_new_name(const ::std::string& value);
  inline void set_new_name(const char* value);
  inline void set_new_name(const char* value, size_t size);
  inline ::std::string* mutable_new_name();
  inline ::std::string* release_new_name();
  inline void set_allocated_new_name(::std::string* new_name);

  // optional string old_name = 3;
  inline bool has_old_name() const;
  inline void clear_old_name();
  static const int kOldNameFieldNumber = 3;
  inline const ::std::string& old_name() const;
  inline void set_old_name(const ::std::string& value);
  inline void set_old_name(const char* value);
  inline void set_old_name(const char* value, size_t size);
  inline ::std::string* mutable_old_name();
  inline ::std::string* release_old_name();
  inline void set_allocated_old_name(::std::string* old_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_change_name_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_new_name();
  inline void clear_has_new_name();
  inline void set_has_old_name();
  inline void clear_has_old_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* new_name_;
  ::std::string* old_name_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_change_name_req* default_instance_;
};
// -------------------------------------------------------------------

class gt_change_name_ret : public ::google::protobuf::Message {
 public:
  gt_change_name_ret();
  virtual ~gt_change_name_ret();

  gt_change_name_ret(const gt_change_name_ret& from);

  inline gt_change_name_ret& operator=(const gt_change_name_ret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_change_name_ret& default_instance();

  void Swap(gt_change_name_ret* other);

  // implements Message ----------------------------------------------

  gt_change_name_ret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_change_name_ret& from);
  void MergeFrom(const gt_change_name_ret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_change_name_ret_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string new_name = 2;
  inline bool has_new_name() const;
  inline void clear_new_name();
  static const int kNewNameFieldNumber = 2;
  inline const ::std::string& new_name() const;
  inline void set_new_name(const ::std::string& value);
  inline void set_new_name(const char* value);
  inline void set_new_name(const char* value, size_t size);
  inline ::std::string* mutable_new_name();
  inline ::std::string* release_new_name();
  inline void set_allocated_new_name(::std::string* new_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_change_name_ret)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_new_name();
  inline void clear_has_new_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* new_name_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gt_change_name_ret* default_instance_;
};
// -------------------------------------------------------------------

class gs_jump_to_cross_game_req : public ::google::protobuf::Message {
 public:
  gs_jump_to_cross_game_req();
  virtual ~gs_jump_to_cross_game_req();

  gs_jump_to_cross_game_req(const gs_jump_to_cross_game_req& from);

  inline gs_jump_to_cross_game_req& operator=(const gs_jump_to_cross_game_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_jump_to_cross_game_req& default_instance();

  void Swap(gs_jump_to_cross_game_req* other);

  // implements Message ----------------------------------------------

  gs_jump_to_cross_game_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_jump_to_cross_game_req& from);
  void MergeFrom(const gs_jump_to_cross_game_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_jump_to_cross_game_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_jump_to_cross_game_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_jump_to_cross_game_req* default_instance_;
};
// -------------------------------------------------------------------

class gt_kick_role_ntf : public ::google::protobuf::Message {
 public:
  gt_kick_role_ntf();
  virtual ~gt_kick_role_ntf();

  gt_kick_role_ntf(const gt_kick_role_ntf& from);

  inline gt_kick_role_ntf& operator=(const gt_kick_role_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_kick_role_ntf& default_instance();

  void Swap(gt_kick_role_ntf* other);

  // implements Message ----------------------------------------------

  gt_kick_role_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_kick_role_ntf& from);
  void MergeFrom(const gt_kick_role_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_kick_role_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::uint64 player_id() const;
  inline void set_player_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_kick_role_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 player_id_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gt_kick_role_ntf* default_instance_;
};
// -------------------------------------------------------------------

class gs_player_num_ntf : public ::google::protobuf::Message {
 public:
  gs_player_num_ntf();
  virtual ~gs_player_num_ntf();

  gs_player_num_ntf(const gs_player_num_ntf& from);

  inline gs_player_num_ntf& operator=(const gs_player_num_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_player_num_ntf& default_instance();

  void Swap(gs_player_num_ntf* other);

  // implements Message ----------------------------------------------

  gs_player_num_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_player_num_ntf& from);
  void MergeFrom(const gs_player_num_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_player_num_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 player_num = 2;
  inline bool has_player_num() const;
  inline void clear_player_num();
  static const int kPlayerNumFieldNumber = 2;
  inline ::google::protobuf::uint32 player_num() const;
  inline void set_player_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_player_num_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_player_num();
  inline void clear_has_player_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 player_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_player_num_ntf* default_instance_;
};
// -------------------------------------------------------------------

class gate_forward_search_req : public ::google::protobuf::Message {
 public:
  gate_forward_search_req();
  virtual ~gate_forward_search_req();

  gate_forward_search_req(const gate_forward_search_req& from);

  inline gate_forward_search_req& operator=(const gate_forward_search_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate_forward_search_req& default_instance();

  void Swap(gate_forward_search_req* other);

  // implements Message ----------------------------------------------

  gate_forward_search_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate_forward_search_req& from);
  void MergeFrom(const gate_forward_search_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gate_forward_search_req_id];
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID proto_id() const;
  inline void set_proto_id(::SProtoSpace::ESSProtoID value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint64 uuid = 4;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 4;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gate_forward_search_req)
 private:
  inline void set_has_proto_id();
  inline void clear_has_proto_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int proto_id_;
  ::google::protobuf::uint32 type_;
  ::std::string* content_;
  ::google::protobuf::uint64 uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gate_forward_search_req* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_info : public ::google::protobuf::Message {
 public:
  log_gather_info();
  virtual ~log_gather_info();

  log_gather_info(const log_gather_info& from);

  inline log_gather_info& operator=(const log_gather_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_info& default_instance();

  void Swap(log_gather_info* other);

  // implements Message ----------------------------------------------

  log_gather_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_info& from);
  void MergeFrom(const log_gather_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.log_gather_role_info role_info = 1;
  inline bool has_role_info() const;
  inline void clear_role_info();
  static const int kRoleInfoFieldNumber = 1;
  inline const ::SProtoSpace::log_gather_role_info& role_info() const;
  inline ::SProtoSpace::log_gather_role_info* mutable_role_info();
  inline ::SProtoSpace::log_gather_role_info* release_role_info();
  inline void set_allocated_role_info(::SProtoSpace::log_gather_role_info* role_info);

  // optional .SProtoSpace.log_gather_task_info task_info = 2;
  inline bool has_task_info() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 2;
  inline const ::SProtoSpace::log_gather_task_info& task_info() const;
  inline ::SProtoSpace::log_gather_task_info* mutable_task_info();
  inline ::SProtoSpace::log_gather_task_info* release_task_info();
  inline void set_allocated_task_info(::SProtoSpace::log_gather_task_info* task_info);

  // optional .SProtoSpace.log_gather_honor_info honor_info = 3;
  inline bool has_honor_info() const;
  inline void clear_honor_info();
  static const int kHonorInfoFieldNumber = 3;
  inline const ::SProtoSpace::log_gather_honor_info& honor_info() const;
  inline ::SProtoSpace::log_gather_honor_info* mutable_honor_info();
  inline ::SProtoSpace::log_gather_honor_info* release_honor_info();
  inline void set_allocated_honor_info(::SProtoSpace::log_gather_honor_info* honor_info);

  // optional .SProtoSpace.log_gather_level_up_info level_info = 4;
  inline bool has_level_info() const;
  inline void clear_level_info();
  static const int kLevelInfoFieldNumber = 4;
  inline const ::SProtoSpace::log_gather_level_up_info& level_info() const;
  inline ::SProtoSpace::log_gather_level_up_info* mutable_level_info();
  inline ::SProtoSpace::log_gather_level_up_info* release_level_info();
  inline void set_allocated_level_info(::SProtoSpace::log_gather_level_up_info* level_info);

  // optional .SProtoSpace.log_gather_buy_info buy_info = 5;
  inline bool has_buy_info() const;
  inline void clear_buy_info();
  static const int kBuyInfoFieldNumber = 5;
  inline const ::SProtoSpace::log_gather_buy_info& buy_info() const;
  inline ::SProtoSpace::log_gather_buy_info* mutable_buy_info();
  inline ::SProtoSpace::log_gather_buy_info* release_buy_info();
  inline void set_allocated_buy_info(::SProtoSpace::log_gather_buy_info* buy_info);

  // repeated .SProtoSpace.log_gather_player_register player_register = 6;
  inline int player_register_size() const;
  inline void clear_player_register();
  static const int kPlayerRegisterFieldNumber = 6;
  inline const ::SProtoSpace::log_gather_player_register& player_register(int index) const;
  inline ::SProtoSpace::log_gather_player_register* mutable_player_register(int index);
  inline ::SProtoSpace::log_gather_player_register* add_player_register();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_register >&
      player_register() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_register >*
      mutable_player_register();

  // repeated .SProtoSpace.log_gather_player_login player_login = 7;
  inline int player_login_size() const;
  inline void clear_player_login();
  static const int kPlayerLoginFieldNumber = 7;
  inline const ::SProtoSpace::log_gather_player_login& player_login(int index) const;
  inline ::SProtoSpace::log_gather_player_login* mutable_player_login(int index);
  inline ::SProtoSpace::log_gather_player_login* add_player_login();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_login >&
      player_login() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_login >*
      mutable_player_login();

  // repeated .SProtoSpace.log_gather_player_logout player_logout = 8;
  inline int player_logout_size() const;
  inline void clear_player_logout();
  static const int kPlayerLogoutFieldNumber = 8;
  inline const ::SProtoSpace::log_gather_player_logout& player_logout(int index) const;
  inline ::SProtoSpace::log_gather_player_logout* mutable_player_logout(int index);
  inline ::SProtoSpace::log_gather_player_logout* add_player_logout();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_logout >&
      player_logout() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_logout >*
      mutable_player_logout();

  // repeated .SProtoSpace.log_gather_money_flow money_flow = 9;
  inline int money_flow_size() const;
  inline void clear_money_flow();
  static const int kMoneyFlowFieldNumber = 9;
  inline const ::SProtoSpace::log_gather_money_flow& money_flow(int index) const;
  inline ::SProtoSpace::log_gather_money_flow* mutable_money_flow(int index);
  inline ::SProtoSpace::log_gather_money_flow* add_money_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_money_flow >&
      money_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_money_flow >*
      mutable_money_flow();

  // repeated .SProtoSpace.log_gather_item_flow item_flow = 10;
  inline int item_flow_size() const;
  inline void clear_item_flow();
  static const int kItemFlowFieldNumber = 10;
  inline const ::SProtoSpace::log_gather_item_flow& item_flow(int index) const;
  inline ::SProtoSpace::log_gather_item_flow* mutable_item_flow(int index);
  inline ::SProtoSpace::log_gather_item_flow* add_item_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_flow >&
      item_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_flow >*
      mutable_item_flow();

  // repeated .SProtoSpace.log_gather_item_money_flow item_money_flow = 11;
  inline int item_money_flow_size() const;
  inline void clear_item_money_flow();
  static const int kItemMoneyFlowFieldNumber = 11;
  inline const ::SProtoSpace::log_gather_item_money_flow& item_money_flow(int index) const;
  inline ::SProtoSpace::log_gather_item_money_flow* mutable_item_money_flow(int index);
  inline ::SProtoSpace::log_gather_item_money_flow* add_item_money_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_money_flow >&
      item_money_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_money_flow >*
      mutable_item_money_flow();

  // repeated .SProtoSpace.log_gather_player_exp_flow player_exp_flow = 12;
  inline int player_exp_flow_size() const;
  inline void clear_player_exp_flow();
  static const int kPlayerExpFlowFieldNumber = 12;
  inline const ::SProtoSpace::log_gather_player_exp_flow& player_exp_flow(int index) const;
  inline ::SProtoSpace::log_gather_player_exp_flow* mutable_player_exp_flow(int index);
  inline ::SProtoSpace::log_gather_player_exp_flow* add_player_exp_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_exp_flow >&
      player_exp_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_exp_flow >*
      mutable_player_exp_flow();

  // repeated .SProtoSpace.log_gather_sns_flow sns_flow = 13;
  inline int sns_flow_size() const;
  inline void clear_sns_flow();
  static const int kSnsFlowFieldNumber = 13;
  inline const ::SProtoSpace::log_gather_sns_flow& sns_flow(int index) const;
  inline ::SProtoSpace::log_gather_sns_flow* mutable_sns_flow(int index);
  inline ::SProtoSpace::log_gather_sns_flow* add_sns_flow();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_sns_flow >&
      sns_flow() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_sns_flow >*
      mutable_sns_flow();

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_info)
 private:
  inline void set_has_role_info();
  inline void clear_has_role_info();
  inline void set_has_task_info();
  inline void clear_has_task_info();
  inline void set_has_honor_info();
  inline void clear_has_honor_info();
  inline void set_has_level_info();
  inline void clear_has_level_info();
  inline void set_has_buy_info();
  inline void clear_has_buy_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::log_gather_role_info* role_info_;
  ::SProtoSpace::log_gather_task_info* task_info_;
  ::SProtoSpace::log_gather_honor_info* honor_info_;
  ::SProtoSpace::log_gather_level_up_info* level_info_;
  ::SProtoSpace::log_gather_buy_info* buy_info_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_register > player_register_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_login > player_login_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_logout > player_logout_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_money_flow > money_flow_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_flow > item_flow_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_money_flow > item_money_flow_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_exp_flow > player_exp_flow_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_sns_flow > sns_flow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_info* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_player_register : public ::google::protobuf::Message {
 public:
  log_gather_player_register();
  virtual ~log_gather_player_register();

  log_gather_player_register(const log_gather_player_register& from);

  inline log_gather_player_register& operator=(const log_gather_player_register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_player_register& default_instance();

  void Swap(log_gather_player_register* other);

  // implements Message ----------------------------------------------

  log_gather_player_register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_player_register& from);
  void MergeFrom(const log_gather_player_register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string vGameAppID = 3;
  inline bool has_vgameappid() const;
  inline void clear_vgameappid();
  static const int kVGameAppIDFieldNumber = 3;
  inline const ::std::string& vgameappid() const;
  inline void set_vgameappid(const ::std::string& value);
  inline void set_vgameappid(const char* value);
  inline void set_vgameappid(const char* value, size_t size);
  inline ::std::string* mutable_vgameappid();
  inline ::std::string* release_vgameappid();
  inline void set_allocated_vgameappid(::std::string* vgameappid);

  // optional int32 PlatID = 4;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 4;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 iZoneAreaID = 5;
  inline bool has_izoneareaid() const;
  inline void clear_izoneareaid();
  static const int kIZoneAreaIDFieldNumber = 5;
  inline ::google::protobuf::int32 izoneareaid() const;
  inline void set_izoneareaid(::google::protobuf::int32 value);

  // optional string vopenid = 6;
  inline bool has_vopenid() const;
  inline void clear_vopenid();
  static const int kVopenidFieldNumber = 6;
  inline const ::std::string& vopenid() const;
  inline void set_vopenid(const ::std::string& value);
  inline void set_vopenid(const char* value);
  inline void set_vopenid(const char* value, size_t size);
  inline ::std::string* mutable_vopenid();
  inline ::std::string* release_vopenid();
  inline void set_allocated_vopenid(::std::string* vopenid);

  // optional string ClientVersion = 7;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 7;
  inline const ::std::string& clientversion() const;
  inline void set_clientversion(const ::std::string& value);
  inline void set_clientversion(const char* value);
  inline void set_clientversion(const char* value, size_t size);
  inline ::std::string* mutable_clientversion();
  inline ::std::string* release_clientversion();
  inline void set_allocated_clientversion(::std::string* clientversion);

  // optional string SystemSoftware = 8;
  inline bool has_systemsoftware() const;
  inline void clear_systemsoftware();
  static const int kSystemSoftwareFieldNumber = 8;
  inline const ::std::string& systemsoftware() const;
  inline void set_systemsoftware(const ::std::string& value);
  inline void set_systemsoftware(const char* value);
  inline void set_systemsoftware(const char* value, size_t size);
  inline ::std::string* mutable_systemsoftware();
  inline ::std::string* release_systemsoftware();
  inline void set_allocated_systemsoftware(::std::string* systemsoftware);

  // optional string SystemHardware = 9;
  inline bool has_systemhardware() const;
  inline void clear_systemhardware();
  static const int kSystemHardwareFieldNumber = 9;
  inline const ::std::string& systemhardware() const;
  inline void set_systemhardware(const ::std::string& value);
  inline void set_systemhardware(const char* value);
  inline void set_systemhardware(const char* value, size_t size);
  inline ::std::string* mutable_systemhardware();
  inline ::std::string* release_systemhardware();
  inline void set_allocated_systemhardware(::std::string* systemhardware);

  // optional string TelecomOper = 10;
  inline bool has_telecomoper() const;
  inline void clear_telecomoper();
  static const int kTelecomOperFieldNumber = 10;
  inline const ::std::string& telecomoper() const;
  inline void set_telecomoper(const ::std::string& value);
  inline void set_telecomoper(const char* value);
  inline void set_telecomoper(const char* value, size_t size);
  inline ::std::string* mutable_telecomoper();
  inline ::std::string* release_telecomoper();
  inline void set_allocated_telecomoper(::std::string* telecomoper);

  // optional string Network = 11;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 11;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional int32 ScreenWidth = 12;
  inline bool has_screenwidth() const;
  inline void clear_screenwidth();
  static const int kScreenWidthFieldNumber = 12;
  inline ::google::protobuf::int32 screenwidth() const;
  inline void set_screenwidth(::google::protobuf::int32 value);

  // optional int32 ScreenHight = 13;
  inline bool has_screenhight() const;
  inline void clear_screenhight();
  static const int kScreenHightFieldNumber = 13;
  inline ::google::protobuf::int32 screenhight() const;
  inline void set_screenhight(::google::protobuf::int32 value);

  // optional float Density = 14;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 14;
  inline float density() const;
  inline void set_density(float value);

  // optional int32 RegChannel = 15;
  inline bool has_regchannel() const;
  inline void clear_regchannel();
  static const int kRegChannelFieldNumber = 15;
  inline ::google::protobuf::int32 regchannel() const;
  inline void set_regchannel(::google::protobuf::int32 value);

  // optional string CpuHardware = 16;
  inline bool has_cpuhardware() const;
  inline void clear_cpuhardware();
  static const int kCpuHardwareFieldNumber = 16;
  inline const ::std::string& cpuhardware() const;
  inline void set_cpuhardware(const ::std::string& value);
  inline void set_cpuhardware(const char* value);
  inline void set_cpuhardware(const char* value, size_t size);
  inline ::std::string* mutable_cpuhardware();
  inline ::std::string* release_cpuhardware();
  inline void set_allocated_cpuhardware(::std::string* cpuhardware);

  // optional int32 Memory = 17;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 17;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);

  // optional string GLRender = 18;
  inline bool has_glrender() const;
  inline void clear_glrender();
  static const int kGLRenderFieldNumber = 18;
  inline const ::std::string& glrender() const;
  inline void set_glrender(const ::std::string& value);
  inline void set_glrender(const char* value);
  inline void set_glrender(const char* value, size_t size);
  inline ::std::string* mutable_glrender();
  inline ::std::string* release_glrender();
  inline void set_allocated_glrender(::std::string* glrender);

  // optional string GLVersion = 19;
  inline bool has_glversion() const;
  inline void clear_glversion();
  static const int kGLVersionFieldNumber = 19;
  inline const ::std::string& glversion() const;
  inline void set_glversion(const ::std::string& value);
  inline void set_glversion(const char* value);
  inline void set_glversion(const char* value, size_t size);
  inline ::std::string* mutable_glversion();
  inline ::std::string* release_glversion();
  inline void set_allocated_glversion(::std::string* glversion);

  // optional string DeviceId = 20;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 20;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerRegister];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_player_register)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_vgameappid();
  inline void clear_has_vgameappid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_izoneareaid();
  inline void clear_has_izoneareaid();
  inline void set_has_vopenid();
  inline void clear_has_vopenid();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_systemsoftware();
  inline void clear_has_systemsoftware();
  inline void set_has_systemhardware();
  inline void clear_has_systemhardware();
  inline void set_has_telecomoper();
  inline void clear_has_telecomoper();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_screenwidth();
  inline void clear_has_screenwidth();
  inline void set_has_screenhight();
  inline void clear_has_screenhight();
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_regchannel();
  inline void clear_has_regchannel();
  inline void set_has_cpuhardware();
  inline void clear_has_cpuhardware();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_glrender();
  inline void clear_has_glrender();
  inline void set_has_glversion();
  inline void clear_has_glversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* vgameappid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 izoneareaid_;
  ::std::string* vopenid_;
  ::std::string* clientversion_;
  ::std::string* systemsoftware_;
  ::std::string* systemhardware_;
  ::std::string* telecomoper_;
  ::std::string* network_;
  ::google::protobuf::int32 screenwidth_;
  ::google::protobuf::int32 screenhight_;
  float density_;
  ::google::protobuf::int32 regchannel_;
  ::std::string* cpuhardware_;
  ::std::string* glrender_;
  ::std::string* glversion_;
  ::google::protobuf::int32 memory_;
  int type_;
  ::std::string* deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_player_register* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_player_login : public ::google::protobuf::Message {
 public:
  log_gather_player_login();
  virtual ~log_gather_player_login();

  log_gather_player_login(const log_gather_player_login& from);

  inline log_gather_player_login& operator=(const log_gather_player_login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_player_login& default_instance();

  void Swap(log_gather_player_login* other);

  // implements Message ----------------------------------------------

  log_gather_player_login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_player_login& from);
  void MergeFrom(const log_gather_player_login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string GameAppID = 3;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 3;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional string OpenID = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIDFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional int32 Level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 PlayerFriendsNum = 6;
  inline bool has_playerfriendsnum() const;
  inline void clear_playerfriendsnum();
  static const int kPlayerFriendsNumFieldNumber = 6;
  inline ::google::protobuf::int32 playerfriendsnum() const;
  inline void set_playerfriendsnum(::google::protobuf::int32 value);

  // optional int32 PlatID = 7;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 7;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional string ClientVersion = 8;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 8;
  inline const ::std::string& clientversion() const;
  inline void set_clientversion(const ::std::string& value);
  inline void set_clientversion(const char* value);
  inline void set_clientversion(const char* value, size_t size);
  inline ::std::string* mutable_clientversion();
  inline ::std::string* release_clientversion();
  inline void set_allocated_clientversion(::std::string* clientversion);

  // optional string SystemSoftware = 9;
  inline bool has_systemsoftware() const;
  inline void clear_systemsoftware();
  static const int kSystemSoftwareFieldNumber = 9;
  inline const ::std::string& systemsoftware() const;
  inline void set_systemsoftware(const ::std::string& value);
  inline void set_systemsoftware(const char* value);
  inline void set_systemsoftware(const char* value, size_t size);
  inline ::std::string* mutable_systemsoftware();
  inline ::std::string* release_systemsoftware();
  inline void set_allocated_systemsoftware(::std::string* systemsoftware);

  // optional string SystemHardware = 10;
  inline bool has_systemhardware() const;
  inline void clear_systemhardware();
  static const int kSystemHardwareFieldNumber = 10;
  inline const ::std::string& systemhardware() const;
  inline void set_systemhardware(const ::std::string& value);
  inline void set_systemhardware(const char* value);
  inline void set_systemhardware(const char* value, size_t size);
  inline ::std::string* mutable_systemhardware();
  inline ::std::string* release_systemhardware();
  inline void set_allocated_systemhardware(::std::string* systemhardware);

  // optional string TelecomOper = 11;
  inline bool has_telecomoper() const;
  inline void clear_telecomoper();
  static const int kTelecomOperFieldNumber = 11;
  inline const ::std::string& telecomoper() const;
  inline void set_telecomoper(const ::std::string& value);
  inline void set_telecomoper(const char* value);
  inline void set_telecomoper(const char* value, size_t size);
  inline ::std::string* mutable_telecomoper();
  inline ::std::string* release_telecomoper();
  inline void set_allocated_telecomoper(::std::string* telecomoper);

  // optional string Network = 12;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 12;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional int32 ScreenWidth = 13;
  inline bool has_screenwidth() const;
  inline void clear_screenwidth();
  static const int kScreenWidthFieldNumber = 13;
  inline ::google::protobuf::int32 screenwidth() const;
  inline void set_screenwidth(::google::protobuf::int32 value);

  // optional int32 ScreenHight = 14;
  inline bool has_screenhight() const;
  inline void clear_screenhight();
  static const int kScreenHightFieldNumber = 14;
  inline ::google::protobuf::int32 screenhight() const;
  inline void set_screenhight(::google::protobuf::int32 value);

  // optional float Density = 15;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 15;
  inline float density() const;
  inline void set_density(float value);

  // optional int32 LoginChannel = 16;
  inline bool has_loginchannel() const;
  inline void clear_loginchannel();
  static const int kLoginChannelFieldNumber = 16;
  inline ::google::protobuf::int32 loginchannel() const;
  inline void set_loginchannel(::google::protobuf::int32 value);

  // optional string CpuHardware = 17;
  inline bool has_cpuhardware() const;
  inline void clear_cpuhardware();
  static const int kCpuHardwareFieldNumber = 17;
  inline const ::std::string& cpuhardware() const;
  inline void set_cpuhardware(const ::std::string& value);
  inline void set_cpuhardware(const char* value);
  inline void set_cpuhardware(const char* value, size_t size);
  inline ::std::string* mutable_cpuhardware();
  inline ::std::string* release_cpuhardware();
  inline void set_allocated_cpuhardware(::std::string* cpuhardware);

  // optional int32 Memory = 18;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 18;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);

  // optional string GLRender = 19;
  inline bool has_glrender() const;
  inline void clear_glrender();
  static const int kGLRenderFieldNumber = 19;
  inline const ::std::string& glrender() const;
  inline void set_glrender(const ::std::string& value);
  inline void set_glrender(const char* value);
  inline void set_glrender(const char* value, size_t size);
  inline ::std::string* mutable_glrender();
  inline ::std::string* release_glrender();
  inline void set_allocated_glrender(::std::string* glrender);

  // optional string GLVersion = 20;
  inline bool has_glversion() const;
  inline void clear_glversion();
  static const int kGLVersionFieldNumber = 20;
  inline const ::std::string& glversion() const;
  inline void set_glversion(const ::std::string& value);
  inline void set_glversion(const char* value);
  inline void set_glversion(const char* value, size_t size);
  inline ::std::string* mutable_glversion();
  inline ::std::string* release_glversion();
  inline void set_allocated_glversion(::std::string* glversion);

  // optional string DeviceId = 21;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 21;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerLogin];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_player_login)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_playerfriendsnum();
  inline void clear_has_playerfriendsnum();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_systemsoftware();
  inline void clear_has_systemsoftware();
  inline void set_has_systemhardware();
  inline void clear_has_systemhardware();
  inline void set_has_telecomoper();
  inline void clear_has_telecomoper();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_screenwidth();
  inline void clear_has_screenwidth();
  inline void set_has_screenhight();
  inline void clear_has_screenhight();
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_loginchannel();
  inline void clear_has_loginchannel();
  inline void set_has_cpuhardware();
  inline void clear_has_cpuhardware();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_glrender();
  inline void clear_has_glrender();
  inline void set_has_glversion();
  inline void clear_has_glversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::std::string* openid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 playerfriendsnum_;
  ::std::string* clientversion_;
  ::std::string* systemsoftware_;
  ::std::string* systemhardware_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 screenwidth_;
  ::std::string* telecomoper_;
  ::std::string* network_;
  ::google::protobuf::int32 screenhight_;
  float density_;
  ::std::string* cpuhardware_;
  ::google::protobuf::int32 loginchannel_;
  ::google::protobuf::int32 memory_;
  ::std::string* glrender_;
  ::std::string* glversion_;
  ::std::string* deviceid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_player_login* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_player_logout : public ::google::protobuf::Message {
 public:
  log_gather_player_logout();
  virtual ~log_gather_player_logout();

  log_gather_player_logout(const log_gather_player_logout& from);

  inline log_gather_player_logout& operator=(const log_gather_player_logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_player_logout& default_instance();

  void Swap(log_gather_player_logout* other);

  // implements Message ----------------------------------------------

  log_gather_player_logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_player_logout& from);
  void MergeFrom(const log_gather_player_logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string GameAppID = 3;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 3;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional string OpenID = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIDFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional int32 OnlineTime = 5;
  inline bool has_onlinetime() const;
  inline void clear_onlinetime();
  static const int kOnlineTimeFieldNumber = 5;
  inline ::google::protobuf::int32 onlinetime() const;
  inline void set_onlinetime(::google::protobuf::int32 value);

  // optional int32 Level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 PlayerFriendsNum = 7;
  inline bool has_playerfriendsnum() const;
  inline void clear_playerfriendsnum();
  static const int kPlayerFriendsNumFieldNumber = 7;
  inline ::google::protobuf::int32 playerfriendsnum() const;
  inline void set_playerfriendsnum(::google::protobuf::int32 value);

  // optional int32 PlatID = 8;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 8;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional string ClientVersion = 9;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 9;
  inline const ::std::string& clientversion() const;
  inline void set_clientversion(const ::std::string& value);
  inline void set_clientversion(const char* value);
  inline void set_clientversion(const char* value, size_t size);
  inline ::std::string* mutable_clientversion();
  inline ::std::string* release_clientversion();
  inline void set_allocated_clientversion(::std::string* clientversion);

  // optional string SystemSoftware = 10;
  inline bool has_systemsoftware() const;
  inline void clear_systemsoftware();
  static const int kSystemSoftwareFieldNumber = 10;
  inline const ::std::string& systemsoftware() const;
  inline void set_systemsoftware(const ::std::string& value);
  inline void set_systemsoftware(const char* value);
  inline void set_systemsoftware(const char* value, size_t size);
  inline ::std::string* mutable_systemsoftware();
  inline ::std::string* release_systemsoftware();
  inline void set_allocated_systemsoftware(::std::string* systemsoftware);

  // optional string SystemHardware = 11;
  inline bool has_systemhardware() const;
  inline void clear_systemhardware();
  static const int kSystemHardwareFieldNumber = 11;
  inline const ::std::string& systemhardware() const;
  inline void set_systemhardware(const ::std::string& value);
  inline void set_systemhardware(const char* value);
  inline void set_systemhardware(const char* value, size_t size);
  inline ::std::string* mutable_systemhardware();
  inline ::std::string* release_systemhardware();
  inline void set_allocated_systemhardware(::std::string* systemhardware);

  // optional string TelecomOper = 12;
  inline bool has_telecomoper() const;
  inline void clear_telecomoper();
  static const int kTelecomOperFieldNumber = 12;
  inline const ::std::string& telecomoper() const;
  inline void set_telecomoper(const ::std::string& value);
  inline void set_telecomoper(const char* value);
  inline void set_telecomoper(const char* value, size_t size);
  inline ::std::string* mutable_telecomoper();
  inline ::std::string* release_telecomoper();
  inline void set_allocated_telecomoper(::std::string* telecomoper);

  // optional string Network = 13;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 13;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional int32 ScreenWidth = 14;
  inline bool has_screenwidth() const;
  inline void clear_screenwidth();
  static const int kScreenWidthFieldNumber = 14;
  inline ::google::protobuf::int32 screenwidth() const;
  inline void set_screenwidth(::google::protobuf::int32 value);

  // optional int32 ScreenHight = 15;
  inline bool has_screenhight() const;
  inline void clear_screenhight();
  static const int kScreenHightFieldNumber = 15;
  inline ::google::protobuf::int32 screenhight() const;
  inline void set_screenhight(::google::protobuf::int32 value);

  // optional float Density = 16;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 16;
  inline float density() const;
  inline void set_density(float value);

  // optional int32 LoginChannel = 17;
  inline bool has_loginchannel() const;
  inline void clear_loginchannel();
  static const int kLoginChannelFieldNumber = 17;
  inline ::google::protobuf::int32 loginchannel() const;
  inline void set_loginchannel(::google::protobuf::int32 value);

  // optional string CpuHardware = 18;
  inline bool has_cpuhardware() const;
  inline void clear_cpuhardware();
  static const int kCpuHardwareFieldNumber = 18;
  inline const ::std::string& cpuhardware() const;
  inline void set_cpuhardware(const ::std::string& value);
  inline void set_cpuhardware(const char* value);
  inline void set_cpuhardware(const char* value, size_t size);
  inline ::std::string* mutable_cpuhardware();
  inline ::std::string* release_cpuhardware();
  inline void set_allocated_cpuhardware(::std::string* cpuhardware);

  // optional int32 Memory = 19;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 19;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);

  // optional string GLRender = 20;
  inline bool has_glrender() const;
  inline void clear_glrender();
  static const int kGLRenderFieldNumber = 20;
  inline const ::std::string& glrender() const;
  inline void set_glrender(const ::std::string& value);
  inline void set_glrender(const char* value);
  inline void set_glrender(const char* value, size_t size);
  inline ::std::string* mutable_glrender();
  inline ::std::string* release_glrender();
  inline void set_allocated_glrender(::std::string* glrender);

  // optional string GLVersion = 21;
  inline bool has_glversion() const;
  inline void clear_glversion();
  static const int kGLVersionFieldNumber = 21;
  inline const ::std::string& glversion() const;
  inline void set_glversion(const ::std::string& value);
  inline void set_glversion(const char* value);
  inline void set_glversion(const char* value, size_t size);
  inline ::std::string* mutable_glversion();
  inline ::std::string* release_glversion();
  inline void set_allocated_glversion(::std::string* glversion);

  // optional string DeviceId = 22;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 22;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerLogout];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_player_logout)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_onlinetime();
  inline void clear_has_onlinetime();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_playerfriendsnum();
  inline void clear_has_playerfriendsnum();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_systemsoftware();
  inline void clear_has_systemsoftware();
  inline void set_has_systemhardware();
  inline void clear_has_systemhardware();
  inline void set_has_telecomoper();
  inline void clear_has_telecomoper();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_screenwidth();
  inline void clear_has_screenwidth();
  inline void set_has_screenhight();
  inline void clear_has_screenhight();
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_loginchannel();
  inline void clear_has_loginchannel();
  inline void set_has_cpuhardware();
  inline void clear_has_cpuhardware();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_glrender();
  inline void clear_has_glrender();
  inline void set_has_glversion();
  inline void clear_has_glversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::std::string* openid_;
  ::google::protobuf::int32 onlinetime_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 playerfriendsnum_;
  ::google::protobuf::int32 platid_;
  ::std::string* clientversion_;
  ::std::string* systemsoftware_;
  ::std::string* systemhardware_;
  ::std::string* telecomoper_;
  ::std::string* network_;
  ::google::protobuf::int32 screenwidth_;
  ::google::protobuf::int32 screenhight_;
  float density_;
  ::google::protobuf::int32 loginchannel_;
  ::std::string* cpuhardware_;
  ::std::string* glrender_;
  ::std::string* glversion_;
  ::google::protobuf::int32 memory_;
  int type_;
  ::std::string* deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_player_logout* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_money_flow : public ::google::protobuf::Message {
 public:
  log_gather_money_flow();
  virtual ~log_gather_money_flow();

  log_gather_money_flow(const log_gather_money_flow& from);

  inline log_gather_money_flow& operator=(const log_gather_money_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_money_flow& default_instance();

  void Swap(log_gather_money_flow* other);

  // implements Message ----------------------------------------------

  log_gather_money_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_money_flow& from);
  void MergeFrom(const log_gather_money_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string vGameAppID = 3;
  inline bool has_vgameappid() const;
  inline void clear_vgameappid();
  static const int kVGameAppIDFieldNumber = 3;
  inline const ::std::string& vgameappid() const;
  inline void set_vgameappid(const ::std::string& value);
  inline void set_vgameappid(const char* value);
  inline void set_vgameappid(const char* value, size_t size);
  inline ::std::string* mutable_vgameappid();
  inline ::std::string* release_vgameappid();
  inline void set_allocated_vgameappid(::std::string* vgameappid);

  // optional int32 PlatID = 4;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 4;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 iZoneAreaID = 5;
  inline bool has_izoneareaid() const;
  inline void clear_izoneareaid();
  static const int kIZoneAreaIDFieldNumber = 5;
  inline ::google::protobuf::int32 izoneareaid() const;
  inline void set_izoneareaid(::google::protobuf::int32 value);

  // optional string vopenid = 6;
  inline bool has_vopenid() const;
  inline void clear_vopenid();
  static const int kVopenidFieldNumber = 6;
  inline const ::std::string& vopenid() const;
  inline void set_vopenid(const ::std::string& value);
  inline void set_vopenid(const char* value);
  inline void set_vopenid(const char* value, size_t size);
  inline ::std::string* mutable_vopenid();
  inline ::std::string* release_vopenid();
  inline void set_allocated_vopenid(::std::string* vopenid);

  // optional int32 Sequence = 8;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 8;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);

  // optional int32 Level = 9;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 9;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 AfterMOney = 10;
  inline bool has_aftermoney() const;
  inline void clear_aftermoney();
  static const int kAfterMOneyFieldNumber = 10;
  inline ::google::protobuf::int32 aftermoney() const;
  inline void set_aftermoney(::google::protobuf::int32 value);

  // optional int32 iMoney = 11;
  inline bool has_imoney() const;
  inline void clear_imoney();
  static const int kIMoneyFieldNumber = 11;
  inline ::google::protobuf::int32 imoney() const;
  inline void set_imoney(::google::protobuf::int32 value);

  // optional int32 Reason = 12;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 12;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // optional int32 SubReason = 13;
  inline bool has_subreason() const;
  inline void clear_subreason();
  static const int kSubReasonFieldNumber = 13;
  inline ::google::protobuf::int32 subreason() const;
  inline void set_subreason(::google::protobuf::int32 value);

  // optional int32 AddOrReduce = 14;
  inline bool has_addorreduce() const;
  inline void clear_addorreduce();
  static const int kAddOrReduceFieldNumber = 14;
  inline ::google::protobuf::int32 addorreduce() const;
  inline void set_addorreduce(::google::protobuf::int32 value);

  // optional int32 iMoneyType = 15;
  inline bool has_imoneytype() const;
  inline void clear_imoneytype();
  static const int kIMoneyTypeFieldNumber = 15;
  inline ::google::protobuf::int32 imoneytype() const;
  inline void set_imoneytype(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_MoneyFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_money_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_vgameappid();
  inline void clear_has_vgameappid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_izoneareaid();
  inline void clear_has_izoneareaid();
  inline void set_has_vopenid();
  inline void clear_has_vopenid();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_aftermoney();
  inline void clear_has_aftermoney();
  inline void set_has_imoney();
  inline void clear_has_imoney();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_subreason();
  inline void clear_has_subreason();
  inline void set_has_addorreduce();
  inline void clear_has_addorreduce();
  inline void set_has_imoneytype();
  inline void clear_has_imoneytype();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* vgameappid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 izoneareaid_;
  ::std::string* vopenid_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 aftermoney_;
  ::google::protobuf::int32 imoney_;
  ::google::protobuf::int32 reason_;
  ::google::protobuf::int32 subreason_;
  ::google::protobuf::int32 addorreduce_;
  ::google::protobuf::int32 imoneytype_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_money_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_item_flow : public ::google::protobuf::Message {
 public:
  log_gather_item_flow();
  virtual ~log_gather_item_flow();

  log_gather_item_flow(const log_gather_item_flow& from);

  inline log_gather_item_flow& operator=(const log_gather_item_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_item_flow& default_instance();

  void Swap(log_gather_item_flow* other);

  // implements Message ----------------------------------------------

  log_gather_item_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_item_flow& from);
  void MergeFrom(const log_gather_item_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string vGameAppID = 3;
  inline bool has_vgameappid() const;
  inline void clear_vgameappid();
  static const int kVGameAppIDFieldNumber = 3;
  inline const ::std::string& vgameappid() const;
  inline void set_vgameappid(const ::std::string& value);
  inline void set_vgameappid(const char* value);
  inline void set_vgameappid(const char* value, size_t size);
  inline ::std::string* mutable_vgameappid();
  inline ::std::string* release_vgameappid();
  inline void set_allocated_vgameappid(::std::string* vgameappid);

  // optional int32 PlatID = 4;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 4;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 iZoneAreaID = 5;
  inline bool has_izoneareaid() const;
  inline void clear_izoneareaid();
  static const int kIZoneAreaIDFieldNumber = 5;
  inline ::google::protobuf::int32 izoneareaid() const;
  inline void set_izoneareaid(::google::protobuf::int32 value);

  // optional string vopenid = 6;
  inline bool has_vopenid() const;
  inline void clear_vopenid();
  static const int kVopenidFieldNumber = 6;
  inline const ::std::string& vopenid() const;
  inline void set_vopenid(const ::std::string& value);
  inline void set_vopenid(const char* value);
  inline void set_vopenid(const char* value, size_t size);
  inline ::std::string* mutable_vopenid();
  inline ::std::string* release_vopenid();
  inline void set_allocated_vopenid(::std::string* vopenid);

  // optional int32 Level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 Sequence = 8;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 8;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);

  // optional int32 iGoodsType = 9;
  inline bool has_igoodstype() const;
  inline void clear_igoodstype();
  static const int kIGoodsTypeFieldNumber = 9;
  inline ::google::protobuf::int32 igoodstype() const;
  inline void set_igoodstype(::google::protobuf::int32 value);

  // optional int32 iGoodsId = 10;
  inline bool has_igoodsid() const;
  inline void clear_igoodsid();
  static const int kIGoodsIdFieldNumber = 10;
  inline ::google::protobuf::int32 igoodsid() const;
  inline void set_igoodsid(::google::protobuf::int32 value);

  // optional int32 Count = 11;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 11;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 AfterCount = 12;
  inline bool has_aftercount() const;
  inline void clear_aftercount();
  static const int kAfterCountFieldNumber = 12;
  inline ::google::protobuf::int32 aftercount() const;
  inline void set_aftercount(::google::protobuf::int32 value);

  // optional int32 Reason = 13;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 13;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // optional int32 SubReason = 14;
  inline bool has_subreason() const;
  inline void clear_subreason();
  static const int kSubReasonFieldNumber = 14;
  inline ::google::protobuf::int32 subreason() const;
  inline void set_subreason(::google::protobuf::int32 value);

  // optional int32 iMoney = 15;
  inline bool has_imoney() const;
  inline void clear_imoney();
  static const int kIMoneyFieldNumber = 15;
  inline ::google::protobuf::int32 imoney() const;
  inline void set_imoney(::google::protobuf::int32 value);

  // optional int32 iMoneyType = 16;
  inline bool has_imoneytype() const;
  inline void clear_imoneytype();
  static const int kIMoneyTypeFieldNumber = 16;
  inline ::google::protobuf::int32 imoneytype() const;
  inline void set_imoneytype(::google::protobuf::int32 value);

  // optional int32 AddOrReduce = 17;
  inline bool has_addorreduce() const;
  inline void clear_addorreduce();
  static const int kAddOrReduceFieldNumber = 17;
  inline ::google::protobuf::int32 addorreduce() const;
  inline void set_addorreduce(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_ItemFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_item_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_vgameappid();
  inline void clear_has_vgameappid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_izoneareaid();
  inline void clear_has_izoneareaid();
  inline void set_has_vopenid();
  inline void clear_has_vopenid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_igoodstype();
  inline void clear_has_igoodstype();
  inline void set_has_igoodsid();
  inline void clear_has_igoodsid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_aftercount();
  inline void clear_has_aftercount();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_subreason();
  inline void clear_has_subreason();
  inline void set_has_imoney();
  inline void clear_has_imoney();
  inline void set_has_imoneytype();
  inline void clear_has_imoneytype();
  inline void set_has_addorreduce();
  inline void clear_has_addorreduce();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* vgameappid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 izoneareaid_;
  ::std::string* vopenid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 igoodstype_;
  ::google::protobuf::int32 igoodsid_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 aftercount_;
  ::google::protobuf::int32 reason_;
  ::google::protobuf::int32 subreason_;
  ::google::protobuf::int32 imoney_;
  ::google::protobuf::int32 imoneytype_;
  ::google::protobuf::int32 addorreduce_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_item_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_item_money_flow : public ::google::protobuf::Message {
 public:
  log_gather_item_money_flow();
  virtual ~log_gather_item_money_flow();

  log_gather_item_money_flow(const log_gather_item_money_flow& from);

  inline log_gather_item_money_flow& operator=(const log_gather_item_money_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_item_money_flow& default_instance();

  void Swap(log_gather_item_money_flow* other);

  // implements Message ----------------------------------------------

  log_gather_item_money_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_item_money_flow& from);
  void MergeFrom(const log_gather_item_money_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional int32 Sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);

  // optional string GameAppID = 4;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 4;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional string OpenID = 5;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIDFieldNumber = 5;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional int32 PlatID = 6;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 6;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 ItemType = 7;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 7;
  inline ::google::protobuf::int32 itemtype() const;
  inline void set_itemtype(::google::protobuf::int32 value);

  // optional int32 ItemId = 8;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 8;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 Count = 9;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 9;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 Money = 10;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 10;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 Level = 11;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 11;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 MoneyType = 12;
  inline bool has_moneytype() const;
  inline void clear_moneytype();
  static const int kMoneyTypeFieldNumber = 12;
  inline ::google::protobuf::int32 moneytype() const;
  inline void set_moneytype(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_ItemMoneyFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_item_money_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_moneytype();
  inline void clear_has_moneytype();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 platid_;
  ::std::string* openid_;
  ::google::protobuf::int32 itemtype_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 moneytype_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_item_money_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_player_exp_flow : public ::google::protobuf::Message {
 public:
  log_gather_player_exp_flow();
  virtual ~log_gather_player_exp_flow();

  log_gather_player_exp_flow(const log_gather_player_exp_flow& from);

  inline log_gather_player_exp_flow& operator=(const log_gather_player_exp_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_player_exp_flow& default_instance();

  void Swap(log_gather_player_exp_flow* other);

  // implements Message ----------------------------------------------

  log_gather_player_exp_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_player_exp_flow& from);
  void MergeFrom(const log_gather_player_exp_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string GameAppID = 3;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 3;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional string OpenID = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIDFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional int32 PlatID = 5;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 5;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 ExpChange = 6;
  inline bool has_expchange() const;
  inline void clear_expchange();
  static const int kExpChangeFieldNumber = 6;
  inline ::google::protobuf::int32 expchange() const;
  inline void set_expchange(::google::protobuf::int32 value);

  // optional int32 BeforeLevel = 7;
  inline bool has_beforelevel() const;
  inline void clear_beforelevel();
  static const int kBeforeLevelFieldNumber = 7;
  inline ::google::protobuf::int32 beforelevel() const;
  inline void set_beforelevel(::google::protobuf::int32 value);

  // optional int32 AfterLevel = 8;
  inline bool has_afterlevel() const;
  inline void clear_afterlevel();
  static const int kAfterLevelFieldNumber = 8;
  inline ::google::protobuf::int32 afterlevel() const;
  inline void set_afterlevel(::google::protobuf::int32 value);

  // optional int32 Time = 9;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 9;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 Reason = 10;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 10;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // optional int32 SubReason = 11;
  inline bool has_subreason() const;
  inline void clear_subreason();
  static const int kSubReasonFieldNumber = 11;
  inline ::google::protobuf::int32 subreason() const;
  inline void set_subreason(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerExpFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_player_exp_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_expchange();
  inline void clear_has_expchange();
  inline void set_has_beforelevel();
  inline void clear_has_beforelevel();
  inline void set_has_afterlevel();
  inline void clear_has_afterlevel();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_subreason();
  inline void clear_has_subreason();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::std::string* openid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 expchange_;
  ::google::protobuf::int32 beforelevel_;
  ::google::protobuf::int32 afterlevel_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 reason_;
  ::google::protobuf::int32 subreason_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_player_exp_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_sns_flow : public ::google::protobuf::Message {
 public:
  log_gather_sns_flow();
  virtual ~log_gather_sns_flow();

  log_gather_sns_flow(const log_gather_sns_flow& from);

  inline log_gather_sns_flow& operator=(const log_gather_sns_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_sns_flow& default_instance();

  void Swap(log_gather_sns_flow* other);

  // implements Message ----------------------------------------------

  log_gather_sns_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_sns_flow& from);
  void MergeFrom(const log_gather_sns_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string GameAppID = 3;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 3;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional int32 PlatID = 4;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 4;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional string ActorOpenID = 5;
  inline bool has_actoropenid() const;
  inline void clear_actoropenid();
  static const int kActorOpenIDFieldNumber = 5;
  inline const ::std::string& actoropenid() const;
  inline void set_actoropenid(const ::std::string& value);
  inline void set_actoropenid(const char* value);
  inline void set_actoropenid(const char* value, size_t size);
  inline ::std::string* mutable_actoropenid();
  inline ::std::string* release_actoropenid();
  inline void set_allocated_actoropenid(::std::string* actoropenid);

  // optional int32 RecNum = 6;
  inline bool has_recnum() const;
  inline void clear_recnum();
  static const int kRecNumFieldNumber = 6;
  inline ::google::protobuf::int32 recnum() const;
  inline void set_recnum(::google::protobuf::int32 value);

  // optional int32 Count = 7;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 7;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 SNSType = 8;
  inline bool has_snstype() const;
  inline void clear_snstype();
  static const int kSNSTypeFieldNumber = 8;
  inline ::google::protobuf::int32 snstype() const;
  inline void set_snstype(::google::protobuf::int32 value);

  // optional int32 SNSSubType = 9;
  inline bool has_snssubtype() const;
  inline void clear_snssubtype();
  static const int kSNSSubTypeFieldNumber = 9;
  inline ::google::protobuf::int32 snssubtype() const;
  inline void set_snssubtype(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_SnsFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_sns_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_actoropenid();
  inline void clear_has_actoropenid();
  inline void set_has_recnum();
  inline void clear_has_recnum();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_snstype();
  inline void clear_has_snstype();
  inline void set_has_snssubtype();
  inline void clear_has_snssubtype();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::std::string* actoropenid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 recnum_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 snstype_;
  ::google::protobuf::int32 snssubtype_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_sns_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_round_flow : public ::google::protobuf::Message {
 public:
  log_gather_round_flow();
  virtual ~log_gather_round_flow();

  log_gather_round_flow(const log_gather_round_flow& from);

  inline log_gather_round_flow& operator=(const log_gather_round_flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_round_flow& default_instance();

  void Swap(log_gather_round_flow* other);

  // implements Message ----------------------------------------------

  log_gather_round_flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_round_flow& from);
  void MergeFrom(const log_gather_round_flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GameSvrId = 1;
  inline bool has_gamesvrid() const;
  inline void clear_gamesvrid();
  static const int kGameSvrIdFieldNumber = 1;
  inline const ::std::string& gamesvrid() const;
  inline void set_gamesvrid(const ::std::string& value);
  inline void set_gamesvrid(const char* value);
  inline void set_gamesvrid(const char* value, size_t size);
  inline ::std::string* mutable_gamesvrid();
  inline ::std::string* release_gamesvrid();
  inline void set_allocated_gamesvrid(::std::string* gamesvrid);

  // optional string dtEventTime = 2;
  inline bool has_dteventtime() const;
  inline void clear_dteventtime();
  static const int kDtEventTimeFieldNumber = 2;
  inline const ::std::string& dteventtime() const;
  inline void set_dteventtime(const ::std::string& value);
  inline void set_dteventtime(const char* value);
  inline void set_dteventtime(const char* value, size_t size);
  inline ::std::string* mutable_dteventtime();
  inline ::std::string* release_dteventtime();
  inline void set_allocated_dteventtime(::std::string* dteventtime);

  // optional string GameAppID = 3;
  inline bool has_gameappid() const;
  inline void clear_gameappid();
  static const int kGameAppIDFieldNumber = 3;
  inline const ::std::string& gameappid() const;
  inline void set_gameappid(const ::std::string& value);
  inline void set_gameappid(const char* value);
  inline void set_gameappid(const char* value, size_t size);
  inline ::std::string* mutable_gameappid();
  inline ::std::string* release_gameappid();
  inline void set_allocated_gameappid(::std::string* gameappid);

  // optional string OpenID = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenIDFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional int32 PlatID = 5;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatIDFieldNumber = 5;
  inline ::google::protobuf::int32 platid() const;
  inline void set_platid(::google::protobuf::int32 value);

  // optional int32 BattleID = 6;
  inline bool has_battleid() const;
  inline void clear_battleid();
  static const int kBattleIDFieldNumber = 6;
  inline ::google::protobuf::int32 battleid() const;
  inline void set_battleid(::google::protobuf::int32 value);

  // optional int32 BattleType = 7;
  inline bool has_battletype() const;
  inline void clear_battletype();
  static const int kBattleTypeFieldNumber = 7;
  inline ::google::protobuf::int32 battletype() const;
  inline void set_battletype(::google::protobuf::int32 value);

  // optional int32 RoundScore = 8;
  inline bool has_roundscore() const;
  inline void clear_roundscore();
  static const int kRoundScoreFieldNumber = 8;
  inline ::google::protobuf::int32 roundscore() const;
  inline void set_roundscore(::google::protobuf::int32 value);

  // optional int32 RoundTime = 9;
  inline bool has_roundtime() const;
  inline void clear_roundtime();
  static const int kRoundTimeFieldNumber = 9;
  inline ::google::protobuf::int32 roundtime() const;
  inline void set_roundtime(::google::protobuf::int32 value);

  // optional int32 Result = 10;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 10;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 Rank = 11;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 11;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 Gold = 12;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 12;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_RoundFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 100;
  inline ::SProtoSpace::EConomicAnalysisType type() const;
  inline void set_type(::SProtoSpace::EConomicAnalysisType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_round_flow)
 private:
  inline void set_has_gamesvrid();
  inline void clear_has_gamesvrid();
  inline void set_has_dteventtime();
  inline void clear_has_dteventtime();
  inline void set_has_gameappid();
  inline void clear_has_gameappid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_battleid();
  inline void clear_has_battleid();
  inline void set_has_battletype();
  inline void clear_has_battletype();
  inline void set_has_roundscore();
  inline void clear_has_roundscore();
  inline void set_has_roundtime();
  inline void clear_has_roundtime();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gamesvrid_;
  ::std::string* dteventtime_;
  ::std::string* gameappid_;
  ::std::string* openid_;
  ::google::protobuf::int32 platid_;
  ::google::protobuf::int32 battleid_;
  ::google::protobuf::int32 battletype_;
  ::google::protobuf::int32 roundscore_;
  ::google::protobuf::int32 roundtime_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 gold_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_round_flow* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_role_info : public ::google::protobuf::Message {
 public:
  log_gather_role_info();
  virtual ~log_gather_role_info();

  log_gather_role_info(const log_gather_role_info& from);

  inline log_gather_role_info& operator=(const log_gather_role_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_role_info& default_instance();

  void Swap(log_gather_role_info* other);

  // implements Message ----------------------------------------------

  log_gather_role_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_role_info& from);
  void MergeFrom(const log_gather_role_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1 [default = 1];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint64 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional string appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 zone_id = 5;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 5;
  inline ::google::protobuf::uint32 zone_id() const;
  inline void set_zone_id(::google::protobuf::uint32 value);

  // optional string zone_name = 6;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 6;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  inline void set_allocated_zone_name(::std::string* zone_name);

  // optional uint32 platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline ::google::protobuf::uint32 platform() const;
  inline void set_platform(::google::protobuf::uint32 value);

  // optional string imei = 8;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 8;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 level = 9;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 fight_value = 11;
  inline bool has_fight_value() const;
  inline void clear_fight_value();
  static const int kFightValueFieldNumber = 11;
  inline ::google::protobuf::uint64 fight_value() const;
  inline void set_fight_value(::google::protobuf::uint64 value);

  // optional string profession = 12;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 12;
  inline const ::std::string& profession() const;
  inline void set_profession(const ::std::string& value);
  inline void set_profession(const char* value);
  inline void set_profession(const char* value, size_t size);
  inline ::std::string* mutable_profession();
  inline ::std::string* release_profession();
  inline void set_allocated_profession(::std::string* profession);

  // optional uint32 pay_total = 13;
  inline bool has_pay_total() const;
  inline void clear_pay_total();
  static const int kPayTotalFieldNumber = 13;
  inline ::google::protobuf::uint32 pay_total() const;
  inline void set_pay_total(::google::protobuf::uint32 value);

  // optional uint32 coin_1 = 14;
  inline bool has_coin_1() const;
  inline void clear_coin_1();
  static const int kCoin1FieldNumber = 14;
  inline ::google::protobuf::uint32 coin_1() const;
  inline void set_coin_1(::google::protobuf::uint32 value);

  // optional uint32 coin_2 = 15;
  inline bool has_coin_2() const;
  inline void clear_coin_2();
  static const int kCoin2FieldNumber = 15;
  inline ::google::protobuf::uint32 coin_2() const;
  inline void set_coin_2(::google::protobuf::uint32 value);

  // optional uint32 vip_level = 16;
  inline bool has_vip_level() const;
  inline void clear_vip_level();
  static const int kVipLevelFieldNumber = 16;
  inline ::google::protobuf::uint32 vip_level() const;
  inline void set_vip_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_role_info)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fight_value();
  inline void clear_has_fight_value();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_pay_total();
  inline void clear_has_pay_total();
  inline void set_has_coin_1();
  inline void clear_has_coin_1();
  inline void set_has_coin_2();
  inline void clear_has_coin_2();
  inline void set_has_vip_level();
  inline void clear_has_vip_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_time_;
  ::std::string* appid_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 zone_id_;
  ::std::string* openid_;
  ::std::string* zone_name_;
  ::std::string* imei_;
  ::google::protobuf::uint32 platform_;
  ::google::protobuf::uint32 level_;
  ::std::string* name_;
  ::google::protobuf::uint64 fight_value_;
  ::std::string* profession_;
  ::google::protobuf::uint32 pay_total_;
  ::google::protobuf::uint32 coin_1_;
  ::google::protobuf::uint32 coin_2_;
  ::google::protobuf::uint32 vip_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_role_info* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_task_info : public ::google::protobuf::Message {
 public:
  log_gather_task_info();
  virtual ~log_gather_task_info();

  log_gather_task_info(const log_gather_task_info& from);

  inline log_gather_task_info& operator=(const log_gather_task_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_task_info& default_instance();

  void Swap(log_gather_task_info* other);

  // implements Message ----------------------------------------------

  log_gather_task_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_task_info& from);
  void MergeFrom(const log_gather_task_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1 [default = 2];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint64 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional string appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 zone_id = 5;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 5;
  inline ::google::protobuf::uint32 zone_id() const;
  inline void set_zone_id(::google::protobuf::uint32 value);

  // optional string zone_name = 6;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 6;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  inline void set_allocated_zone_name(::std::string* zone_name);

  // optional uint32 platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline ::google::protobuf::uint32 platform() const;
  inline void set_platform(::google::protobuf::uint32 value);

  // optional string imei = 8;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 8;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 task_id = 9;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 9;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional string task_name = 10;
  inline bool has_task_name() const;
  inline void clear_task_name();
  static const int kTaskNameFieldNumber = 10;
  inline const ::std::string& task_name() const;
  inline void set_task_name(const ::std::string& value);
  inline void set_task_name(const char* value);
  inline void set_task_name(const char* value, size_t size);
  inline ::std::string* mutable_task_name();
  inline ::std::string* release_task_name();
  inline void set_allocated_task_name(::std::string* task_name);

  // optional uint32 status = 11;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 11;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional string task_detail = 12;
  inline bool has_task_detail() const;
  inline void clear_task_detail();
  static const int kTaskDetailFieldNumber = 12;
  inline const ::std::string& task_detail() const;
  inline void set_task_detail(const ::std::string& value);
  inline void set_task_detail(const char* value);
  inline void set_task_detail(const char* value, size_t size);
  inline ::std::string* mutable_task_detail();
  inline ::std::string* release_task_detail();
  inline void set_allocated_task_detail(::std::string* task_detail);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_task_info)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_task_name();
  inline void clear_has_task_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_task_detail();
  inline void clear_has_task_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_time_;
  ::std::string* appid_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 zone_id_;
  ::std::string* openid_;
  ::std::string* zone_name_;
  ::std::string* imei_;
  ::google::protobuf::uint32 platform_;
  ::google::protobuf::uint32 task_id_;
  ::std::string* task_name_;
  ::std::string* task_detail_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_task_info* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_honor_info : public ::google::protobuf::Message {
 public:
  log_gather_honor_info();
  virtual ~log_gather_honor_info();

  log_gather_honor_info(const log_gather_honor_info& from);

  inline log_gather_honor_info& operator=(const log_gather_honor_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_honor_info& default_instance();

  void Swap(log_gather_honor_info* other);

  // implements Message ----------------------------------------------

  log_gather_honor_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_honor_info& from);
  void MergeFrom(const log_gather_honor_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1 [default = 3];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint64 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional string appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 zone_id = 5;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 5;
  inline ::google::protobuf::uint32 zone_id() const;
  inline void set_zone_id(::google::protobuf::uint32 value);

  // optional string zone_name = 6;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 6;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  inline void set_allocated_zone_name(::std::string* zone_name);

  // optional uint32 platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline ::google::protobuf::uint32 platform() const;
  inline void set_platform(::google::protobuf::uint32 value);

  // optional string imei = 8;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 8;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 honor_id = 9;
  inline bool has_honor_id() const;
  inline void clear_honor_id();
  static const int kHonorIdFieldNumber = 9;
  inline ::google::protobuf::uint32 honor_id() const;
  inline void set_honor_id(::google::protobuf::uint32 value);

  // optional string honor_name = 10;
  inline bool has_honor_name() const;
  inline void clear_honor_name();
  static const int kHonorNameFieldNumber = 10;
  inline const ::std::string& honor_name() const;
  inline void set_honor_name(const ::std::string& value);
  inline void set_honor_name(const char* value);
  inline void set_honor_name(const char* value, size_t size);
  inline ::std::string* mutable_honor_name();
  inline ::std::string* release_honor_name();
  inline void set_allocated_honor_name(::std::string* honor_name);

  // optional uint32 honor_detail = 11;
  inline bool has_honor_detail() const;
  inline void clear_honor_detail();
  static const int kHonorDetailFieldNumber = 11;
  inline ::google::protobuf::uint32 honor_detail() const;
  inline void set_honor_detail(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_honor_info)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_honor_id();
  inline void clear_has_honor_id();
  inline void set_has_honor_name();
  inline void clear_has_honor_name();
  inline void set_has_honor_detail();
  inline void clear_has_honor_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_time_;
  ::std::string* appid_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 zone_id_;
  ::std::string* openid_;
  ::std::string* zone_name_;
  ::std::string* imei_;
  ::google::protobuf::uint32 platform_;
  ::google::protobuf::uint32 honor_id_;
  ::std::string* honor_name_;
  ::google::protobuf::uint32 honor_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_honor_info* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_level_up_info : public ::google::protobuf::Message {
 public:
  log_gather_level_up_info();
  virtual ~log_gather_level_up_info();

  log_gather_level_up_info(const log_gather_level_up_info& from);

  inline log_gather_level_up_info& operator=(const log_gather_level_up_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_level_up_info& default_instance();

  void Swap(log_gather_level_up_info* other);

  // implements Message ----------------------------------------------

  log_gather_level_up_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_level_up_info& from);
  void MergeFrom(const log_gather_level_up_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1 [default = 4];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint64 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional string appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 zone_id = 5;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 5;
  inline ::google::protobuf::uint32 zone_id() const;
  inline void set_zone_id(::google::protobuf::uint32 value);

  // optional string zone_name = 6;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 6;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  inline void set_allocated_zone_name(::std::string* zone_name);

  // optional uint32 platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline ::google::protobuf::uint32 platform() const;
  inline void set_platform(::google::protobuf::uint32 value);

  // optional string imei = 8;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 8;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 new_level = 9;
  inline bool has_new_level() const;
  inline void clear_new_level();
  static const int kNewLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 new_level() const;
  inline void set_new_level(::google::protobuf::uint32 value);

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 old_level = 11;
  inline bool has_old_level() const;
  inline void clear_old_level();
  static const int kOldLevelFieldNumber = 11;
  inline ::google::protobuf::uint32 old_level() const;
  inline void set_old_level(::google::protobuf::uint32 value);

  // optional string detail_desc = 12;
  inline bool has_detail_desc() const;
  inline void clear_detail_desc();
  static const int kDetailDescFieldNumber = 12;
  inline const ::std::string& detail_desc() const;
  inline void set_detail_desc(const ::std::string& value);
  inline void set_detail_desc(const char* value);
  inline void set_detail_desc(const char* value, size_t size);
  inline ::std::string* mutable_detail_desc();
  inline ::std::string* release_detail_desc();
  inline void set_allocated_detail_desc(::std::string* detail_desc);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_level_up_info)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_new_level();
  inline void clear_has_new_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_old_level();
  inline void clear_has_old_level();
  inline void set_has_detail_desc();
  inline void clear_has_detail_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_time_;
  ::std::string* appid_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 zone_id_;
  ::std::string* openid_;
  ::std::string* zone_name_;
  ::std::string* imei_;
  ::google::protobuf::uint32 platform_;
  ::google::protobuf::uint32 new_level_;
  ::std::string* name_;
  ::std::string* detail_desc_;
  ::google::protobuf::uint32 old_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_level_up_info* default_instance_;
};
// -------------------------------------------------------------------

class log_gather_buy_info : public ::google::protobuf::Message {
 public:
  log_gather_buy_info();
  virtual ~log_gather_buy_info();

  log_gather_buy_info(const log_gather_buy_info& from);

  inline log_gather_buy_info& operator=(const log_gather_buy_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const log_gather_buy_info& default_instance();

  void Swap(log_gather_buy_info* other);

  // implements Message ----------------------------------------------

  log_gather_buy_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const log_gather_buy_info& from);
  void MergeFrom(const log_gather_buy_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1 [default = 5];
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint64 event_time = 2;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 event_time() const;
  inline void set_event_time(::google::protobuf::uint64 value);

  // optional string appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional uint32 zone_id = 5;
  inline bool has_zone_id() const;
  inline void clear_zone_id();
  static const int kZoneIdFieldNumber = 5;
  inline ::google::protobuf::uint32 zone_id() const;
  inline void set_zone_id(::google::protobuf::uint32 value);

  // optional string zone_name = 6;
  inline bool has_zone_name() const;
  inline void clear_zone_name();
  static const int kZoneNameFieldNumber = 6;
  inline const ::std::string& zone_name() const;
  inline void set_zone_name(const ::std::string& value);
  inline void set_zone_name(const char* value);
  inline void set_zone_name(const char* value, size_t size);
  inline ::std::string* mutable_zone_name();
  inline ::std::string* release_zone_name();
  inline void set_allocated_zone_name(::std::string* zone_name);

  // optional uint32 platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline ::google::protobuf::uint32 platform() const;
  inline void set_platform(::google::protobuf::uint32 value);

  // optional string imei = 8;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 8;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional uint32 level = 9;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 item_id = 11;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 11;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional string item_name = 12;
  inline bool has_item_name() const;
  inline void clear_item_name();
  static const int kItemNameFieldNumber = 12;
  inline const ::std::string& item_name() const;
  inline void set_item_name(const ::std::string& value);
  inline void set_item_name(const char* value);
  inline void set_item_name(const char* value, size_t size);
  inline ::std::string* mutable_item_name();
  inline ::std::string* release_item_name();
  inline void set_allocated_item_name(::std::string* item_name);

  // optional uint32 item_count = 13;
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 13;
  inline ::google::protobuf::uint32 item_count() const;
  inline void set_item_count(::google::protobuf::uint32 value);

  // optional uint32 cost = 14;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 14;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // optional uint32 left_coin = 15;
  inline bool has_left_coin() const;
  inline void clear_left_coin();
  static const int kLeftCoinFieldNumber = 15;
  inline ::google::protobuf::uint32 left_coin() const;
  inline void set_left_coin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.log_gather_buy_info)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_time();
  inline void clear_has_event_time();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_zone_id();
  inline void clear_has_zone_id();
  inline void set_has_zone_name();
  inline void clear_has_zone_name();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_name();
  inline void clear_has_item_name();
  inline void set_has_item_count();
  inline void clear_has_item_count();
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_left_coin();
  inline void clear_has_left_coin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 event_time_;
  ::std::string* appid_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 zone_id_;
  ::std::string* openid_;
  ::std::string* zone_name_;
  ::std::string* imei_;
  ::google::protobuf::uint32 platform_;
  ::google::protobuf::uint32 level_;
  ::std::string* name_;
  ::std::string* item_name_;
  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 item_count_;
  ::google::protobuf::uint32 cost_;
  ::google::protobuf::uint32 left_coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static log_gather_buy_info* default_instance_;
};
// -------------------------------------------------------------------

class allocate_chat_room_req : public ::google::protobuf::Message {
 public:
  allocate_chat_room_req();
  virtual ~allocate_chat_room_req();

  allocate_chat_room_req(const allocate_chat_room_req& from);

  inline allocate_chat_room_req& operator=(const allocate_chat_room_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const allocate_chat_room_req& default_instance();

  void Swap(allocate_chat_room_req* other);

  // implements Message ----------------------------------------------

  allocate_chat_room_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const allocate_chat_room_req& from);
  void MergeFrom(const allocate_chat_room_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID proto_id = 1 [default = allocate_chat_room_req_id];
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID proto_id() const;
  inline void set_proto_id(::SProtoSpace::ESSProtoID value);

  // repeated int32 room_ids = 2;
  inline int room_ids_size() const;
  inline void clear_room_ids();
  static const int kRoomIdsFieldNumber = 2;
  inline ::google::protobuf::int32 room_ids(int index) const;
  inline void set_room_ids(int index, ::google::protobuf::int32 value);
  inline void add_room_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      room_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_room_ids();

  // @@protoc_insertion_point(class_scope:SProtoSpace.allocate_chat_room_req)
 private:
  inline void set_has_proto_id();
  inline void clear_has_proto_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > room_ids_;
  int proto_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static allocate_chat_room_req* default_instance_;
};
// -------------------------------------------------------------------

class allocate_chat_room_ack : public ::google::protobuf::Message {
 public:
  allocate_chat_room_ack();
  virtual ~allocate_chat_room_ack();

  allocate_chat_room_ack(const allocate_chat_room_ack& from);

  inline allocate_chat_room_ack& operator=(const allocate_chat_room_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const allocate_chat_room_ack& default_instance();

  void Swap(allocate_chat_room_ack* other);

  // implements Message ----------------------------------------------

  allocate_chat_room_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const allocate_chat_room_ack& from);
  void MergeFrom(const allocate_chat_room_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID proto_id = 1 [default = allocate_chat_room_ack_id];
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID proto_id() const;
  inline void set_proto_id(::SProtoSpace::ESSProtoID value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // repeated int32 room_ids = 3;
  inline int room_ids_size() const;
  inline void clear_room_ids();
  static const int kRoomIdsFieldNumber = 3;
  inline ::google::protobuf::int32 room_ids(int index) const;
  inline void set_room_ids(int index, ::google::protobuf::int32 value);
  inline void add_room_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      room_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_room_ids();

  // @@protoc_insertion_point(class_scope:SProtoSpace.allocate_chat_room_ack)
 private:
  inline void set_has_proto_id();
  inline void clear_has_proto_id();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int proto_id_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > room_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static allocate_chat_room_ack* default_instance_;
};
// -------------------------------------------------------------------

class gs_get_role_position_req : public ::google::protobuf::Message {
 public:
  gs_get_role_position_req();
  virtual ~gs_get_role_position_req();

  gs_get_role_position_req(const gs_get_role_position_req& from);

  inline gs_get_role_position_req& operator=(const gs_get_role_position_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_get_role_position_req& default_instance();

  void Swap(gs_get_role_position_req* other);

  // implements Message ----------------------------------------------

  gs_get_role_position_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_get_role_position_req& from);
  void MergeFrom(const gs_get_role_position_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gs_get_role_position_req_id];
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID proto_id() const;
  inline void set_proto_id(::SProtoSpace::ESSProtoID value);

  // optional uint64 dest_id = 2;
  inline bool has_dest_id() const;
  inline void clear_dest_id();
  static const int kDestIdFieldNumber = 2;
  inline ::google::protobuf::uint64 dest_id() const;
  inline void set_dest_id(::google::protobuf::uint64 value);

  // optional uint64 sour_id = 3;
  inline bool has_sour_id() const;
  inline void clear_sour_id();
  static const int kSourIdFieldNumber = 3;
  inline ::google::protobuf::uint64 sour_id() const;
  inline void set_sour_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_get_role_position_req)
 private:
  inline void set_has_proto_id();
  inline void clear_has_proto_id();
  inline void set_has_dest_id();
  inline void clear_has_dest_id();
  inline void set_has_sour_id();
  inline void clear_has_sour_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dest_id_;
  ::google::protobuf::uint64 sour_id_;
  int proto_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_get_role_position_req* default_instance_;
};
// -------------------------------------------------------------------

class gs_get_role_position_ack : public ::google::protobuf::Message {
 public:
  gs_get_role_position_ack();
  virtual ~gs_get_role_position_ack();

  gs_get_role_position_ack(const gs_get_role_position_ack& from);

  inline gs_get_role_position_ack& operator=(const gs_get_role_position_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_get_role_position_ack& default_instance();

  void Swap(gs_get_role_position_ack* other);

  // implements Message ----------------------------------------------

  gs_get_role_position_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_get_role_position_ack& from);
  void MergeFrom(const gs_get_role_position_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gs_get_role_position_ack_id];
  inline bool has_proto_id() const;
  inline void clear_proto_id();
  static const int kProtoIdFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID proto_id() const;
  inline void set_proto_id(::SProtoSpace::ESSProtoID value);

  // optional uint32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // optional int32 room_id = 3;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 3;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);

  // optional .SProtoSpace.role_position dest_pos = 4;
  inline bool has_dest_pos() const;
  inline void clear_dest_pos();
  static const int kDestPosFieldNumber = 4;
  inline const ::SProtoSpace::role_position& dest_pos() const;
  inline ::SProtoSpace::role_position* mutable_dest_pos();
  inline ::SProtoSpace::role_position* release_dest_pos();
  inline void set_allocated_dest_pos(::SProtoSpace::role_position* dest_pos);

  // optional uint64 sour_id = 5;
  inline bool has_sour_id() const;
  inline void clear_sour_id();
  static const int kSourIdFieldNumber = 5;
  inline ::google::protobuf::uint64 sour_id() const;
  inline void set_sour_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_get_role_position_ack)
 private:
  inline void set_has_proto_id();
  inline void clear_has_proto_id();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_dest_pos();
  inline void clear_has_dest_pos();
  inline void set_has_sour_id();
  inline void clear_has_sour_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int proto_id_;
  ::google::protobuf::uint32 ret_;
  ::SProtoSpace::role_position* dest_pos_;
  ::google::protobuf::uint64 sour_id_;
  ::google::protobuf::int32 room_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_get_role_position_ack* default_instance_;
};
// -------------------------------------------------------------------

class red_pt_ss_ntf : public ::google::protobuf::Message {
 public:
  red_pt_ss_ntf();
  virtual ~red_pt_ss_ntf();

  red_pt_ss_ntf(const red_pt_ss_ntf& from);

  inline red_pt_ss_ntf& operator=(const red_pt_ss_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const red_pt_ss_ntf& default_instance();

  void Swap(red_pt_ss_ntf* other);

  // implements Message ----------------------------------------------

  red_pt_ss_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const red_pt_ss_ntf& from);
  void MergeFrom(const red_pt_ss_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = red_pt_ss_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 role_id = 2;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional .SProtoSpace.red_pt_infos infos = 3;
  inline bool has_infos() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::SProtoSpace::red_pt_infos& infos() const;
  inline ::SProtoSpace::red_pt_infos* mutable_infos();
  inline ::SProtoSpace::red_pt_infos* release_infos();
  inline void set_allocated_infos(::SProtoSpace::red_pt_infos* infos);

  // @@protoc_insertion_point(class_scope:SProtoSpace.red_pt_ss_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_infos();
  inline void clear_has_infos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  ::SProtoSpace::red_pt_infos* infos_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static red_pt_ss_ntf* default_instance_;
};
// -------------------------------------------------------------------

class get_other_role_fashion_ss_req : public ::google::protobuf::Message {
 public:
  get_other_role_fashion_ss_req();
  virtual ~get_other_role_fashion_ss_req();

  get_other_role_fashion_ss_req(const get_other_role_fashion_ss_req& from);

  inline get_other_role_fashion_ss_req& operator=(const get_other_role_fashion_ss_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_other_role_fashion_ss_req& default_instance();

  void Swap(get_other_role_fashion_ss_req* other);

  // implements Message ----------------------------------------------

  get_other_role_fashion_ss_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_other_role_fashion_ss_req& from);
  void MergeFrom(const get_other_role_fashion_ss_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = get_other_role_fashion_ss_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated uint64 role_id_s = 2;
  inline int role_id_s_size() const;
  inline void clear_role_id_s();
  static const int kRoleIdSFieldNumber = 2;
  inline ::google::protobuf::uint64 role_id_s(int index) const;
  inline void set_role_id_s(int index, ::google::protobuf::uint64 value);
  inline void add_role_id_s(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      role_id_s() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_role_id_s();

  // repeated string role_name_s = 3;
  inline int role_name_s_size() const;
  inline void clear_role_name_s();
  static const int kRoleNameSFieldNumber = 3;
  inline const ::std::string& role_name_s(int index) const;
  inline ::std::string* mutable_role_name_s(int index);
  inline void set_role_name_s(int index, const ::std::string& value);
  inline void set_role_name_s(int index, const char* value);
  inline void set_role_name_s(int index, const char* value, size_t size);
  inline ::std::string* add_role_name_s();
  inline void add_role_name_s(const ::std::string& value);
  inline void add_role_name_s(const char* value);
  inline void add_role_name_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& role_name_s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_role_name_s();

  // @@protoc_insertion_point(class_scope:SProtoSpace.get_other_role_fashion_ss_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > role_id_s_;
  ::google::protobuf::RepeatedPtrField< ::std::string> role_name_s_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static get_other_role_fashion_ss_req* default_instance_;
};
// -------------------------------------------------------------------

class get_other_role_fashion_ss_ack : public ::google::protobuf::Message {
 public:
  get_other_role_fashion_ss_ack();
  virtual ~get_other_role_fashion_ss_ack();

  get_other_role_fashion_ss_ack(const get_other_role_fashion_ss_ack& from);

  inline get_other_role_fashion_ss_ack& operator=(const get_other_role_fashion_ss_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const get_other_role_fashion_ss_ack& default_instance();

  void Swap(get_other_role_fashion_ss_ack* other);

  // implements Message ----------------------------------------------

  get_other_role_fashion_ss_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_other_role_fashion_ss_ack& from);
  void MergeFrom(const get_other_role_fashion_ss_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = get_other_role_fashion_ss_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.fashions_pack fashions_p_wearing = 2;
  inline bool has_fashions_p_wearing() const;
  inline void clear_fashions_p_wearing();
  static const int kFashionsPWearingFieldNumber = 2;
  inline const ::SProtoSpace::fashions_pack& fashions_p_wearing() const;
  inline ::SProtoSpace::fashions_pack* mutable_fashions_p_wearing();
  inline ::SProtoSpace::fashions_pack* release_fashions_p_wearing();
  inline void set_allocated_fashions_p_wearing(::SProtoSpace::fashions_pack* fashions_p_wearing);

  // optional .SProtoSpace.MsgErrorType error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::SProtoSpace::MsgErrorType error_code() const;
  inline void set_error_code(::SProtoSpace::MsgErrorType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.get_other_role_fashion_ss_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_fashions_p_wearing();
  inline void clear_has_fashions_p_wearing();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::fashions_pack* fashions_p_wearing_;
  int protoid_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static get_other_role_fashion_ss_ack* default_instance_;
};
// -------------------------------------------------------------------

class gs_chat_req : public ::google::protobuf::Message {
 public:
  gs_chat_req();
  virtual ~gs_chat_req();

  gs_chat_req(const gs_chat_req& from);

  inline gs_chat_req& operator=(const gs_chat_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_chat_req& default_instance();

  void Swap(gs_chat_req* other);

  // implements Message ----------------------------------------------

  gs_chat_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_chat_req& from);
  void MergeFrom(const gs_chat_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_chat_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.CHAT_TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::SProtoSpace::CHAT_TYPE type() const;
  inline void set_type(::SProtoSpace::CHAT_TYPE value);

  // optional uint64 module_id = 3;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 3;
  inline ::google::protobuf::uint64 module_id() const;
  inline void set_module_id(::google::protobuf::uint64 value);

  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint64 role_id = 5;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 5;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_chat_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_module_id();
  inline void clear_has_module_id();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_role_id();
  inline void clear_has_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  int type_;
  ::google::protobuf::uint64 module_id_;
  ::std::string* content_;
  ::google::protobuf::uint64 role_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_chat_req* default_instance_;
};
// -------------------------------------------------------------------

class gs_chat_ack : public ::google::protobuf::Message {
 public:
  gs_chat_ack();
  virtual ~gs_chat_ack();

  gs_chat_ack(const gs_chat_ack& from);

  inline gs_chat_ack& operator=(const gs_chat_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gs_chat_ack& default_instance();

  void Swap(gs_chat_ack* other);

  // implements Message ----------------------------------------------

  gs_chat_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gs_chat_ack& from);
  void MergeFrom(const gs_chat_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_chat_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.CHAT_TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::SProtoSpace::CHAT_TYPE type() const;
  inline void set_type(::SProtoSpace::CHAT_TYPE value);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional .SProtoSpace.public_role_base_info sour_data = 4;
  inline bool has_sour_data() const;
  inline void clear_sour_data();
  static const int kSourDataFieldNumber = 4;
  inline const ::SProtoSpace::public_role_base_info& sour_data() const;
  inline ::SProtoSpace::public_role_base_info* mutable_sour_data();
  inline ::SProtoSpace::public_role_base_info* release_sour_data();
  inline void set_allocated_sour_data(::SProtoSpace::public_role_base_info* sour_data);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gs_chat_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_sour_data();
  inline void clear_has_sour_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  int type_;
  ::std::string* content_;
  ::SProtoSpace::public_role_base_info* sour_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static gs_chat_ack* default_instance_;
};
// -------------------------------------------------------------------

class user_event_track_ss_ntf : public ::google::protobuf::Message {
 public:
  user_event_track_ss_ntf();
  virtual ~user_event_track_ss_ntf();

  user_event_track_ss_ntf(const user_event_track_ss_ntf& from);

  inline user_event_track_ss_ntf& operator=(const user_event_track_ss_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_event_track_ss_ntf& default_instance();

  void Swap(user_event_track_ss_ntf* other);

  // implements Message ----------------------------------------------

  user_event_track_ss_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_event_track_ss_ntf& from);
  void MergeFrom(const user_event_track_ss_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = user_event_track_ss_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated string log_s = 2;
  inline int log_s_size() const;
  inline void clear_log_s();
  static const int kLogSFieldNumber = 2;
  inline const ::std::string& log_s(int index) const;
  inline ::std::string* mutable_log_s(int index);
  inline void set_log_s(int index, const ::std::string& value);
  inline void set_log_s(int index, const char* value);
  inline void set_log_s(int index, const char* value, size_t size);
  inline ::std::string* add_log_s();
  inline void add_log_s(const ::std::string& value);
  inline void add_log_s(const char* value);
  inline void add_log_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& log_s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_log_s();

  // @@protoc_insertion_point(class_scope:SProtoSpace.user_event_track_ss_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> log_s_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fgame_2eproto();
  friend void protobuf_AssignDesc_ss_5fgame_2eproto();
  friend void protobuf_ShutdownFile_ss_5fgame_2eproto();

  void InitAsDefaultInstance();
  static user_event_track_ss_ntf* default_instance_;
};
// ===================================================================


// ===================================================================

// role_enter_game_server

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_enter_game_server_id];
inline bool role_enter_game_server::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_enter_game_server::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_enter_game_server::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_enter_game_server::clear_protoid() {
  protoid_ = 700;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID role_enter_game_server::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void role_enter_game_server::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 role_id = 2;
inline bool role_enter_game_server::has_role_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_enter_game_server::set_has_role_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_enter_game_server::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_enter_game_server::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 role_enter_game_server::role_id() const {
  return role_id_;
}
inline void role_enter_game_server::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint32 area_id = 3;
inline bool role_enter_game_server::has_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_enter_game_server::set_has_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_enter_game_server::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_enter_game_server::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 role_enter_game_server::area_id() const {
  return area_id_;
}
inline void role_enter_game_server::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional uint64 db_svr_id = 4;
inline bool role_enter_game_server::has_db_svr_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_enter_game_server::set_has_db_svr_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_enter_game_server::clear_has_db_svr_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_enter_game_server::clear_db_svr_id() {
  db_svr_id_ = GOOGLE_ULONGLONG(0);
  clear_has_db_svr_id();
}
inline ::google::protobuf::uint64 role_enter_game_server::db_svr_id() const {
  return db_svr_id_;
}
inline void role_enter_game_server::set_db_svr_id(::google::protobuf::uint64 value) {
  set_has_db_svr_id();
  db_svr_id_ = value;
}

// optional bool is_reconnect = 5;
inline bool role_enter_game_server::has_is_reconnect() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_enter_game_server::set_has_is_reconnect() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_enter_game_server::clear_has_is_reconnect() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_enter_game_server::clear_is_reconnect() {
  is_reconnect_ = false;
  clear_has_is_reconnect();
}
inline bool role_enter_game_server::is_reconnect() const {
  return is_reconnect_;
}
inline void role_enter_game_server::set_is_reconnect(bool value) {
  set_has_is_reconnect();
  is_reconnect_ = value;
}

// optional bool is_switch_scene = 6 [default = false];
inline bool role_enter_game_server::has_is_switch_scene() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_enter_game_server::set_has_is_switch_scene() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_enter_game_server::clear_has_is_switch_scene() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_enter_game_server::clear_is_switch_scene() {
  is_switch_scene_ = false;
  clear_has_is_switch_scene();
}
inline bool role_enter_game_server::is_switch_scene() const {
  return is_switch_scene_;
}
inline void role_enter_game_server::set_is_switch_scene(bool value) {
  set_has_is_switch_scene();
  is_switch_scene_ = value;
}

// optional uint32 scene_id = 7 [default = 0];
inline bool role_enter_game_server::has_scene_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_enter_game_server::set_has_scene_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_enter_game_server::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_enter_game_server::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 role_enter_game_server::scene_id() const {
  return scene_id_;
}
inline void role_enter_game_server::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 scene_type = 8 [default = 0];
inline bool role_enter_game_server::has_scene_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_enter_game_server::set_has_scene_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_enter_game_server::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_enter_game_server::clear_scene_type() {
  scene_type_ = 0u;
  clear_has_scene_type();
}
inline ::google::protobuf::uint32 role_enter_game_server::scene_type() const {
  return scene_type_;
}
inline void role_enter_game_server::set_scene_type(::google::protobuf::uint32 value) {
  set_has_scene_type();
  scene_type_ = value;
}

// -------------------------------------------------------------------

// gt_enter_game_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_enter_game_ack_id];
inline bool gt_enter_game_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_enter_game_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_enter_game_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_enter_game_ack::clear_protoid() {
  protoid_ = 709;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_enter_game_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_enter_game_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 role_id = 2;
inline bool gt_enter_game_ack::has_role_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_enter_game_ack::set_has_role_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_enter_game_ack::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_enter_game_ack::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 gt_enter_game_ack::role_id() const {
  return role_id_;
}
inline void gt_enter_game_ack::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 3;
inline bool gt_enter_game_ack::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_enter_game_ack::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_enter_game_ack::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_enter_game_ack::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& gt_enter_game_ack::role_name() const {
  return *role_name_;
}
inline void gt_enter_game_ack::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void gt_enter_game_ack::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void gt_enter_game_ack::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gt_enter_game_ack::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* gt_enter_game_ack::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gt_enter_game_ack::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ret = 4;
inline bool gt_enter_game_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gt_enter_game_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gt_enter_game_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gt_enter_game_ack::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 gt_enter_game_ack::ret() const {
  return ret_;
}
inline void gt_enter_game_ack::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// gs_create_scene_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_create_scene_req_id];
inline bool gs_create_scene_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_create_scene_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_create_scene_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_create_scene_req::clear_protoid() {
  protoid_ = 1650;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_create_scene_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_create_scene_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 create_type = 2;
inline bool gs_create_scene_req::has_create_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_create_scene_req::set_has_create_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_create_scene_req::clear_has_create_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_create_scene_req::clear_create_type() {
  create_type_ = 0u;
  clear_has_create_type();
}
inline ::google::protobuf::uint32 gs_create_scene_req::create_type() const {
  return create_type_;
}
inline void gs_create_scene_req::set_create_type(::google::protobuf::uint32 value) {
  set_has_create_type();
  create_type_ = value;
}

// optional uint32 scene_id = 3;
inline bool gs_create_scene_req::has_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_create_scene_req::set_has_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_create_scene_req::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_create_scene_req::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 gs_create_scene_req::scene_id() const {
  return scene_id_;
}
inline void gs_create_scene_req::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 scene_type = 4;
inline bool gs_create_scene_req::has_scene_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_create_scene_req::set_has_scene_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_create_scene_req::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_create_scene_req::clear_scene_type() {
  scene_type_ = 0u;
  clear_has_scene_type();
}
inline ::google::protobuf::uint32 gs_create_scene_req::scene_type() const {
  return scene_type_;
}
inline void gs_create_scene_req::set_scene_type(::google::protobuf::uint32 value) {
  set_has_scene_type();
  scene_type_ = value;
}

// optional uint32 param = 5;
inline bool gs_create_scene_req::has_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_create_scene_req::set_has_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_create_scene_req::clear_has_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_create_scene_req::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 gs_create_scene_req::param() const {
  return param_;
}
inline void gs_create_scene_req::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional uint32 last_time = 6;
inline bool gs_create_scene_req::has_last_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gs_create_scene_req::set_has_last_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gs_create_scene_req::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gs_create_scene_req::clear_last_time() {
  last_time_ = 0u;
  clear_has_last_time();
}
inline ::google::protobuf::uint32 gs_create_scene_req::last_time() const {
  return last_time_;
}
inline void gs_create_scene_req::set_last_time(::google::protobuf::uint32 value) {
  set_has_last_time();
  last_time_ = value;
}

// -------------------------------------------------------------------

// gs_create_scene_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_create_scene_ack_id];
inline bool gs_create_scene_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_create_scene_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_create_scene_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_create_scene_ack::clear_protoid() {
  protoid_ = 1651;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_create_scene_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_create_scene_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 create_type = 2;
inline bool gs_create_scene_ack::has_create_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_create_scene_ack::set_has_create_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_create_scene_ack::clear_has_create_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_create_scene_ack::clear_create_type() {
  create_type_ = 0u;
  clear_has_create_type();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::create_type() const {
  return create_type_;
}
inline void gs_create_scene_ack::set_create_type(::google::protobuf::uint32 value) {
  set_has_create_type();
  create_type_ = value;
}

// optional uint32 scene_id = 3;
inline bool gs_create_scene_ack::has_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_create_scene_ack::set_has_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_create_scene_ack::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_create_scene_ack::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::scene_id() const {
  return scene_id_;
}
inline void gs_create_scene_ack::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 scene_type = 4;
inline bool gs_create_scene_ack::has_scene_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_create_scene_ack::set_has_scene_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_create_scene_ack::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_create_scene_ack::clear_scene_type() {
  scene_type_ = 0u;
  clear_has_scene_type();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::scene_type() const {
  return scene_type_;
}
inline void gs_create_scene_ack::set_scene_type(::google::protobuf::uint32 value) {
  set_has_scene_type();
  scene_type_ = value;
}

// optional uint32 param = 5;
inline bool gs_create_scene_ack::has_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_create_scene_ack::set_has_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_create_scene_ack::clear_has_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_create_scene_ack::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::param() const {
  return param_;
}
inline void gs_create_scene_ack::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional uint32 last_time = 6;
inline bool gs_create_scene_ack::has_last_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gs_create_scene_ack::set_has_last_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gs_create_scene_ack::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gs_create_scene_ack::clear_last_time() {
  last_time_ = 0u;
  clear_has_last_time();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::last_time() const {
  return last_time_;
}
inline void gs_create_scene_ack::set_last_time(::google::protobuf::uint32 value) {
  set_has_last_time();
  last_time_ = value;
}

// optional uint32 ret = 7;
inline bool gs_create_scene_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gs_create_scene_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gs_create_scene_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gs_create_scene_ack::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 gs_create_scene_ack::ret() const {
  return ret_;
}
inline void gs_create_scene_ack::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// gs_kick_role_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_kick_role_req_id];
inline bool gs_kick_role_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_kick_role_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_kick_role_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_kick_role_req::clear_protoid() {
  protoid_ = 1652;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_kick_role_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_kick_role_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 reason = 2;
inline bool gs_kick_role_req::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_kick_role_req::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_kick_role_req::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_kick_role_req::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 gs_kick_role_req::reason() const {
  return reason_;
}
inline void gs_kick_role_req::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
}

// optional uint32 scene_id = 3;
inline bool gs_kick_role_req::has_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_kick_role_req::set_has_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_kick_role_req::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_kick_role_req::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 gs_kick_role_req::scene_id() const {
  return scene_id_;
}
inline void gs_kick_role_req::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 scene_type = 4;
inline bool gs_kick_role_req::has_scene_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_kick_role_req::set_has_scene_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_kick_role_req::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_kick_role_req::clear_scene_type() {
  scene_type_ = 0u;
  clear_has_scene_type();
}
inline ::google::protobuf::uint32 gs_kick_role_req::scene_type() const {
  return scene_type_;
}
inline void gs_kick_role_req::set_scene_type(::google::protobuf::uint32 value) {
  set_has_scene_type();
  scene_type_ = value;
}

// optional uint64 game_id = 5;
inline bool gs_kick_role_req::has_game_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_kick_role_req::set_has_game_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_kick_role_req::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_kick_role_req::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 gs_kick_role_req::game_id() const {
  return game_id_;
}
inline void gs_kick_role_req::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// -------------------------------------------------------------------

// gs_kick_role_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_kick_role_ack_id];
inline bool gs_kick_role_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_kick_role_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_kick_role_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_kick_role_ack::clear_protoid() {
  protoid_ = 1653;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_kick_role_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_kick_role_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 reason = 2;
inline bool gs_kick_role_ack::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_kick_role_ack::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_kick_role_ack::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_kick_role_ack::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 gs_kick_role_ack::reason() const {
  return reason_;
}
inline void gs_kick_role_ack::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
}

// optional uint32 ret = 3;
inline bool gs_kick_role_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_kick_role_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_kick_role_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_kick_role_ack::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 gs_kick_role_ack::ret() const {
  return ret_;
}
inline void gs_kick_role_ack::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// optional uint32 scene_id = 4;
inline bool gs_kick_role_ack::has_scene_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_kick_role_ack::set_has_scene_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_kick_role_ack::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_kick_role_ack::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 gs_kick_role_ack::scene_id() const {
  return scene_id_;
}
inline void gs_kick_role_ack::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 scene_type = 5;
inline bool gs_kick_role_ack::has_scene_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_kick_role_ack::set_has_scene_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_kick_role_ack::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_kick_role_ack::clear_scene_type() {
  scene_type_ = 0u;
  clear_has_scene_type();
}
inline ::google::protobuf::uint32 gs_kick_role_ack::scene_type() const {
  return scene_type_;
}
inline void gs_kick_role_ack::set_scene_type(::google::protobuf::uint32 value) {
  set_has_scene_type();
  scene_type_ = value;
}

// optional uint64 game_id = 6;
inline bool gs_kick_role_ack::has_game_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gs_kick_role_ack::set_has_game_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gs_kick_role_ack::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gs_kick_role_ack::clear_game_id() {
  game_id_ = GOOGLE_ULONGLONG(0);
  clear_has_game_id();
}
inline ::google::protobuf::uint64 gs_kick_role_ack::game_id() const {
  return game_id_;
}
inline void gs_kick_role_ack::set_game_id(::google::protobuf::uint64 value) {
  set_has_game_id();
  game_id_ = value;
}

// -------------------------------------------------------------------

// gs_broadcast_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_broadcast_req_id];
inline bool gs_broadcast_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_broadcast_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_broadcast_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_broadcast_req::clear_protoid() {
  protoid_ = 701;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_broadcast_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_broadcast_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional bytes proto = 2;
inline bool gs_broadcast_req::has_proto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_broadcast_req::set_has_proto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_broadcast_req::clear_has_proto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_broadcast_req::clear_proto() {
  if (proto_ != &::google::protobuf::internal::kEmptyString) {
    proto_->clear();
  }
  clear_has_proto();
}
inline const ::std::string& gs_broadcast_req::proto() const {
  return *proto_;
}
inline void gs_broadcast_req::set_proto(const ::std::string& value) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(value);
}
inline void gs_broadcast_req::set_proto(const char* value) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(value);
}
inline void gs_broadcast_req::set_proto(const void* value, size_t size) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gs_broadcast_req::mutable_proto() {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  return proto_;
}
inline ::std::string* gs_broadcast_req::release_proto() {
  clear_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proto_;
    proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gs_broadcast_req::set_allocated_proto(::std::string* proto) {
  if (proto_ != &::google::protobuf::internal::kEmptyString) {
    delete proto_;
  }
  if (proto) {
    set_has_proto();
    proto_ = proto;
  } else {
    clear_has_proto();
    proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gs_change_name_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_change_name_req_id];
inline bool gs_change_name_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_change_name_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_change_name_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_change_name_req::clear_protoid() {
  protoid_ = 702;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_change_name_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_change_name_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string new_name = 2;
inline bool gs_change_name_req::has_new_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_change_name_req::set_has_new_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_change_name_req::clear_has_new_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_change_name_req::clear_new_name() {
  if (new_name_ != &::google::protobuf::internal::kEmptyString) {
    new_name_->clear();
  }
  clear_has_new_name();
}
inline const ::std::string& gs_change_name_req::new_name() const {
  return *new_name_;
}
inline void gs_change_name_req::set_new_name(const ::std::string& value) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(value);
}
inline void gs_change_name_req::set_new_name(const char* value) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(value);
}
inline void gs_change_name_req::set_new_name(const char* value, size_t size) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gs_change_name_req::mutable_new_name() {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  return new_name_;
}
inline ::std::string* gs_change_name_req::release_new_name() {
  clear_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_name_;
    new_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gs_change_name_req::set_allocated_new_name(::std::string* new_name) {
  if (new_name_ != &::google::protobuf::internal::kEmptyString) {
    delete new_name_;
  }
  if (new_name) {
    set_has_new_name();
    new_name_ = new_name;
  } else {
    clear_has_new_name();
    new_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_name = 3;
inline bool gs_change_name_req::has_old_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_change_name_req::set_has_old_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_change_name_req::clear_has_old_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_change_name_req::clear_old_name() {
  if (old_name_ != &::google::protobuf::internal::kEmptyString) {
    old_name_->clear();
  }
  clear_has_old_name();
}
inline const ::std::string& gs_change_name_req::old_name() const {
  return *old_name_;
}
inline void gs_change_name_req::set_old_name(const ::std::string& value) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(value);
}
inline void gs_change_name_req::set_old_name(const char* value) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(value);
}
inline void gs_change_name_req::set_old_name(const char* value, size_t size) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gs_change_name_req::mutable_old_name() {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  return old_name_;
}
inline ::std::string* gs_change_name_req::release_old_name() {
  clear_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_name_;
    old_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gs_change_name_req::set_allocated_old_name(::std::string* old_name) {
  if (old_name_ != &::google::protobuf::internal::kEmptyString) {
    delete old_name_;
  }
  if (old_name) {
    set_has_old_name();
    old_name_ = old_name;
  } else {
    clear_has_old_name();
    old_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gt_change_name_ret

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_change_name_ret_id];
inline bool gt_change_name_ret::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_change_name_ret::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_change_name_ret::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_change_name_ret::clear_protoid() {
  protoid_ = 703;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_change_name_ret::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_change_name_ret::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string new_name = 2;
inline bool gt_change_name_ret::has_new_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_change_name_ret::set_has_new_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_change_name_ret::clear_has_new_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_change_name_ret::clear_new_name() {
  if (new_name_ != &::google::protobuf::internal::kEmptyString) {
    new_name_->clear();
  }
  clear_has_new_name();
}
inline const ::std::string& gt_change_name_ret::new_name() const {
  return *new_name_;
}
inline void gt_change_name_ret::set_new_name(const ::std::string& value) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(value);
}
inline void gt_change_name_ret::set_new_name(const char* value) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(value);
}
inline void gt_change_name_ret::set_new_name(const char* value, size_t size) {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  new_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gt_change_name_ret::mutable_new_name() {
  set_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    new_name_ = new ::std::string;
  }
  return new_name_;
}
inline ::std::string* gt_change_name_ret::release_new_name() {
  clear_has_new_name();
  if (new_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_name_;
    new_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gt_change_name_ret::set_allocated_new_name(::std::string* new_name) {
  if (new_name_ != &::google::protobuf::internal::kEmptyString) {
    delete new_name_;
  }
  if (new_name) {
    set_has_new_name();
    new_name_ = new_name;
  } else {
    clear_has_new_name();
    new_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gs_jump_to_cross_game_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_jump_to_cross_game_req_id];
inline bool gs_jump_to_cross_game_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_jump_to_cross_game_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_jump_to_cross_game_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_jump_to_cross_game_req::clear_protoid() {
  protoid_ = 704;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_jump_to_cross_game_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_jump_to_cross_game_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// gt_kick_role_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_kick_role_ntf_id];
inline bool gt_kick_role_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_kick_role_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_kick_role_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_kick_role_ntf::clear_protoid() {
  protoid_ = 705;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_kick_role_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_kick_role_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 player_id = 2;
inline bool gt_kick_role_ntf::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_kick_role_ntf::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_kick_role_ntf::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_kick_role_ntf::clear_player_id() {
  player_id_ = GOOGLE_ULONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::uint64 gt_kick_role_ntf::player_id() const {
  return player_id_;
}
inline void gt_kick_role_ntf::set_player_id(::google::protobuf::uint64 value) {
  set_has_player_id();
  player_id_ = value;
}

// -------------------------------------------------------------------

// gs_player_num_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_player_num_ntf_id];
inline bool gs_player_num_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_player_num_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_player_num_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_player_num_ntf::clear_protoid() {
  protoid_ = 706;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_player_num_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_player_num_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 player_num = 2;
inline bool gs_player_num_ntf::has_player_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_player_num_ntf::set_has_player_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_player_num_ntf::clear_has_player_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_player_num_ntf::clear_player_num() {
  player_num_ = 0u;
  clear_has_player_num();
}
inline ::google::protobuf::uint32 gs_player_num_ntf::player_num() const {
  return player_num_;
}
inline void gs_player_num_ntf::set_player_num(::google::protobuf::uint32 value) {
  set_has_player_num();
  player_num_ = value;
}

// -------------------------------------------------------------------

// gate_forward_search_req

// optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gate_forward_search_req_id];
inline bool gate_forward_search_req::has_proto_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate_forward_search_req::set_has_proto_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate_forward_search_req::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate_forward_search_req::clear_proto_id() {
  proto_id_ = 707;
  clear_has_proto_id();
}
inline ::SProtoSpace::ESSProtoID gate_forward_search_req::proto_id() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(proto_id_);
}
inline void gate_forward_search_req::set_proto_id(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_proto_id();
  proto_id_ = value;
}

// optional uint32 type = 2;
inline bool gate_forward_search_req::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate_forward_search_req::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate_forward_search_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate_forward_search_req::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 gate_forward_search_req::type() const {
  return type_;
}
inline void gate_forward_search_req::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string content = 3;
inline bool gate_forward_search_req::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gate_forward_search_req::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gate_forward_search_req::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gate_forward_search_req::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& gate_forward_search_req::content() const {
  return *content_;
}
inline void gate_forward_search_req::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gate_forward_search_req::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gate_forward_search_req::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gate_forward_search_req::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* gate_forward_search_req::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gate_forward_search_req::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uuid = 4;
inline bool gate_forward_search_req::has_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gate_forward_search_req::set_has_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gate_forward_search_req::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gate_forward_search_req::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 gate_forward_search_req::uuid() const {
  return uuid_;
}
inline void gate_forward_search_req::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// -------------------------------------------------------------------

// log_gather_info

// optional .SProtoSpace.log_gather_role_info role_info = 1;
inline bool log_gather_info::has_role_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_info::set_has_role_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_info::clear_has_role_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_info::clear_role_info() {
  if (role_info_ != NULL) role_info_->::SProtoSpace::log_gather_role_info::Clear();
  clear_has_role_info();
}
inline const ::SProtoSpace::log_gather_role_info& log_gather_info::role_info() const {
  return role_info_ != NULL ? *role_info_ : *default_instance_->role_info_;
}
inline ::SProtoSpace::log_gather_role_info* log_gather_info::mutable_role_info() {
  set_has_role_info();
  if (role_info_ == NULL) role_info_ = new ::SProtoSpace::log_gather_role_info;
  return role_info_;
}
inline ::SProtoSpace::log_gather_role_info* log_gather_info::release_role_info() {
  clear_has_role_info();
  ::SProtoSpace::log_gather_role_info* temp = role_info_;
  role_info_ = NULL;
  return temp;
}
inline void log_gather_info::set_allocated_role_info(::SProtoSpace::log_gather_role_info* role_info) {
  delete role_info_;
  role_info_ = role_info;
  if (role_info) {
    set_has_role_info();
  } else {
    clear_has_role_info();
  }
}

// optional .SProtoSpace.log_gather_task_info task_info = 2;
inline bool log_gather_info::has_task_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_info::set_has_task_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_info::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_info::clear_task_info() {
  if (task_info_ != NULL) task_info_->::SProtoSpace::log_gather_task_info::Clear();
  clear_has_task_info();
}
inline const ::SProtoSpace::log_gather_task_info& log_gather_info::task_info() const {
  return task_info_ != NULL ? *task_info_ : *default_instance_->task_info_;
}
inline ::SProtoSpace::log_gather_task_info* log_gather_info::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) task_info_ = new ::SProtoSpace::log_gather_task_info;
  return task_info_;
}
inline ::SProtoSpace::log_gather_task_info* log_gather_info::release_task_info() {
  clear_has_task_info();
  ::SProtoSpace::log_gather_task_info* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void log_gather_info::set_allocated_task_info(::SProtoSpace::log_gather_task_info* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
}

// optional .SProtoSpace.log_gather_honor_info honor_info = 3;
inline bool log_gather_info::has_honor_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_info::set_has_honor_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_info::clear_has_honor_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_info::clear_honor_info() {
  if (honor_info_ != NULL) honor_info_->::SProtoSpace::log_gather_honor_info::Clear();
  clear_has_honor_info();
}
inline const ::SProtoSpace::log_gather_honor_info& log_gather_info::honor_info() const {
  return honor_info_ != NULL ? *honor_info_ : *default_instance_->honor_info_;
}
inline ::SProtoSpace::log_gather_honor_info* log_gather_info::mutable_honor_info() {
  set_has_honor_info();
  if (honor_info_ == NULL) honor_info_ = new ::SProtoSpace::log_gather_honor_info;
  return honor_info_;
}
inline ::SProtoSpace::log_gather_honor_info* log_gather_info::release_honor_info() {
  clear_has_honor_info();
  ::SProtoSpace::log_gather_honor_info* temp = honor_info_;
  honor_info_ = NULL;
  return temp;
}
inline void log_gather_info::set_allocated_honor_info(::SProtoSpace::log_gather_honor_info* honor_info) {
  delete honor_info_;
  honor_info_ = honor_info;
  if (honor_info) {
    set_has_honor_info();
  } else {
    clear_has_honor_info();
  }
}

// optional .SProtoSpace.log_gather_level_up_info level_info = 4;
inline bool log_gather_info::has_level_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_info::set_has_level_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_info::clear_has_level_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_info::clear_level_info() {
  if (level_info_ != NULL) level_info_->::SProtoSpace::log_gather_level_up_info::Clear();
  clear_has_level_info();
}
inline const ::SProtoSpace::log_gather_level_up_info& log_gather_info::level_info() const {
  return level_info_ != NULL ? *level_info_ : *default_instance_->level_info_;
}
inline ::SProtoSpace::log_gather_level_up_info* log_gather_info::mutable_level_info() {
  set_has_level_info();
  if (level_info_ == NULL) level_info_ = new ::SProtoSpace::log_gather_level_up_info;
  return level_info_;
}
inline ::SProtoSpace::log_gather_level_up_info* log_gather_info::release_level_info() {
  clear_has_level_info();
  ::SProtoSpace::log_gather_level_up_info* temp = level_info_;
  level_info_ = NULL;
  return temp;
}
inline void log_gather_info::set_allocated_level_info(::SProtoSpace::log_gather_level_up_info* level_info) {
  delete level_info_;
  level_info_ = level_info;
  if (level_info) {
    set_has_level_info();
  } else {
    clear_has_level_info();
  }
}

// optional .SProtoSpace.log_gather_buy_info buy_info = 5;
inline bool log_gather_info::has_buy_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_info::set_has_buy_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_info::clear_has_buy_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_info::clear_buy_info() {
  if (buy_info_ != NULL) buy_info_->::SProtoSpace::log_gather_buy_info::Clear();
  clear_has_buy_info();
}
inline const ::SProtoSpace::log_gather_buy_info& log_gather_info::buy_info() const {
  return buy_info_ != NULL ? *buy_info_ : *default_instance_->buy_info_;
}
inline ::SProtoSpace::log_gather_buy_info* log_gather_info::mutable_buy_info() {
  set_has_buy_info();
  if (buy_info_ == NULL) buy_info_ = new ::SProtoSpace::log_gather_buy_info;
  return buy_info_;
}
inline ::SProtoSpace::log_gather_buy_info* log_gather_info::release_buy_info() {
  clear_has_buy_info();
  ::SProtoSpace::log_gather_buy_info* temp = buy_info_;
  buy_info_ = NULL;
  return temp;
}
inline void log_gather_info::set_allocated_buy_info(::SProtoSpace::log_gather_buy_info* buy_info) {
  delete buy_info_;
  buy_info_ = buy_info;
  if (buy_info) {
    set_has_buy_info();
  } else {
    clear_has_buy_info();
  }
}

// repeated .SProtoSpace.log_gather_player_register player_register = 6;
inline int log_gather_info::player_register_size() const {
  return player_register_.size();
}
inline void log_gather_info::clear_player_register() {
  player_register_.Clear();
}
inline const ::SProtoSpace::log_gather_player_register& log_gather_info::player_register(int index) const {
  return player_register_.Get(index);
}
inline ::SProtoSpace::log_gather_player_register* log_gather_info::mutable_player_register(int index) {
  return player_register_.Mutable(index);
}
inline ::SProtoSpace::log_gather_player_register* log_gather_info::add_player_register() {
  return player_register_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_register >&
log_gather_info::player_register() const {
  return player_register_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_register >*
log_gather_info::mutable_player_register() {
  return &player_register_;
}

// repeated .SProtoSpace.log_gather_player_login player_login = 7;
inline int log_gather_info::player_login_size() const {
  return player_login_.size();
}
inline void log_gather_info::clear_player_login() {
  player_login_.Clear();
}
inline const ::SProtoSpace::log_gather_player_login& log_gather_info::player_login(int index) const {
  return player_login_.Get(index);
}
inline ::SProtoSpace::log_gather_player_login* log_gather_info::mutable_player_login(int index) {
  return player_login_.Mutable(index);
}
inline ::SProtoSpace::log_gather_player_login* log_gather_info::add_player_login() {
  return player_login_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_login >&
log_gather_info::player_login() const {
  return player_login_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_login >*
log_gather_info::mutable_player_login() {
  return &player_login_;
}

// repeated .SProtoSpace.log_gather_player_logout player_logout = 8;
inline int log_gather_info::player_logout_size() const {
  return player_logout_.size();
}
inline void log_gather_info::clear_player_logout() {
  player_logout_.Clear();
}
inline const ::SProtoSpace::log_gather_player_logout& log_gather_info::player_logout(int index) const {
  return player_logout_.Get(index);
}
inline ::SProtoSpace::log_gather_player_logout* log_gather_info::mutable_player_logout(int index) {
  return player_logout_.Mutable(index);
}
inline ::SProtoSpace::log_gather_player_logout* log_gather_info::add_player_logout() {
  return player_logout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_logout >&
log_gather_info::player_logout() const {
  return player_logout_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_logout >*
log_gather_info::mutable_player_logout() {
  return &player_logout_;
}

// repeated .SProtoSpace.log_gather_money_flow money_flow = 9;
inline int log_gather_info::money_flow_size() const {
  return money_flow_.size();
}
inline void log_gather_info::clear_money_flow() {
  money_flow_.Clear();
}
inline const ::SProtoSpace::log_gather_money_flow& log_gather_info::money_flow(int index) const {
  return money_flow_.Get(index);
}
inline ::SProtoSpace::log_gather_money_flow* log_gather_info::mutable_money_flow(int index) {
  return money_flow_.Mutable(index);
}
inline ::SProtoSpace::log_gather_money_flow* log_gather_info::add_money_flow() {
  return money_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_money_flow >&
log_gather_info::money_flow() const {
  return money_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_money_flow >*
log_gather_info::mutable_money_flow() {
  return &money_flow_;
}

// repeated .SProtoSpace.log_gather_item_flow item_flow = 10;
inline int log_gather_info::item_flow_size() const {
  return item_flow_.size();
}
inline void log_gather_info::clear_item_flow() {
  item_flow_.Clear();
}
inline const ::SProtoSpace::log_gather_item_flow& log_gather_info::item_flow(int index) const {
  return item_flow_.Get(index);
}
inline ::SProtoSpace::log_gather_item_flow* log_gather_info::mutable_item_flow(int index) {
  return item_flow_.Mutable(index);
}
inline ::SProtoSpace::log_gather_item_flow* log_gather_info::add_item_flow() {
  return item_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_flow >&
log_gather_info::item_flow() const {
  return item_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_flow >*
log_gather_info::mutable_item_flow() {
  return &item_flow_;
}

// repeated .SProtoSpace.log_gather_item_money_flow item_money_flow = 11;
inline int log_gather_info::item_money_flow_size() const {
  return item_money_flow_.size();
}
inline void log_gather_info::clear_item_money_flow() {
  item_money_flow_.Clear();
}
inline const ::SProtoSpace::log_gather_item_money_flow& log_gather_info::item_money_flow(int index) const {
  return item_money_flow_.Get(index);
}
inline ::SProtoSpace::log_gather_item_money_flow* log_gather_info::mutable_item_money_flow(int index) {
  return item_money_flow_.Mutable(index);
}
inline ::SProtoSpace::log_gather_item_money_flow* log_gather_info::add_item_money_flow() {
  return item_money_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_money_flow >&
log_gather_info::item_money_flow() const {
  return item_money_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_item_money_flow >*
log_gather_info::mutable_item_money_flow() {
  return &item_money_flow_;
}

// repeated .SProtoSpace.log_gather_player_exp_flow player_exp_flow = 12;
inline int log_gather_info::player_exp_flow_size() const {
  return player_exp_flow_.size();
}
inline void log_gather_info::clear_player_exp_flow() {
  player_exp_flow_.Clear();
}
inline const ::SProtoSpace::log_gather_player_exp_flow& log_gather_info::player_exp_flow(int index) const {
  return player_exp_flow_.Get(index);
}
inline ::SProtoSpace::log_gather_player_exp_flow* log_gather_info::mutable_player_exp_flow(int index) {
  return player_exp_flow_.Mutable(index);
}
inline ::SProtoSpace::log_gather_player_exp_flow* log_gather_info::add_player_exp_flow() {
  return player_exp_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_exp_flow >&
log_gather_info::player_exp_flow() const {
  return player_exp_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_player_exp_flow >*
log_gather_info::mutable_player_exp_flow() {
  return &player_exp_flow_;
}

// repeated .SProtoSpace.log_gather_sns_flow sns_flow = 13;
inline int log_gather_info::sns_flow_size() const {
  return sns_flow_.size();
}
inline void log_gather_info::clear_sns_flow() {
  sns_flow_.Clear();
}
inline const ::SProtoSpace::log_gather_sns_flow& log_gather_info::sns_flow(int index) const {
  return sns_flow_.Get(index);
}
inline ::SProtoSpace::log_gather_sns_flow* log_gather_info::mutable_sns_flow(int index) {
  return sns_flow_.Mutable(index);
}
inline ::SProtoSpace::log_gather_sns_flow* log_gather_info::add_sns_flow() {
  return sns_flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_sns_flow >&
log_gather_info::sns_flow() const {
  return sns_flow_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::log_gather_sns_flow >*
log_gather_info::mutable_sns_flow() {
  return &sns_flow_;
}

// -------------------------------------------------------------------

// log_gather_player_register

// optional string GameSvrId = 1;
inline bool log_gather_player_register::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_player_register::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_player_register::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_player_register::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_player_register::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_player_register::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_register::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_register::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_player_register::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_player_register::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_player_register::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_player_register::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_player_register::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_player_register::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_player_register::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_register::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_register::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_player_register::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vGameAppID = 3;
inline bool log_gather_player_register::has_vgameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_player_register::set_has_vgameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_player_register::clear_has_vgameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_player_register::clear_vgameappid() {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    vgameappid_->clear();
  }
  clear_has_vgameappid();
}
inline const ::std::string& log_gather_player_register::vgameappid() const {
  return *vgameappid_;
}
inline void log_gather_player_register::set_vgameappid(const ::std::string& value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_player_register::set_vgameappid(const char* value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_player_register::set_vgameappid(const char* value, size_t size) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_vgameappid() {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  return vgameappid_;
}
inline ::std::string* log_gather_player_register::release_vgameappid() {
  clear_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vgameappid_;
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_vgameappid(::std::string* vgameappid) {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete vgameappid_;
  }
  if (vgameappid) {
    set_has_vgameappid();
    vgameappid_ = vgameappid;
  } else {
    clear_has_vgameappid();
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 4;
inline bool log_gather_player_register::has_platid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_player_register::set_has_platid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_player_register::clear_has_platid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_player_register::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_player_register::platid() const {
  return platid_;
}
inline void log_gather_player_register::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 iZoneAreaID = 5;
inline bool log_gather_player_register::has_izoneareaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_player_register::set_has_izoneareaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_player_register::clear_has_izoneareaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_player_register::clear_izoneareaid() {
  izoneareaid_ = 0;
  clear_has_izoneareaid();
}
inline ::google::protobuf::int32 log_gather_player_register::izoneareaid() const {
  return izoneareaid_;
}
inline void log_gather_player_register::set_izoneareaid(::google::protobuf::int32 value) {
  set_has_izoneareaid();
  izoneareaid_ = value;
}

// optional string vopenid = 6;
inline bool log_gather_player_register::has_vopenid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_player_register::set_has_vopenid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_player_register::clear_has_vopenid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_player_register::clear_vopenid() {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    vopenid_->clear();
  }
  clear_has_vopenid();
}
inline const ::std::string& log_gather_player_register::vopenid() const {
  return *vopenid_;
}
inline void log_gather_player_register::set_vopenid(const ::std::string& value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_player_register::set_vopenid(const char* value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_player_register::set_vopenid(const char* value, size_t size) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_vopenid() {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  return vopenid_;
}
inline ::std::string* log_gather_player_register::release_vopenid() {
  clear_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vopenid_;
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_vopenid(::std::string* vopenid) {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete vopenid_;
  }
  if (vopenid) {
    set_has_vopenid();
    vopenid_ = vopenid;
  } else {
    clear_has_vopenid();
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ClientVersion = 7;
inline bool log_gather_player_register::has_clientversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_player_register::set_has_clientversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_player_register::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_player_register::clear_clientversion() {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    clientversion_->clear();
  }
  clear_has_clientversion();
}
inline const ::std::string& log_gather_player_register::clientversion() const {
  return *clientversion_;
}
inline void log_gather_player_register::set_clientversion(const ::std::string& value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_register::set_clientversion(const char* value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_register::set_clientversion(const char* value, size_t size) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_clientversion() {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  return clientversion_;
}
inline ::std::string* log_gather_player_register::release_clientversion() {
  clear_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientversion_;
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_clientversion(::std::string* clientversion) {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    delete clientversion_;
  }
  if (clientversion) {
    set_has_clientversion();
    clientversion_ = clientversion;
  } else {
    clear_has_clientversion();
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemSoftware = 8;
inline bool log_gather_player_register::has_systemsoftware() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_player_register::set_has_systemsoftware() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_player_register::clear_has_systemsoftware() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_player_register::clear_systemsoftware() {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    systemsoftware_->clear();
  }
  clear_has_systemsoftware();
}
inline const ::std::string& log_gather_player_register::systemsoftware() const {
  return *systemsoftware_;
}
inline void log_gather_player_register::set_systemsoftware(const ::std::string& value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_register::set_systemsoftware(const char* value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_register::set_systemsoftware(const char* value, size_t size) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_systemsoftware() {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  return systemsoftware_;
}
inline ::std::string* log_gather_player_register::release_systemsoftware() {
  clear_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemsoftware_;
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_systemsoftware(::std::string* systemsoftware) {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemsoftware_;
  }
  if (systemsoftware) {
    set_has_systemsoftware();
    systemsoftware_ = systemsoftware;
  } else {
    clear_has_systemsoftware();
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemHardware = 9;
inline bool log_gather_player_register::has_systemhardware() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_player_register::set_has_systemhardware() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_player_register::clear_has_systemhardware() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_player_register::clear_systemhardware() {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    systemhardware_->clear();
  }
  clear_has_systemhardware();
}
inline const ::std::string& log_gather_player_register::systemhardware() const {
  return *systemhardware_;
}
inline void log_gather_player_register::set_systemhardware(const ::std::string& value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_register::set_systemhardware(const char* value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_register::set_systemhardware(const char* value, size_t size) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_systemhardware() {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  return systemhardware_;
}
inline ::std::string* log_gather_player_register::release_systemhardware() {
  clear_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemhardware_;
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_systemhardware(::std::string* systemhardware) {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemhardware_;
  }
  if (systemhardware) {
    set_has_systemhardware();
    systemhardware_ = systemhardware;
  } else {
    clear_has_systemhardware();
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string TelecomOper = 10;
inline bool log_gather_player_register::has_telecomoper() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_player_register::set_has_telecomoper() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_player_register::clear_has_telecomoper() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_player_register::clear_telecomoper() {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    telecomoper_->clear();
  }
  clear_has_telecomoper();
}
inline const ::std::string& log_gather_player_register::telecomoper() const {
  return *telecomoper_;
}
inline void log_gather_player_register::set_telecomoper(const ::std::string& value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_register::set_telecomoper(const char* value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_register::set_telecomoper(const char* value, size_t size) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_telecomoper() {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  return telecomoper_;
}
inline ::std::string* log_gather_player_register::release_telecomoper() {
  clear_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telecomoper_;
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_telecomoper(::std::string* telecomoper) {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    delete telecomoper_;
  }
  if (telecomoper) {
    set_has_telecomoper();
    telecomoper_ = telecomoper;
  } else {
    clear_has_telecomoper();
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Network = 11;
inline bool log_gather_player_register::has_network() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_player_register::set_has_network() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_player_register::clear_has_network() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_player_register::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& log_gather_player_register::network() const {
  return *network_;
}
inline void log_gather_player_register::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_register::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_register::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* log_gather_player_register::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ScreenWidth = 12;
inline bool log_gather_player_register::has_screenwidth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_player_register::set_has_screenwidth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_player_register::clear_has_screenwidth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_player_register::clear_screenwidth() {
  screenwidth_ = 0;
  clear_has_screenwidth();
}
inline ::google::protobuf::int32 log_gather_player_register::screenwidth() const {
  return screenwidth_;
}
inline void log_gather_player_register::set_screenwidth(::google::protobuf::int32 value) {
  set_has_screenwidth();
  screenwidth_ = value;
}

// optional int32 ScreenHight = 13;
inline bool log_gather_player_register::has_screenhight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_player_register::set_has_screenhight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_player_register::clear_has_screenhight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_player_register::clear_screenhight() {
  screenhight_ = 0;
  clear_has_screenhight();
}
inline ::google::protobuf::int32 log_gather_player_register::screenhight() const {
  return screenhight_;
}
inline void log_gather_player_register::set_screenhight(::google::protobuf::int32 value) {
  set_has_screenhight();
  screenhight_ = value;
}

// optional float Density = 14;
inline bool log_gather_player_register::has_density() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_player_register::set_has_density() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_player_register::clear_has_density() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_player_register::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float log_gather_player_register::density() const {
  return density_;
}
inline void log_gather_player_register::set_density(float value) {
  set_has_density();
  density_ = value;
}

// optional int32 RegChannel = 15;
inline bool log_gather_player_register::has_regchannel() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_player_register::set_has_regchannel() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_player_register::clear_has_regchannel() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_player_register::clear_regchannel() {
  regchannel_ = 0;
  clear_has_regchannel();
}
inline ::google::protobuf::int32 log_gather_player_register::regchannel() const {
  return regchannel_;
}
inline void log_gather_player_register::set_regchannel(::google::protobuf::int32 value) {
  set_has_regchannel();
  regchannel_ = value;
}

// optional string CpuHardware = 16;
inline bool log_gather_player_register::has_cpuhardware() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void log_gather_player_register::set_has_cpuhardware() {
  _has_bits_[0] |= 0x00008000u;
}
inline void log_gather_player_register::clear_has_cpuhardware() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void log_gather_player_register::clear_cpuhardware() {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    cpuhardware_->clear();
  }
  clear_has_cpuhardware();
}
inline const ::std::string& log_gather_player_register::cpuhardware() const {
  return *cpuhardware_;
}
inline void log_gather_player_register::set_cpuhardware(const ::std::string& value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_register::set_cpuhardware(const char* value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_register::set_cpuhardware(const char* value, size_t size) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_cpuhardware() {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  return cpuhardware_;
}
inline ::std::string* log_gather_player_register::release_cpuhardware() {
  clear_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpuhardware_;
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_cpuhardware(::std::string* cpuhardware) {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete cpuhardware_;
  }
  if (cpuhardware) {
    set_has_cpuhardware();
    cpuhardware_ = cpuhardware;
  } else {
    clear_has_cpuhardware();
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Memory = 17;
inline bool log_gather_player_register::has_memory() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void log_gather_player_register::set_has_memory() {
  _has_bits_[0] |= 0x00010000u;
}
inline void log_gather_player_register::clear_has_memory() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void log_gather_player_register::clear_memory() {
  memory_ = 0;
  clear_has_memory();
}
inline ::google::protobuf::int32 log_gather_player_register::memory() const {
  return memory_;
}
inline void log_gather_player_register::set_memory(::google::protobuf::int32 value) {
  set_has_memory();
  memory_ = value;
}

// optional string GLRender = 18;
inline bool log_gather_player_register::has_glrender() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void log_gather_player_register::set_has_glrender() {
  _has_bits_[0] |= 0x00020000u;
}
inline void log_gather_player_register::clear_has_glrender() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void log_gather_player_register::clear_glrender() {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    glrender_->clear();
  }
  clear_has_glrender();
}
inline const ::std::string& log_gather_player_register::glrender() const {
  return *glrender_;
}
inline void log_gather_player_register::set_glrender(const ::std::string& value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_register::set_glrender(const char* value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_register::set_glrender(const char* value, size_t size) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_glrender() {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  return glrender_;
}
inline ::std::string* log_gather_player_register::release_glrender() {
  clear_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glrender_;
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_glrender(::std::string* glrender) {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    delete glrender_;
  }
  if (glrender) {
    set_has_glrender();
    glrender_ = glrender;
  } else {
    clear_has_glrender();
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GLVersion = 19;
inline bool log_gather_player_register::has_glversion() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void log_gather_player_register::set_has_glversion() {
  _has_bits_[0] |= 0x00040000u;
}
inline void log_gather_player_register::clear_has_glversion() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void log_gather_player_register::clear_glversion() {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    glversion_->clear();
  }
  clear_has_glversion();
}
inline const ::std::string& log_gather_player_register::glversion() const {
  return *glversion_;
}
inline void log_gather_player_register::set_glversion(const ::std::string& value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_register::set_glversion(const char* value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_register::set_glversion(const char* value, size_t size) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_glversion() {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  return glversion_;
}
inline ::std::string* log_gather_player_register::release_glversion() {
  clear_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glversion_;
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_glversion(::std::string* glversion) {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    delete glversion_;
  }
  if (glversion) {
    set_has_glversion();
    glversion_ = glversion;
  } else {
    clear_has_glversion();
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DeviceId = 20;
inline bool log_gather_player_register::has_deviceid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void log_gather_player_register::set_has_deviceid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void log_gather_player_register::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void log_gather_player_register::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& log_gather_player_register::deviceid() const {
  return *deviceid_;
}
inline void log_gather_player_register::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_register::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_register::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_register::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* log_gather_player_register::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_register::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerRegister];
inline bool log_gather_player_register::has_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void log_gather_player_register::set_has_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void log_gather_player_register::clear_has_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void log_gather_player_register::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_player_register::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_player_register::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_player_login

// optional string GameSvrId = 1;
inline bool log_gather_player_login::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_player_login::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_player_login::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_player_login::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_player_login::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_player_login::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_login::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_login::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_player_login::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_player_login::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_player_login::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_player_login::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_player_login::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_player_login::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_player_login::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_login::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_login::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_player_login::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GameAppID = 3;
inline bool log_gather_player_login::has_gameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_player_login::set_has_gameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_player_login::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_player_login::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_player_login::gameappid() const {
  return *gameappid_;
}
inline void log_gather_player_login::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_login::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_login::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_player_login::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OpenID = 4;
inline bool log_gather_player_login::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_player_login::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_player_login::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_player_login::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_player_login::openid() const {
  return *openid_;
}
inline void log_gather_player_login::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_login::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_login::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_player_login::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Level = 5;
inline bool log_gather_player_login::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_player_login::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_player_login::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_player_login::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 log_gather_player_login::level() const {
  return level_;
}
inline void log_gather_player_login::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 PlayerFriendsNum = 6;
inline bool log_gather_player_login::has_playerfriendsnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_player_login::set_has_playerfriendsnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_player_login::clear_has_playerfriendsnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_player_login::clear_playerfriendsnum() {
  playerfriendsnum_ = 0;
  clear_has_playerfriendsnum();
}
inline ::google::protobuf::int32 log_gather_player_login::playerfriendsnum() const {
  return playerfriendsnum_;
}
inline void log_gather_player_login::set_playerfriendsnum(::google::protobuf::int32 value) {
  set_has_playerfriendsnum();
  playerfriendsnum_ = value;
}

// optional int32 PlatID = 7;
inline bool log_gather_player_login::has_platid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_player_login::set_has_platid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_player_login::clear_has_platid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_player_login::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_player_login::platid() const {
  return platid_;
}
inline void log_gather_player_login::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional string ClientVersion = 8;
inline bool log_gather_player_login::has_clientversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_player_login::set_has_clientversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_player_login::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_player_login::clear_clientversion() {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    clientversion_->clear();
  }
  clear_has_clientversion();
}
inline const ::std::string& log_gather_player_login::clientversion() const {
  return *clientversion_;
}
inline void log_gather_player_login::set_clientversion(const ::std::string& value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_login::set_clientversion(const char* value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_login::set_clientversion(const char* value, size_t size) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_clientversion() {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  return clientversion_;
}
inline ::std::string* log_gather_player_login::release_clientversion() {
  clear_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientversion_;
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_clientversion(::std::string* clientversion) {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    delete clientversion_;
  }
  if (clientversion) {
    set_has_clientversion();
    clientversion_ = clientversion;
  } else {
    clear_has_clientversion();
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemSoftware = 9;
inline bool log_gather_player_login::has_systemsoftware() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_player_login::set_has_systemsoftware() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_player_login::clear_has_systemsoftware() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_player_login::clear_systemsoftware() {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    systemsoftware_->clear();
  }
  clear_has_systemsoftware();
}
inline const ::std::string& log_gather_player_login::systemsoftware() const {
  return *systemsoftware_;
}
inline void log_gather_player_login::set_systemsoftware(const ::std::string& value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_login::set_systemsoftware(const char* value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_login::set_systemsoftware(const char* value, size_t size) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_systemsoftware() {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  return systemsoftware_;
}
inline ::std::string* log_gather_player_login::release_systemsoftware() {
  clear_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemsoftware_;
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_systemsoftware(::std::string* systemsoftware) {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemsoftware_;
  }
  if (systemsoftware) {
    set_has_systemsoftware();
    systemsoftware_ = systemsoftware;
  } else {
    clear_has_systemsoftware();
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemHardware = 10;
inline bool log_gather_player_login::has_systemhardware() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_player_login::set_has_systemhardware() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_player_login::clear_has_systemhardware() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_player_login::clear_systemhardware() {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    systemhardware_->clear();
  }
  clear_has_systemhardware();
}
inline const ::std::string& log_gather_player_login::systemhardware() const {
  return *systemhardware_;
}
inline void log_gather_player_login::set_systemhardware(const ::std::string& value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_login::set_systemhardware(const char* value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_login::set_systemhardware(const char* value, size_t size) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_systemhardware() {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  return systemhardware_;
}
inline ::std::string* log_gather_player_login::release_systemhardware() {
  clear_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemhardware_;
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_systemhardware(::std::string* systemhardware) {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemhardware_;
  }
  if (systemhardware) {
    set_has_systemhardware();
    systemhardware_ = systemhardware;
  } else {
    clear_has_systemhardware();
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string TelecomOper = 11;
inline bool log_gather_player_login::has_telecomoper() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_player_login::set_has_telecomoper() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_player_login::clear_has_telecomoper() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_player_login::clear_telecomoper() {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    telecomoper_->clear();
  }
  clear_has_telecomoper();
}
inline const ::std::string& log_gather_player_login::telecomoper() const {
  return *telecomoper_;
}
inline void log_gather_player_login::set_telecomoper(const ::std::string& value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_login::set_telecomoper(const char* value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_login::set_telecomoper(const char* value, size_t size) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_telecomoper() {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  return telecomoper_;
}
inline ::std::string* log_gather_player_login::release_telecomoper() {
  clear_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telecomoper_;
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_telecomoper(::std::string* telecomoper) {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    delete telecomoper_;
  }
  if (telecomoper) {
    set_has_telecomoper();
    telecomoper_ = telecomoper;
  } else {
    clear_has_telecomoper();
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Network = 12;
inline bool log_gather_player_login::has_network() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_player_login::set_has_network() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_player_login::clear_has_network() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_player_login::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& log_gather_player_login::network() const {
  return *network_;
}
inline void log_gather_player_login::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_login::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_login::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* log_gather_player_login::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ScreenWidth = 13;
inline bool log_gather_player_login::has_screenwidth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_player_login::set_has_screenwidth() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_player_login::clear_has_screenwidth() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_player_login::clear_screenwidth() {
  screenwidth_ = 0;
  clear_has_screenwidth();
}
inline ::google::protobuf::int32 log_gather_player_login::screenwidth() const {
  return screenwidth_;
}
inline void log_gather_player_login::set_screenwidth(::google::protobuf::int32 value) {
  set_has_screenwidth();
  screenwidth_ = value;
}

// optional int32 ScreenHight = 14;
inline bool log_gather_player_login::has_screenhight() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_player_login::set_has_screenhight() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_player_login::clear_has_screenhight() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_player_login::clear_screenhight() {
  screenhight_ = 0;
  clear_has_screenhight();
}
inline ::google::protobuf::int32 log_gather_player_login::screenhight() const {
  return screenhight_;
}
inline void log_gather_player_login::set_screenhight(::google::protobuf::int32 value) {
  set_has_screenhight();
  screenhight_ = value;
}

// optional float Density = 15;
inline bool log_gather_player_login::has_density() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_player_login::set_has_density() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_player_login::clear_has_density() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_player_login::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float log_gather_player_login::density() const {
  return density_;
}
inline void log_gather_player_login::set_density(float value) {
  set_has_density();
  density_ = value;
}

// optional int32 LoginChannel = 16;
inline bool log_gather_player_login::has_loginchannel() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void log_gather_player_login::set_has_loginchannel() {
  _has_bits_[0] |= 0x00008000u;
}
inline void log_gather_player_login::clear_has_loginchannel() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void log_gather_player_login::clear_loginchannel() {
  loginchannel_ = 0;
  clear_has_loginchannel();
}
inline ::google::protobuf::int32 log_gather_player_login::loginchannel() const {
  return loginchannel_;
}
inline void log_gather_player_login::set_loginchannel(::google::protobuf::int32 value) {
  set_has_loginchannel();
  loginchannel_ = value;
}

// optional string CpuHardware = 17;
inline bool log_gather_player_login::has_cpuhardware() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void log_gather_player_login::set_has_cpuhardware() {
  _has_bits_[0] |= 0x00010000u;
}
inline void log_gather_player_login::clear_has_cpuhardware() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void log_gather_player_login::clear_cpuhardware() {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    cpuhardware_->clear();
  }
  clear_has_cpuhardware();
}
inline const ::std::string& log_gather_player_login::cpuhardware() const {
  return *cpuhardware_;
}
inline void log_gather_player_login::set_cpuhardware(const ::std::string& value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_login::set_cpuhardware(const char* value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_login::set_cpuhardware(const char* value, size_t size) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_cpuhardware() {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  return cpuhardware_;
}
inline ::std::string* log_gather_player_login::release_cpuhardware() {
  clear_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpuhardware_;
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_cpuhardware(::std::string* cpuhardware) {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete cpuhardware_;
  }
  if (cpuhardware) {
    set_has_cpuhardware();
    cpuhardware_ = cpuhardware;
  } else {
    clear_has_cpuhardware();
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Memory = 18;
inline bool log_gather_player_login::has_memory() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void log_gather_player_login::set_has_memory() {
  _has_bits_[0] |= 0x00020000u;
}
inline void log_gather_player_login::clear_has_memory() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void log_gather_player_login::clear_memory() {
  memory_ = 0;
  clear_has_memory();
}
inline ::google::protobuf::int32 log_gather_player_login::memory() const {
  return memory_;
}
inline void log_gather_player_login::set_memory(::google::protobuf::int32 value) {
  set_has_memory();
  memory_ = value;
}

// optional string GLRender = 19;
inline bool log_gather_player_login::has_glrender() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void log_gather_player_login::set_has_glrender() {
  _has_bits_[0] |= 0x00040000u;
}
inline void log_gather_player_login::clear_has_glrender() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void log_gather_player_login::clear_glrender() {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    glrender_->clear();
  }
  clear_has_glrender();
}
inline const ::std::string& log_gather_player_login::glrender() const {
  return *glrender_;
}
inline void log_gather_player_login::set_glrender(const ::std::string& value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_login::set_glrender(const char* value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_login::set_glrender(const char* value, size_t size) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_glrender() {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  return glrender_;
}
inline ::std::string* log_gather_player_login::release_glrender() {
  clear_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glrender_;
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_glrender(::std::string* glrender) {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    delete glrender_;
  }
  if (glrender) {
    set_has_glrender();
    glrender_ = glrender;
  } else {
    clear_has_glrender();
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GLVersion = 20;
inline bool log_gather_player_login::has_glversion() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void log_gather_player_login::set_has_glversion() {
  _has_bits_[0] |= 0x00080000u;
}
inline void log_gather_player_login::clear_has_glversion() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void log_gather_player_login::clear_glversion() {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    glversion_->clear();
  }
  clear_has_glversion();
}
inline const ::std::string& log_gather_player_login::glversion() const {
  return *glversion_;
}
inline void log_gather_player_login::set_glversion(const ::std::string& value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_login::set_glversion(const char* value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_login::set_glversion(const char* value, size_t size) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_glversion() {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  return glversion_;
}
inline ::std::string* log_gather_player_login::release_glversion() {
  clear_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glversion_;
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_glversion(::std::string* glversion) {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    delete glversion_;
  }
  if (glversion) {
    set_has_glversion();
    glversion_ = glversion;
  } else {
    clear_has_glversion();
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DeviceId = 21;
inline bool log_gather_player_login::has_deviceid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void log_gather_player_login::set_has_deviceid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void log_gather_player_login::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void log_gather_player_login::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& log_gather_player_login::deviceid() const {
  return *deviceid_;
}
inline void log_gather_player_login::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_login::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_login::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_login::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* log_gather_player_login::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_login::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerLogin];
inline bool log_gather_player_login::has_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void log_gather_player_login::set_has_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void log_gather_player_login::clear_has_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void log_gather_player_login::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_player_login::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_player_login::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_player_logout

// optional string GameSvrId = 1;
inline bool log_gather_player_logout::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_player_logout::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_player_logout::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_player_logout::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_player_logout::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_player_logout::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_logout::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_logout::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_player_logout::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_player_logout::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_player_logout::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_player_logout::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_player_logout::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_player_logout::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_player_logout::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_logout::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_logout::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_player_logout::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GameAppID = 3;
inline bool log_gather_player_logout::has_gameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_player_logout::set_has_gameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_player_logout::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_player_logout::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_player_logout::gameappid() const {
  return *gameappid_;
}
inline void log_gather_player_logout::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_logout::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_logout::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_player_logout::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OpenID = 4;
inline bool log_gather_player_logout::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_player_logout::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_player_logout::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_player_logout::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_player_logout::openid() const {
  return *openid_;
}
inline void log_gather_player_logout::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_logout::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_logout::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_player_logout::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 OnlineTime = 5;
inline bool log_gather_player_logout::has_onlinetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_player_logout::set_has_onlinetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_player_logout::clear_has_onlinetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_player_logout::clear_onlinetime() {
  onlinetime_ = 0;
  clear_has_onlinetime();
}
inline ::google::protobuf::int32 log_gather_player_logout::onlinetime() const {
  return onlinetime_;
}
inline void log_gather_player_logout::set_onlinetime(::google::protobuf::int32 value) {
  set_has_onlinetime();
  onlinetime_ = value;
}

// optional int32 Level = 6;
inline bool log_gather_player_logout::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_player_logout::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_player_logout::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_player_logout::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 log_gather_player_logout::level() const {
  return level_;
}
inline void log_gather_player_logout::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 PlayerFriendsNum = 7;
inline bool log_gather_player_logout::has_playerfriendsnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_player_logout::set_has_playerfriendsnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_player_logout::clear_has_playerfriendsnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_player_logout::clear_playerfriendsnum() {
  playerfriendsnum_ = 0;
  clear_has_playerfriendsnum();
}
inline ::google::protobuf::int32 log_gather_player_logout::playerfriendsnum() const {
  return playerfriendsnum_;
}
inline void log_gather_player_logout::set_playerfriendsnum(::google::protobuf::int32 value) {
  set_has_playerfriendsnum();
  playerfriendsnum_ = value;
}

// optional int32 PlatID = 8;
inline bool log_gather_player_logout::has_platid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_player_logout::set_has_platid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_player_logout::clear_has_platid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_player_logout::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_player_logout::platid() const {
  return platid_;
}
inline void log_gather_player_logout::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional string ClientVersion = 9;
inline bool log_gather_player_logout::has_clientversion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_player_logout::set_has_clientversion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_player_logout::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_player_logout::clear_clientversion() {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    clientversion_->clear();
  }
  clear_has_clientversion();
}
inline const ::std::string& log_gather_player_logout::clientversion() const {
  return *clientversion_;
}
inline void log_gather_player_logout::set_clientversion(const ::std::string& value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_logout::set_clientversion(const char* value) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(value);
}
inline void log_gather_player_logout::set_clientversion(const char* value, size_t size) {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  clientversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_clientversion() {
  set_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    clientversion_ = new ::std::string;
  }
  return clientversion_;
}
inline ::std::string* log_gather_player_logout::release_clientversion() {
  clear_has_clientversion();
  if (clientversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientversion_;
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_clientversion(::std::string* clientversion) {
  if (clientversion_ != &::google::protobuf::internal::kEmptyString) {
    delete clientversion_;
  }
  if (clientversion) {
    set_has_clientversion();
    clientversion_ = clientversion;
  } else {
    clear_has_clientversion();
    clientversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemSoftware = 10;
inline bool log_gather_player_logout::has_systemsoftware() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_player_logout::set_has_systemsoftware() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_player_logout::clear_has_systemsoftware() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_player_logout::clear_systemsoftware() {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    systemsoftware_->clear();
  }
  clear_has_systemsoftware();
}
inline const ::std::string& log_gather_player_logout::systemsoftware() const {
  return *systemsoftware_;
}
inline void log_gather_player_logout::set_systemsoftware(const ::std::string& value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_logout::set_systemsoftware(const char* value) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(value);
}
inline void log_gather_player_logout::set_systemsoftware(const char* value, size_t size) {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  systemsoftware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_systemsoftware() {
  set_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    systemsoftware_ = new ::std::string;
  }
  return systemsoftware_;
}
inline ::std::string* log_gather_player_logout::release_systemsoftware() {
  clear_has_systemsoftware();
  if (systemsoftware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemsoftware_;
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_systemsoftware(::std::string* systemsoftware) {
  if (systemsoftware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemsoftware_;
  }
  if (systemsoftware) {
    set_has_systemsoftware();
    systemsoftware_ = systemsoftware;
  } else {
    clear_has_systemsoftware();
    systemsoftware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemHardware = 11;
inline bool log_gather_player_logout::has_systemhardware() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_player_logout::set_has_systemhardware() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_player_logout::clear_has_systemhardware() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_player_logout::clear_systemhardware() {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    systemhardware_->clear();
  }
  clear_has_systemhardware();
}
inline const ::std::string& log_gather_player_logout::systemhardware() const {
  return *systemhardware_;
}
inline void log_gather_player_logout::set_systemhardware(const ::std::string& value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_logout::set_systemhardware(const char* value) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(value);
}
inline void log_gather_player_logout::set_systemhardware(const char* value, size_t size) {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  systemhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_systemhardware() {
  set_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    systemhardware_ = new ::std::string;
  }
  return systemhardware_;
}
inline ::std::string* log_gather_player_logout::release_systemhardware() {
  clear_has_systemhardware();
  if (systemhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemhardware_;
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_systemhardware(::std::string* systemhardware) {
  if (systemhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete systemhardware_;
  }
  if (systemhardware) {
    set_has_systemhardware();
    systemhardware_ = systemhardware;
  } else {
    clear_has_systemhardware();
    systemhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string TelecomOper = 12;
inline bool log_gather_player_logout::has_telecomoper() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_player_logout::set_has_telecomoper() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_player_logout::clear_has_telecomoper() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_player_logout::clear_telecomoper() {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    telecomoper_->clear();
  }
  clear_has_telecomoper();
}
inline const ::std::string& log_gather_player_logout::telecomoper() const {
  return *telecomoper_;
}
inline void log_gather_player_logout::set_telecomoper(const ::std::string& value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_logout::set_telecomoper(const char* value) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(value);
}
inline void log_gather_player_logout::set_telecomoper(const char* value, size_t size) {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  telecomoper_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_telecomoper() {
  set_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    telecomoper_ = new ::std::string;
  }
  return telecomoper_;
}
inline ::std::string* log_gather_player_logout::release_telecomoper() {
  clear_has_telecomoper();
  if (telecomoper_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = telecomoper_;
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_telecomoper(::std::string* telecomoper) {
  if (telecomoper_ != &::google::protobuf::internal::kEmptyString) {
    delete telecomoper_;
  }
  if (telecomoper) {
    set_has_telecomoper();
    telecomoper_ = telecomoper;
  } else {
    clear_has_telecomoper();
    telecomoper_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Network = 13;
inline bool log_gather_player_logout::has_network() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_player_logout::set_has_network() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_player_logout::clear_has_network() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_player_logout::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& log_gather_player_logout::network() const {
  return *network_;
}
inline void log_gather_player_logout::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_logout::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void log_gather_player_logout::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* log_gather_player_logout::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ScreenWidth = 14;
inline bool log_gather_player_logout::has_screenwidth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_player_logout::set_has_screenwidth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_player_logout::clear_has_screenwidth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_player_logout::clear_screenwidth() {
  screenwidth_ = 0;
  clear_has_screenwidth();
}
inline ::google::protobuf::int32 log_gather_player_logout::screenwidth() const {
  return screenwidth_;
}
inline void log_gather_player_logout::set_screenwidth(::google::protobuf::int32 value) {
  set_has_screenwidth();
  screenwidth_ = value;
}

// optional int32 ScreenHight = 15;
inline bool log_gather_player_logout::has_screenhight() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_player_logout::set_has_screenhight() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_player_logout::clear_has_screenhight() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_player_logout::clear_screenhight() {
  screenhight_ = 0;
  clear_has_screenhight();
}
inline ::google::protobuf::int32 log_gather_player_logout::screenhight() const {
  return screenhight_;
}
inline void log_gather_player_logout::set_screenhight(::google::protobuf::int32 value) {
  set_has_screenhight();
  screenhight_ = value;
}

// optional float Density = 16;
inline bool log_gather_player_logout::has_density() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void log_gather_player_logout::set_has_density() {
  _has_bits_[0] |= 0x00008000u;
}
inline void log_gather_player_logout::clear_has_density() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void log_gather_player_logout::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float log_gather_player_logout::density() const {
  return density_;
}
inline void log_gather_player_logout::set_density(float value) {
  set_has_density();
  density_ = value;
}

// optional int32 LoginChannel = 17;
inline bool log_gather_player_logout::has_loginchannel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void log_gather_player_logout::set_has_loginchannel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void log_gather_player_logout::clear_has_loginchannel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void log_gather_player_logout::clear_loginchannel() {
  loginchannel_ = 0;
  clear_has_loginchannel();
}
inline ::google::protobuf::int32 log_gather_player_logout::loginchannel() const {
  return loginchannel_;
}
inline void log_gather_player_logout::set_loginchannel(::google::protobuf::int32 value) {
  set_has_loginchannel();
  loginchannel_ = value;
}

// optional string CpuHardware = 18;
inline bool log_gather_player_logout::has_cpuhardware() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void log_gather_player_logout::set_has_cpuhardware() {
  _has_bits_[0] |= 0x00020000u;
}
inline void log_gather_player_logout::clear_has_cpuhardware() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void log_gather_player_logout::clear_cpuhardware() {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    cpuhardware_->clear();
  }
  clear_has_cpuhardware();
}
inline const ::std::string& log_gather_player_logout::cpuhardware() const {
  return *cpuhardware_;
}
inline void log_gather_player_logout::set_cpuhardware(const ::std::string& value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_logout::set_cpuhardware(const char* value) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(value);
}
inline void log_gather_player_logout::set_cpuhardware(const char* value, size_t size) {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  cpuhardware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_cpuhardware() {
  set_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    cpuhardware_ = new ::std::string;
  }
  return cpuhardware_;
}
inline ::std::string* log_gather_player_logout::release_cpuhardware() {
  clear_has_cpuhardware();
  if (cpuhardware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpuhardware_;
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_cpuhardware(::std::string* cpuhardware) {
  if (cpuhardware_ != &::google::protobuf::internal::kEmptyString) {
    delete cpuhardware_;
  }
  if (cpuhardware) {
    set_has_cpuhardware();
    cpuhardware_ = cpuhardware;
  } else {
    clear_has_cpuhardware();
    cpuhardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Memory = 19;
inline bool log_gather_player_logout::has_memory() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void log_gather_player_logout::set_has_memory() {
  _has_bits_[0] |= 0x00040000u;
}
inline void log_gather_player_logout::clear_has_memory() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void log_gather_player_logout::clear_memory() {
  memory_ = 0;
  clear_has_memory();
}
inline ::google::protobuf::int32 log_gather_player_logout::memory() const {
  return memory_;
}
inline void log_gather_player_logout::set_memory(::google::protobuf::int32 value) {
  set_has_memory();
  memory_ = value;
}

// optional string GLRender = 20;
inline bool log_gather_player_logout::has_glrender() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void log_gather_player_logout::set_has_glrender() {
  _has_bits_[0] |= 0x00080000u;
}
inline void log_gather_player_logout::clear_has_glrender() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void log_gather_player_logout::clear_glrender() {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    glrender_->clear();
  }
  clear_has_glrender();
}
inline const ::std::string& log_gather_player_logout::glrender() const {
  return *glrender_;
}
inline void log_gather_player_logout::set_glrender(const ::std::string& value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_logout::set_glrender(const char* value) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(value);
}
inline void log_gather_player_logout::set_glrender(const char* value, size_t size) {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  glrender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_glrender() {
  set_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    glrender_ = new ::std::string;
  }
  return glrender_;
}
inline ::std::string* log_gather_player_logout::release_glrender() {
  clear_has_glrender();
  if (glrender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glrender_;
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_glrender(::std::string* glrender) {
  if (glrender_ != &::google::protobuf::internal::kEmptyString) {
    delete glrender_;
  }
  if (glrender) {
    set_has_glrender();
    glrender_ = glrender;
  } else {
    clear_has_glrender();
    glrender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GLVersion = 21;
inline bool log_gather_player_logout::has_glversion() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void log_gather_player_logout::set_has_glversion() {
  _has_bits_[0] |= 0x00100000u;
}
inline void log_gather_player_logout::clear_has_glversion() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void log_gather_player_logout::clear_glversion() {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    glversion_->clear();
  }
  clear_has_glversion();
}
inline const ::std::string& log_gather_player_logout::glversion() const {
  return *glversion_;
}
inline void log_gather_player_logout::set_glversion(const ::std::string& value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_logout::set_glversion(const char* value) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(value);
}
inline void log_gather_player_logout::set_glversion(const char* value, size_t size) {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  glversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_glversion() {
  set_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    glversion_ = new ::std::string;
  }
  return glversion_;
}
inline ::std::string* log_gather_player_logout::release_glversion() {
  clear_has_glversion();
  if (glversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = glversion_;
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_glversion(::std::string* glversion) {
  if (glversion_ != &::google::protobuf::internal::kEmptyString) {
    delete glversion_;
  }
  if (glversion) {
    set_has_glversion();
    glversion_ = glversion;
  } else {
    clear_has_glversion();
    glversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DeviceId = 22;
inline bool log_gather_player_logout::has_deviceid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void log_gather_player_logout::set_has_deviceid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void log_gather_player_logout::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void log_gather_player_logout::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& log_gather_player_logout::deviceid() const {
  return *deviceid_;
}
inline void log_gather_player_logout::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_logout::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void log_gather_player_logout::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_logout::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* log_gather_player_logout::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_logout::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerLogout];
inline bool log_gather_player_logout::has_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void log_gather_player_logout::set_has_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void log_gather_player_logout::clear_has_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void log_gather_player_logout::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_player_logout::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_player_logout::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_money_flow

// optional string GameSvrId = 1;
inline bool log_gather_money_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_money_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_money_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_money_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_money_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_money_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_money_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_money_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_money_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_money_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_money_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_money_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_money_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_money_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_money_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_money_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_money_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_money_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_money_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_money_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_money_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_money_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vGameAppID = 3;
inline bool log_gather_money_flow::has_vgameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_money_flow::set_has_vgameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_money_flow::clear_has_vgameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_money_flow::clear_vgameappid() {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    vgameappid_->clear();
  }
  clear_has_vgameappid();
}
inline const ::std::string& log_gather_money_flow::vgameappid() const {
  return *vgameappid_;
}
inline void log_gather_money_flow::set_vgameappid(const ::std::string& value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_money_flow::set_vgameappid(const char* value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_money_flow::set_vgameappid(const char* value, size_t size) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_money_flow::mutable_vgameappid() {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  return vgameappid_;
}
inline ::std::string* log_gather_money_flow::release_vgameappid() {
  clear_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vgameappid_;
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_money_flow::set_allocated_vgameappid(::std::string* vgameappid) {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete vgameappid_;
  }
  if (vgameappid) {
    set_has_vgameappid();
    vgameappid_ = vgameappid;
  } else {
    clear_has_vgameappid();
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 4;
inline bool log_gather_money_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_money_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_money_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_money_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_money_flow::platid() const {
  return platid_;
}
inline void log_gather_money_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 iZoneAreaID = 5;
inline bool log_gather_money_flow::has_izoneareaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_money_flow::set_has_izoneareaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_money_flow::clear_has_izoneareaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_money_flow::clear_izoneareaid() {
  izoneareaid_ = 0;
  clear_has_izoneareaid();
}
inline ::google::protobuf::int32 log_gather_money_flow::izoneareaid() const {
  return izoneareaid_;
}
inline void log_gather_money_flow::set_izoneareaid(::google::protobuf::int32 value) {
  set_has_izoneareaid();
  izoneareaid_ = value;
}

// optional string vopenid = 6;
inline bool log_gather_money_flow::has_vopenid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_money_flow::set_has_vopenid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_money_flow::clear_has_vopenid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_money_flow::clear_vopenid() {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    vopenid_->clear();
  }
  clear_has_vopenid();
}
inline const ::std::string& log_gather_money_flow::vopenid() const {
  return *vopenid_;
}
inline void log_gather_money_flow::set_vopenid(const ::std::string& value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_money_flow::set_vopenid(const char* value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_money_flow::set_vopenid(const char* value, size_t size) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_money_flow::mutable_vopenid() {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  return vopenid_;
}
inline ::std::string* log_gather_money_flow::release_vopenid() {
  clear_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vopenid_;
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_money_flow::set_allocated_vopenid(::std::string* vopenid) {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete vopenid_;
  }
  if (vopenid) {
    set_has_vopenid();
    vopenid_ = vopenid;
  } else {
    clear_has_vopenid();
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Sequence = 8;
inline bool log_gather_money_flow::has_sequence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_money_flow::set_has_sequence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_money_flow::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_money_flow::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 log_gather_money_flow::sequence() const {
  return sequence_;
}
inline void log_gather_money_flow::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 Level = 9;
inline bool log_gather_money_flow::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_money_flow::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_money_flow::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_money_flow::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 log_gather_money_flow::level() const {
  return level_;
}
inline void log_gather_money_flow::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 AfterMOney = 10;
inline bool log_gather_money_flow::has_aftermoney() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_money_flow::set_has_aftermoney() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_money_flow::clear_has_aftermoney() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_money_flow::clear_aftermoney() {
  aftermoney_ = 0;
  clear_has_aftermoney();
}
inline ::google::protobuf::int32 log_gather_money_flow::aftermoney() const {
  return aftermoney_;
}
inline void log_gather_money_flow::set_aftermoney(::google::protobuf::int32 value) {
  set_has_aftermoney();
  aftermoney_ = value;
}

// optional int32 iMoney = 11;
inline bool log_gather_money_flow::has_imoney() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_money_flow::set_has_imoney() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_money_flow::clear_has_imoney() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_money_flow::clear_imoney() {
  imoney_ = 0;
  clear_has_imoney();
}
inline ::google::protobuf::int32 log_gather_money_flow::imoney() const {
  return imoney_;
}
inline void log_gather_money_flow::set_imoney(::google::protobuf::int32 value) {
  set_has_imoney();
  imoney_ = value;
}

// optional int32 Reason = 12;
inline bool log_gather_money_flow::has_reason() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_money_flow::set_has_reason() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_money_flow::clear_has_reason() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_money_flow::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 log_gather_money_flow::reason() const {
  return reason_;
}
inline void log_gather_money_flow::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// optional int32 SubReason = 13;
inline bool log_gather_money_flow::has_subreason() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_money_flow::set_has_subreason() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_money_flow::clear_has_subreason() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_money_flow::clear_subreason() {
  subreason_ = 0;
  clear_has_subreason();
}
inline ::google::protobuf::int32 log_gather_money_flow::subreason() const {
  return subreason_;
}
inline void log_gather_money_flow::set_subreason(::google::protobuf::int32 value) {
  set_has_subreason();
  subreason_ = value;
}

// optional int32 AddOrReduce = 14;
inline bool log_gather_money_flow::has_addorreduce() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_money_flow::set_has_addorreduce() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_money_flow::clear_has_addorreduce() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_money_flow::clear_addorreduce() {
  addorreduce_ = 0;
  clear_has_addorreduce();
}
inline ::google::protobuf::int32 log_gather_money_flow::addorreduce() const {
  return addorreduce_;
}
inline void log_gather_money_flow::set_addorreduce(::google::protobuf::int32 value) {
  set_has_addorreduce();
  addorreduce_ = value;
}

// optional int32 iMoneyType = 15;
inline bool log_gather_money_flow::has_imoneytype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_money_flow::set_has_imoneytype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_money_flow::clear_has_imoneytype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_money_flow::clear_imoneytype() {
  imoneytype_ = 0;
  clear_has_imoneytype();
}
inline ::google::protobuf::int32 log_gather_money_flow::imoneytype() const {
  return imoneytype_;
}
inline void log_gather_money_flow::set_imoneytype(::google::protobuf::int32 value) {
  set_has_imoneytype();
  imoneytype_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_MoneyFlow];
inline bool log_gather_money_flow::has_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_money_flow::set_has_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_money_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_money_flow::clear_type() {
  type_ = 4;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_money_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_money_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_item_flow

// optional string GameSvrId = 1;
inline bool log_gather_item_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_item_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_item_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_item_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_item_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_item_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_item_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_item_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_item_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_item_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_item_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_item_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_item_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_item_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_item_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_item_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_item_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_item_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string vGameAppID = 3;
inline bool log_gather_item_flow::has_vgameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_item_flow::set_has_vgameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_item_flow::clear_has_vgameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_item_flow::clear_vgameappid() {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    vgameappid_->clear();
  }
  clear_has_vgameappid();
}
inline const ::std::string& log_gather_item_flow::vgameappid() const {
  return *vgameappid_;
}
inline void log_gather_item_flow::set_vgameappid(const ::std::string& value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_item_flow::set_vgameappid(const char* value) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(value);
}
inline void log_gather_item_flow::set_vgameappid(const char* value, size_t size) {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  vgameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_flow::mutable_vgameappid() {
  set_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    vgameappid_ = new ::std::string;
  }
  return vgameappid_;
}
inline ::std::string* log_gather_item_flow::release_vgameappid() {
  clear_has_vgameappid();
  if (vgameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vgameappid_;
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_flow::set_allocated_vgameappid(::std::string* vgameappid) {
  if (vgameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete vgameappid_;
  }
  if (vgameappid) {
    set_has_vgameappid();
    vgameappid_ = vgameappid;
  } else {
    clear_has_vgameappid();
    vgameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 4;
inline bool log_gather_item_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_item_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_item_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_item_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_item_flow::platid() const {
  return platid_;
}
inline void log_gather_item_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 iZoneAreaID = 5;
inline bool log_gather_item_flow::has_izoneareaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_item_flow::set_has_izoneareaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_item_flow::clear_has_izoneareaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_item_flow::clear_izoneareaid() {
  izoneareaid_ = 0;
  clear_has_izoneareaid();
}
inline ::google::protobuf::int32 log_gather_item_flow::izoneareaid() const {
  return izoneareaid_;
}
inline void log_gather_item_flow::set_izoneareaid(::google::protobuf::int32 value) {
  set_has_izoneareaid();
  izoneareaid_ = value;
}

// optional string vopenid = 6;
inline bool log_gather_item_flow::has_vopenid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_item_flow::set_has_vopenid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_item_flow::clear_has_vopenid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_item_flow::clear_vopenid() {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    vopenid_->clear();
  }
  clear_has_vopenid();
}
inline const ::std::string& log_gather_item_flow::vopenid() const {
  return *vopenid_;
}
inline void log_gather_item_flow::set_vopenid(const ::std::string& value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_item_flow::set_vopenid(const char* value) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(value);
}
inline void log_gather_item_flow::set_vopenid(const char* value, size_t size) {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  vopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_flow::mutable_vopenid() {
  set_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    vopenid_ = new ::std::string;
  }
  return vopenid_;
}
inline ::std::string* log_gather_item_flow::release_vopenid() {
  clear_has_vopenid();
  if (vopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vopenid_;
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_flow::set_allocated_vopenid(::std::string* vopenid) {
  if (vopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete vopenid_;
  }
  if (vopenid) {
    set_has_vopenid();
    vopenid_ = vopenid;
  } else {
    clear_has_vopenid();
    vopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Level = 7;
inline bool log_gather_item_flow::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_item_flow::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_item_flow::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_item_flow::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 log_gather_item_flow::level() const {
  return level_;
}
inline void log_gather_item_flow::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 Sequence = 8;
inline bool log_gather_item_flow::has_sequence() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_item_flow::set_has_sequence() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_item_flow::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_item_flow::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 log_gather_item_flow::sequence() const {
  return sequence_;
}
inline void log_gather_item_flow::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 iGoodsType = 9;
inline bool log_gather_item_flow::has_igoodstype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_item_flow::set_has_igoodstype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_item_flow::clear_has_igoodstype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_item_flow::clear_igoodstype() {
  igoodstype_ = 0;
  clear_has_igoodstype();
}
inline ::google::protobuf::int32 log_gather_item_flow::igoodstype() const {
  return igoodstype_;
}
inline void log_gather_item_flow::set_igoodstype(::google::protobuf::int32 value) {
  set_has_igoodstype();
  igoodstype_ = value;
}

// optional int32 iGoodsId = 10;
inline bool log_gather_item_flow::has_igoodsid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_item_flow::set_has_igoodsid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_item_flow::clear_has_igoodsid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_item_flow::clear_igoodsid() {
  igoodsid_ = 0;
  clear_has_igoodsid();
}
inline ::google::protobuf::int32 log_gather_item_flow::igoodsid() const {
  return igoodsid_;
}
inline void log_gather_item_flow::set_igoodsid(::google::protobuf::int32 value) {
  set_has_igoodsid();
  igoodsid_ = value;
}

// optional int32 Count = 11;
inline bool log_gather_item_flow::has_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_item_flow::set_has_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_item_flow::clear_has_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_item_flow::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 log_gather_item_flow::count() const {
  return count_;
}
inline void log_gather_item_flow::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 AfterCount = 12;
inline bool log_gather_item_flow::has_aftercount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_item_flow::set_has_aftercount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_item_flow::clear_has_aftercount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_item_flow::clear_aftercount() {
  aftercount_ = 0;
  clear_has_aftercount();
}
inline ::google::protobuf::int32 log_gather_item_flow::aftercount() const {
  return aftercount_;
}
inline void log_gather_item_flow::set_aftercount(::google::protobuf::int32 value) {
  set_has_aftercount();
  aftercount_ = value;
}

// optional int32 Reason = 13;
inline bool log_gather_item_flow::has_reason() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_item_flow::set_has_reason() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_item_flow::clear_has_reason() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_item_flow::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 log_gather_item_flow::reason() const {
  return reason_;
}
inline void log_gather_item_flow::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// optional int32 SubReason = 14;
inline bool log_gather_item_flow::has_subreason() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_item_flow::set_has_subreason() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_item_flow::clear_has_subreason() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_item_flow::clear_subreason() {
  subreason_ = 0;
  clear_has_subreason();
}
inline ::google::protobuf::int32 log_gather_item_flow::subreason() const {
  return subreason_;
}
inline void log_gather_item_flow::set_subreason(::google::protobuf::int32 value) {
  set_has_subreason();
  subreason_ = value;
}

// optional int32 iMoney = 15;
inline bool log_gather_item_flow::has_imoney() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_item_flow::set_has_imoney() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_item_flow::clear_has_imoney() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_item_flow::clear_imoney() {
  imoney_ = 0;
  clear_has_imoney();
}
inline ::google::protobuf::int32 log_gather_item_flow::imoney() const {
  return imoney_;
}
inline void log_gather_item_flow::set_imoney(::google::protobuf::int32 value) {
  set_has_imoney();
  imoney_ = value;
}

// optional int32 iMoneyType = 16;
inline bool log_gather_item_flow::has_imoneytype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void log_gather_item_flow::set_has_imoneytype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void log_gather_item_flow::clear_has_imoneytype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void log_gather_item_flow::clear_imoneytype() {
  imoneytype_ = 0;
  clear_has_imoneytype();
}
inline ::google::protobuf::int32 log_gather_item_flow::imoneytype() const {
  return imoneytype_;
}
inline void log_gather_item_flow::set_imoneytype(::google::protobuf::int32 value) {
  set_has_imoneytype();
  imoneytype_ = value;
}

// optional int32 AddOrReduce = 17;
inline bool log_gather_item_flow::has_addorreduce() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void log_gather_item_flow::set_has_addorreduce() {
  _has_bits_[0] |= 0x00010000u;
}
inline void log_gather_item_flow::clear_has_addorreduce() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void log_gather_item_flow::clear_addorreduce() {
  addorreduce_ = 0;
  clear_has_addorreduce();
}
inline ::google::protobuf::int32 log_gather_item_flow::addorreduce() const {
  return addorreduce_;
}
inline void log_gather_item_flow::set_addorreduce(::google::protobuf::int32 value) {
  set_has_addorreduce();
  addorreduce_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_ItemFlow];
inline bool log_gather_item_flow::has_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void log_gather_item_flow::set_has_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void log_gather_item_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void log_gather_item_flow::clear_type() {
  type_ = 5;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_item_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_item_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_item_money_flow

// optional string GameSvrId = 1;
inline bool log_gather_item_money_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_item_money_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_item_money_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_item_money_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_item_money_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_item_money_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_item_money_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_item_money_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_money_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_item_money_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_money_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_item_money_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_item_money_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_item_money_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_item_money_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_item_money_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_item_money_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_item_money_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_item_money_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_money_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_item_money_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_money_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Sequence = 3;
inline bool log_gather_item_money_flow::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_item_money_flow::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_item_money_flow::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_item_money_flow::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::sequence() const {
  return sequence_;
}
inline void log_gather_item_money_flow::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional string GameAppID = 4;
inline bool log_gather_item_money_flow::has_gameappid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_item_money_flow::set_has_gameappid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_item_money_flow::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_item_money_flow::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_item_money_flow::gameappid() const {
  return *gameappid_;
}
inline void log_gather_item_money_flow::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_item_money_flow::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_item_money_flow::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_money_flow::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_item_money_flow::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_money_flow::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OpenID = 5;
inline bool log_gather_item_money_flow::has_openid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_item_money_flow::set_has_openid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_item_money_flow::clear_has_openid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_item_money_flow::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_item_money_flow::openid() const {
  return *openid_;
}
inline void log_gather_item_money_flow::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_item_money_flow::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_item_money_flow::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_item_money_flow::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_item_money_flow::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_item_money_flow::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 6;
inline bool log_gather_item_money_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_item_money_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_item_money_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_item_money_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::platid() const {
  return platid_;
}
inline void log_gather_item_money_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 ItemType = 7;
inline bool log_gather_item_money_flow::has_itemtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_item_money_flow::set_has_itemtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_item_money_flow::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_item_money_flow::clear_itemtype() {
  itemtype_ = 0;
  clear_has_itemtype();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::itemtype() const {
  return itemtype_;
}
inline void log_gather_item_money_flow::set_itemtype(::google::protobuf::int32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// optional int32 ItemId = 8;
inline bool log_gather_item_money_flow::has_itemid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_item_money_flow::set_has_itemid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_item_money_flow::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_item_money_flow::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::itemid() const {
  return itemid_;
}
inline void log_gather_item_money_flow::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 Count = 9;
inline bool log_gather_item_money_flow::has_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_item_money_flow::set_has_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_item_money_flow::clear_has_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_item_money_flow::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::count() const {
  return count_;
}
inline void log_gather_item_money_flow::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 Money = 10;
inline bool log_gather_item_money_flow::has_money() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_item_money_flow::set_has_money() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_item_money_flow::clear_has_money() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_item_money_flow::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::money() const {
  return money_;
}
inline void log_gather_item_money_flow::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 Level = 11;
inline bool log_gather_item_money_flow::has_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_item_money_flow::set_has_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_item_money_flow::clear_has_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_item_money_flow::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::level() const {
  return level_;
}
inline void log_gather_item_money_flow::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 MoneyType = 12;
inline bool log_gather_item_money_flow::has_moneytype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_item_money_flow::set_has_moneytype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_item_money_flow::clear_has_moneytype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_item_money_flow::clear_moneytype() {
  moneytype_ = 0;
  clear_has_moneytype();
}
inline ::google::protobuf::int32 log_gather_item_money_flow::moneytype() const {
  return moneytype_;
}
inline void log_gather_item_money_flow::set_moneytype(::google::protobuf::int32 value) {
  set_has_moneytype();
  moneytype_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_ItemMoneyFlow];
inline bool log_gather_item_money_flow::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_item_money_flow::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_item_money_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_item_money_flow::clear_type() {
  type_ = 6;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_item_money_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_item_money_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_player_exp_flow

// optional string GameSvrId = 1;
inline bool log_gather_player_exp_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_player_exp_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_player_exp_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_player_exp_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_player_exp_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_player_exp_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_exp_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_player_exp_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_exp_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_player_exp_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_exp_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_player_exp_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_player_exp_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_player_exp_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_player_exp_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_player_exp_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_player_exp_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_exp_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_player_exp_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_exp_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_player_exp_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_exp_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GameAppID = 3;
inline bool log_gather_player_exp_flow::has_gameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_player_exp_flow::set_has_gameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_player_exp_flow::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_player_exp_flow::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_player_exp_flow::gameappid() const {
  return *gameappid_;
}
inline void log_gather_player_exp_flow::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_exp_flow::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_player_exp_flow::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_exp_flow::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_player_exp_flow::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_exp_flow::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OpenID = 4;
inline bool log_gather_player_exp_flow::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_player_exp_flow::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_player_exp_flow::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_player_exp_flow::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_player_exp_flow::openid() const {
  return *openid_;
}
inline void log_gather_player_exp_flow::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_exp_flow::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_player_exp_flow::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_player_exp_flow::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_player_exp_flow::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_player_exp_flow::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 5;
inline bool log_gather_player_exp_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_player_exp_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_player_exp_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_player_exp_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::platid() const {
  return platid_;
}
inline void log_gather_player_exp_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 ExpChange = 6;
inline bool log_gather_player_exp_flow::has_expchange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_player_exp_flow::set_has_expchange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_player_exp_flow::clear_has_expchange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_player_exp_flow::clear_expchange() {
  expchange_ = 0;
  clear_has_expchange();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::expchange() const {
  return expchange_;
}
inline void log_gather_player_exp_flow::set_expchange(::google::protobuf::int32 value) {
  set_has_expchange();
  expchange_ = value;
}

// optional int32 BeforeLevel = 7;
inline bool log_gather_player_exp_flow::has_beforelevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_player_exp_flow::set_has_beforelevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_player_exp_flow::clear_has_beforelevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_player_exp_flow::clear_beforelevel() {
  beforelevel_ = 0;
  clear_has_beforelevel();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::beforelevel() const {
  return beforelevel_;
}
inline void log_gather_player_exp_flow::set_beforelevel(::google::protobuf::int32 value) {
  set_has_beforelevel();
  beforelevel_ = value;
}

// optional int32 AfterLevel = 8;
inline bool log_gather_player_exp_flow::has_afterlevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_player_exp_flow::set_has_afterlevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_player_exp_flow::clear_has_afterlevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_player_exp_flow::clear_afterlevel() {
  afterlevel_ = 0;
  clear_has_afterlevel();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::afterlevel() const {
  return afterlevel_;
}
inline void log_gather_player_exp_flow::set_afterlevel(::google::protobuf::int32 value) {
  set_has_afterlevel();
  afterlevel_ = value;
}

// optional int32 Time = 9;
inline bool log_gather_player_exp_flow::has_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_player_exp_flow::set_has_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_player_exp_flow::clear_has_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_player_exp_flow::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::time() const {
  return time_;
}
inline void log_gather_player_exp_flow::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 Reason = 10;
inline bool log_gather_player_exp_flow::has_reason() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_player_exp_flow::set_has_reason() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_player_exp_flow::clear_has_reason() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_player_exp_flow::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::reason() const {
  return reason_;
}
inline void log_gather_player_exp_flow::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// optional int32 SubReason = 11;
inline bool log_gather_player_exp_flow::has_subreason() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_player_exp_flow::set_has_subreason() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_player_exp_flow::clear_has_subreason() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_player_exp_flow::clear_subreason() {
  subreason_ = 0;
  clear_has_subreason();
}
inline ::google::protobuf::int32 log_gather_player_exp_flow::subreason() const {
  return subreason_;
}
inline void log_gather_player_exp_flow::set_subreason(::google::protobuf::int32 value) {
  set_has_subreason();
  subreason_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_PlayerExpFlow];
inline bool log_gather_player_exp_flow::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_player_exp_flow::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_player_exp_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_player_exp_flow::clear_type() {
  type_ = 7;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_player_exp_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_player_exp_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_sns_flow

// optional string GameSvrId = 1;
inline bool log_gather_sns_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_sns_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_sns_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_sns_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_sns_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_sns_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_sns_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_sns_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_sns_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_sns_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_sns_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_sns_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_sns_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_sns_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_sns_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_sns_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_sns_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_sns_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_sns_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_sns_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_sns_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_sns_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GameAppID = 3;
inline bool log_gather_sns_flow::has_gameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_sns_flow::set_has_gameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_sns_flow::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_sns_flow::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_sns_flow::gameappid() const {
  return *gameappid_;
}
inline void log_gather_sns_flow::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_sns_flow::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_sns_flow::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_sns_flow::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_sns_flow::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_sns_flow::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 4;
inline bool log_gather_sns_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_sns_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_sns_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_sns_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_sns_flow::platid() const {
  return platid_;
}
inline void log_gather_sns_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional string ActorOpenID = 5;
inline bool log_gather_sns_flow::has_actoropenid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_sns_flow::set_has_actoropenid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_sns_flow::clear_has_actoropenid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_sns_flow::clear_actoropenid() {
  if (actoropenid_ != &::google::protobuf::internal::kEmptyString) {
    actoropenid_->clear();
  }
  clear_has_actoropenid();
}
inline const ::std::string& log_gather_sns_flow::actoropenid() const {
  return *actoropenid_;
}
inline void log_gather_sns_flow::set_actoropenid(const ::std::string& value) {
  set_has_actoropenid();
  if (actoropenid_ == &::google::protobuf::internal::kEmptyString) {
    actoropenid_ = new ::std::string;
  }
  actoropenid_->assign(value);
}
inline void log_gather_sns_flow::set_actoropenid(const char* value) {
  set_has_actoropenid();
  if (actoropenid_ == &::google::protobuf::internal::kEmptyString) {
    actoropenid_ = new ::std::string;
  }
  actoropenid_->assign(value);
}
inline void log_gather_sns_flow::set_actoropenid(const char* value, size_t size) {
  set_has_actoropenid();
  if (actoropenid_ == &::google::protobuf::internal::kEmptyString) {
    actoropenid_ = new ::std::string;
  }
  actoropenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_sns_flow::mutable_actoropenid() {
  set_has_actoropenid();
  if (actoropenid_ == &::google::protobuf::internal::kEmptyString) {
    actoropenid_ = new ::std::string;
  }
  return actoropenid_;
}
inline ::std::string* log_gather_sns_flow::release_actoropenid() {
  clear_has_actoropenid();
  if (actoropenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actoropenid_;
    actoropenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_sns_flow::set_allocated_actoropenid(::std::string* actoropenid) {
  if (actoropenid_ != &::google::protobuf::internal::kEmptyString) {
    delete actoropenid_;
  }
  if (actoropenid) {
    set_has_actoropenid();
    actoropenid_ = actoropenid;
  } else {
    clear_has_actoropenid();
    actoropenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 RecNum = 6;
inline bool log_gather_sns_flow::has_recnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_sns_flow::set_has_recnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_sns_flow::clear_has_recnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_sns_flow::clear_recnum() {
  recnum_ = 0;
  clear_has_recnum();
}
inline ::google::protobuf::int32 log_gather_sns_flow::recnum() const {
  return recnum_;
}
inline void log_gather_sns_flow::set_recnum(::google::protobuf::int32 value) {
  set_has_recnum();
  recnum_ = value;
}

// optional int32 Count = 7;
inline bool log_gather_sns_flow::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_sns_flow::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_sns_flow::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_sns_flow::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 log_gather_sns_flow::count() const {
  return count_;
}
inline void log_gather_sns_flow::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 SNSType = 8;
inline bool log_gather_sns_flow::has_snstype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_sns_flow::set_has_snstype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_sns_flow::clear_has_snstype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_sns_flow::clear_snstype() {
  snstype_ = 0;
  clear_has_snstype();
}
inline ::google::protobuf::int32 log_gather_sns_flow::snstype() const {
  return snstype_;
}
inline void log_gather_sns_flow::set_snstype(::google::protobuf::int32 value) {
  set_has_snstype();
  snstype_ = value;
}

// optional int32 SNSSubType = 9;
inline bool log_gather_sns_flow::has_snssubtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_sns_flow::set_has_snssubtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_sns_flow::clear_has_snssubtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_sns_flow::clear_snssubtype() {
  snssubtype_ = 0;
  clear_has_snssubtype();
}
inline ::google::protobuf::int32 log_gather_sns_flow::snssubtype() const {
  return snssubtype_;
}
inline void log_gather_sns_flow::set_snssubtype(::google::protobuf::int32 value) {
  set_has_snssubtype();
  snssubtype_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_SnsFlow];
inline bool log_gather_sns_flow::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_sns_flow::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_sns_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_sns_flow::clear_type() {
  type_ = 8;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_sns_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_sns_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_round_flow

// optional string GameSvrId = 1;
inline bool log_gather_round_flow::has_gamesvrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_round_flow::set_has_gamesvrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_round_flow::clear_has_gamesvrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_round_flow::clear_gamesvrid() {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    gamesvrid_->clear();
  }
  clear_has_gamesvrid();
}
inline const ::std::string& log_gather_round_flow::gamesvrid() const {
  return *gamesvrid_;
}
inline void log_gather_round_flow::set_gamesvrid(const ::std::string& value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_round_flow::set_gamesvrid(const char* value) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(value);
}
inline void log_gather_round_flow::set_gamesvrid(const char* value, size_t size) {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  gamesvrid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_round_flow::mutable_gamesvrid() {
  set_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    gamesvrid_ = new ::std::string;
  }
  return gamesvrid_;
}
inline ::std::string* log_gather_round_flow::release_gamesvrid() {
  clear_has_gamesvrid();
  if (gamesvrid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamesvrid_;
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_round_flow::set_allocated_gamesvrid(::std::string* gamesvrid) {
  if (gamesvrid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamesvrid_;
  }
  if (gamesvrid) {
    set_has_gamesvrid();
    gamesvrid_ = gamesvrid;
  } else {
    clear_has_gamesvrid();
    gamesvrid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dtEventTime = 2;
inline bool log_gather_round_flow::has_dteventtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_round_flow::set_has_dteventtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_round_flow::clear_has_dteventtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_round_flow::clear_dteventtime() {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    dteventtime_->clear();
  }
  clear_has_dteventtime();
}
inline const ::std::string& log_gather_round_flow::dteventtime() const {
  return *dteventtime_;
}
inline void log_gather_round_flow::set_dteventtime(const ::std::string& value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_round_flow::set_dteventtime(const char* value) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(value);
}
inline void log_gather_round_flow::set_dteventtime(const char* value, size_t size) {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  dteventtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_round_flow::mutable_dteventtime() {
  set_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    dteventtime_ = new ::std::string;
  }
  return dteventtime_;
}
inline ::std::string* log_gather_round_flow::release_dteventtime() {
  clear_has_dteventtime();
  if (dteventtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dteventtime_;
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_round_flow::set_allocated_dteventtime(::std::string* dteventtime) {
  if (dteventtime_ != &::google::protobuf::internal::kEmptyString) {
    delete dteventtime_;
  }
  if (dteventtime) {
    set_has_dteventtime();
    dteventtime_ = dteventtime;
  } else {
    clear_has_dteventtime();
    dteventtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string GameAppID = 3;
inline bool log_gather_round_flow::has_gameappid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_round_flow::set_has_gameappid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_round_flow::clear_has_gameappid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_round_flow::clear_gameappid() {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    gameappid_->clear();
  }
  clear_has_gameappid();
}
inline const ::std::string& log_gather_round_flow::gameappid() const {
  return *gameappid_;
}
inline void log_gather_round_flow::set_gameappid(const ::std::string& value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_round_flow::set_gameappid(const char* value) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(value);
}
inline void log_gather_round_flow::set_gameappid(const char* value, size_t size) {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  gameappid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_round_flow::mutable_gameappid() {
  set_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    gameappid_ = new ::std::string;
  }
  return gameappid_;
}
inline ::std::string* log_gather_round_flow::release_gameappid() {
  clear_has_gameappid();
  if (gameappid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameappid_;
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_round_flow::set_allocated_gameappid(::std::string* gameappid) {
  if (gameappid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameappid_;
  }
  if (gameappid) {
    set_has_gameappid();
    gameappid_ = gameappid;
  } else {
    clear_has_gameappid();
    gameappid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OpenID = 4;
inline bool log_gather_round_flow::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_round_flow::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_round_flow::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_round_flow::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_round_flow::openid() const {
  return *openid_;
}
inline void log_gather_round_flow::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_round_flow::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_round_flow::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_round_flow::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_round_flow::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_round_flow::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlatID = 5;
inline bool log_gather_round_flow::has_platid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_round_flow::set_has_platid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_round_flow::clear_has_platid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_round_flow::clear_platid() {
  platid_ = 0;
  clear_has_platid();
}
inline ::google::protobuf::int32 log_gather_round_flow::platid() const {
  return platid_;
}
inline void log_gather_round_flow::set_platid(::google::protobuf::int32 value) {
  set_has_platid();
  platid_ = value;
}

// optional int32 BattleID = 6;
inline bool log_gather_round_flow::has_battleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_round_flow::set_has_battleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_round_flow::clear_has_battleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_round_flow::clear_battleid() {
  battleid_ = 0;
  clear_has_battleid();
}
inline ::google::protobuf::int32 log_gather_round_flow::battleid() const {
  return battleid_;
}
inline void log_gather_round_flow::set_battleid(::google::protobuf::int32 value) {
  set_has_battleid();
  battleid_ = value;
}

// optional int32 BattleType = 7;
inline bool log_gather_round_flow::has_battletype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_round_flow::set_has_battletype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_round_flow::clear_has_battletype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_round_flow::clear_battletype() {
  battletype_ = 0;
  clear_has_battletype();
}
inline ::google::protobuf::int32 log_gather_round_flow::battletype() const {
  return battletype_;
}
inline void log_gather_round_flow::set_battletype(::google::protobuf::int32 value) {
  set_has_battletype();
  battletype_ = value;
}

// optional int32 RoundScore = 8;
inline bool log_gather_round_flow::has_roundscore() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_round_flow::set_has_roundscore() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_round_flow::clear_has_roundscore() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_round_flow::clear_roundscore() {
  roundscore_ = 0;
  clear_has_roundscore();
}
inline ::google::protobuf::int32 log_gather_round_flow::roundscore() const {
  return roundscore_;
}
inline void log_gather_round_flow::set_roundscore(::google::protobuf::int32 value) {
  set_has_roundscore();
  roundscore_ = value;
}

// optional int32 RoundTime = 9;
inline bool log_gather_round_flow::has_roundtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_round_flow::set_has_roundtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_round_flow::clear_has_roundtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_round_flow::clear_roundtime() {
  roundtime_ = 0;
  clear_has_roundtime();
}
inline ::google::protobuf::int32 log_gather_round_flow::roundtime() const {
  return roundtime_;
}
inline void log_gather_round_flow::set_roundtime(::google::protobuf::int32 value) {
  set_has_roundtime();
  roundtime_ = value;
}

// optional int32 Result = 10;
inline bool log_gather_round_flow::has_result() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_round_flow::set_has_result() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_round_flow::clear_has_result() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_round_flow::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 log_gather_round_flow::result() const {
  return result_;
}
inline void log_gather_round_flow::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 Rank = 11;
inline bool log_gather_round_flow::has_rank() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_round_flow::set_has_rank() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_round_flow::clear_has_rank() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_round_flow::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 log_gather_round_flow::rank() const {
  return rank_;
}
inline void log_gather_round_flow::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 Gold = 12;
inline bool log_gather_round_flow::has_gold() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_round_flow::set_has_gold() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_round_flow::clear_has_gold() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_round_flow::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 log_gather_round_flow::gold() const {
  return gold_;
}
inline void log_gather_round_flow::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// optional .SProtoSpace.EConomicAnalysisType Type = 100 [default = EConomicAnalysisType_RoundFlow];
inline bool log_gather_round_flow::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_round_flow::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_round_flow::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_round_flow::clear_type() {
  type_ = 9;
  clear_has_type();
}
inline ::SProtoSpace::EConomicAnalysisType log_gather_round_flow::type() const {
  return static_cast< ::SProtoSpace::EConomicAnalysisType >(type_);
}
inline void log_gather_round_flow::set_type(::SProtoSpace::EConomicAnalysisType value) {
  assert(::SProtoSpace::EConomicAnalysisType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// log_gather_role_info

// optional uint32 event_id = 1 [default = 1];
inline bool log_gather_role_info::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_role_info::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_role_info::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_role_info::clear_event_id() {
  event_id_ = 1u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 log_gather_role_info::event_id() const {
  return event_id_;
}
inline void log_gather_role_info::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 event_time = 2;
inline bool log_gather_role_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_role_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_role_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_role_info::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 log_gather_role_info::event_time() const {
  return event_time_;
}
inline void log_gather_role_info::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string appid = 3;
inline bool log_gather_role_info::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_role_info::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_role_info::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_role_info::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& log_gather_role_info::appid() const {
  return *appid_;
}
inline void log_gather_role_info::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_role_info::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_role_info::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* log_gather_role_info::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 4;
inline bool log_gather_role_info::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_role_info::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_role_info::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_role_info::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_role_info::openid() const {
  return *openid_;
}
inline void log_gather_role_info::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_role_info::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_role_info::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_role_info::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 zone_id = 5;
inline bool log_gather_role_info::has_zone_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_role_info::set_has_zone_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_role_info::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_role_info::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 log_gather_role_info::zone_id() const {
  return zone_id_;
}
inline void log_gather_role_info::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
}

// optional string zone_name = 6;
inline bool log_gather_role_info::has_zone_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_role_info::set_has_zone_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_role_info::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_role_info::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& log_gather_role_info::zone_name() const {
  return *zone_name_;
}
inline void log_gather_role_info::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_role_info::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_role_info::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* log_gather_role_info::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_zone_name(::std::string* zone_name) {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_name_;
  }
  if (zone_name) {
    set_has_zone_name();
    zone_name_ = zone_name;
  } else {
    clear_has_zone_name();
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform = 7;
inline bool log_gather_role_info::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_role_info::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_role_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_role_info::clear_platform() {
  platform_ = 0u;
  clear_has_platform();
}
inline ::google::protobuf::uint32 log_gather_role_info::platform() const {
  return platform_;
}
inline void log_gather_role_info::set_platform(::google::protobuf::uint32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string imei = 8;
inline bool log_gather_role_info::has_imei() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_role_info::set_has_imei() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_role_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_role_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& log_gather_role_info::imei() const {
  return *imei_;
}
inline void log_gather_role_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_role_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_role_info::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* log_gather_role_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 9;
inline bool log_gather_role_info::has_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_role_info::set_has_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_role_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_role_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 log_gather_role_info::level() const {
  return level_;
}
inline void log_gather_role_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string name = 10;
inline bool log_gather_role_info::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_role_info::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_role_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_role_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& log_gather_role_info::name() const {
  return *name_;
}
inline void log_gather_role_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_role_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_role_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* log_gather_role_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 fight_value = 11;
inline bool log_gather_role_info::has_fight_value() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_role_info::set_has_fight_value() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_role_info::clear_has_fight_value() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_role_info::clear_fight_value() {
  fight_value_ = GOOGLE_ULONGLONG(0);
  clear_has_fight_value();
}
inline ::google::protobuf::uint64 log_gather_role_info::fight_value() const {
  return fight_value_;
}
inline void log_gather_role_info::set_fight_value(::google::protobuf::uint64 value) {
  set_has_fight_value();
  fight_value_ = value;
}

// optional string profession = 12;
inline bool log_gather_role_info::has_profession() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_role_info::set_has_profession() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_role_info::clear_has_profession() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_role_info::clear_profession() {
  if (profession_ != &::google::protobuf::internal::kEmptyString) {
    profession_->clear();
  }
  clear_has_profession();
}
inline const ::std::string& log_gather_role_info::profession() const {
  return *profession_;
}
inline void log_gather_role_info::set_profession(const ::std::string& value) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(value);
}
inline void log_gather_role_info::set_profession(const char* value) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(value);
}
inline void log_gather_role_info::set_profession(const char* value, size_t size) {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  profession_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_role_info::mutable_profession() {
  set_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    profession_ = new ::std::string;
  }
  return profession_;
}
inline ::std::string* log_gather_role_info::release_profession() {
  clear_has_profession();
  if (profession_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profession_;
    profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_role_info::set_allocated_profession(::std::string* profession) {
  if (profession_ != &::google::protobuf::internal::kEmptyString) {
    delete profession_;
  }
  if (profession) {
    set_has_profession();
    profession_ = profession;
  } else {
    clear_has_profession();
    profession_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pay_total = 13;
inline bool log_gather_role_info::has_pay_total() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_role_info::set_has_pay_total() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_role_info::clear_has_pay_total() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_role_info::clear_pay_total() {
  pay_total_ = 0u;
  clear_has_pay_total();
}
inline ::google::protobuf::uint32 log_gather_role_info::pay_total() const {
  return pay_total_;
}
inline void log_gather_role_info::set_pay_total(::google::protobuf::uint32 value) {
  set_has_pay_total();
  pay_total_ = value;
}

// optional uint32 coin_1 = 14;
inline bool log_gather_role_info::has_coin_1() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_role_info::set_has_coin_1() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_role_info::clear_has_coin_1() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_role_info::clear_coin_1() {
  coin_1_ = 0u;
  clear_has_coin_1();
}
inline ::google::protobuf::uint32 log_gather_role_info::coin_1() const {
  return coin_1_;
}
inline void log_gather_role_info::set_coin_1(::google::protobuf::uint32 value) {
  set_has_coin_1();
  coin_1_ = value;
}

// optional uint32 coin_2 = 15;
inline bool log_gather_role_info::has_coin_2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_role_info::set_has_coin_2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_role_info::clear_has_coin_2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_role_info::clear_coin_2() {
  coin_2_ = 0u;
  clear_has_coin_2();
}
inline ::google::protobuf::uint32 log_gather_role_info::coin_2() const {
  return coin_2_;
}
inline void log_gather_role_info::set_coin_2(::google::protobuf::uint32 value) {
  set_has_coin_2();
  coin_2_ = value;
}

// optional uint32 vip_level = 16;
inline bool log_gather_role_info::has_vip_level() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void log_gather_role_info::set_has_vip_level() {
  _has_bits_[0] |= 0x00008000u;
}
inline void log_gather_role_info::clear_has_vip_level() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void log_gather_role_info::clear_vip_level() {
  vip_level_ = 0u;
  clear_has_vip_level();
}
inline ::google::protobuf::uint32 log_gather_role_info::vip_level() const {
  return vip_level_;
}
inline void log_gather_role_info::set_vip_level(::google::protobuf::uint32 value) {
  set_has_vip_level();
  vip_level_ = value;
}

// -------------------------------------------------------------------

// log_gather_task_info

// optional uint32 event_id = 1 [default = 2];
inline bool log_gather_task_info::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_task_info::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_task_info::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_task_info::clear_event_id() {
  event_id_ = 2u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 log_gather_task_info::event_id() const {
  return event_id_;
}
inline void log_gather_task_info::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 event_time = 2;
inline bool log_gather_task_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_task_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_task_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_task_info::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 log_gather_task_info::event_time() const {
  return event_time_;
}
inline void log_gather_task_info::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string appid = 3;
inline bool log_gather_task_info::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_task_info::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_task_info::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_task_info::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& log_gather_task_info::appid() const {
  return *appid_;
}
inline void log_gather_task_info::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_task_info::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_task_info::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* log_gather_task_info::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 4;
inline bool log_gather_task_info::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_task_info::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_task_info::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_task_info::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_task_info::openid() const {
  return *openid_;
}
inline void log_gather_task_info::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_task_info::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_task_info::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_task_info::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 zone_id = 5;
inline bool log_gather_task_info::has_zone_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_task_info::set_has_zone_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_task_info::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_task_info::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 log_gather_task_info::zone_id() const {
  return zone_id_;
}
inline void log_gather_task_info::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
}

// optional string zone_name = 6;
inline bool log_gather_task_info::has_zone_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_task_info::set_has_zone_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_task_info::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_task_info::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& log_gather_task_info::zone_name() const {
  return *zone_name_;
}
inline void log_gather_task_info::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_task_info::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_task_info::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* log_gather_task_info::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_zone_name(::std::string* zone_name) {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_name_;
  }
  if (zone_name) {
    set_has_zone_name();
    zone_name_ = zone_name;
  } else {
    clear_has_zone_name();
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform = 7;
inline bool log_gather_task_info::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_task_info::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_task_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_task_info::clear_platform() {
  platform_ = 0u;
  clear_has_platform();
}
inline ::google::protobuf::uint32 log_gather_task_info::platform() const {
  return platform_;
}
inline void log_gather_task_info::set_platform(::google::protobuf::uint32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string imei = 8;
inline bool log_gather_task_info::has_imei() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_task_info::set_has_imei() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_task_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_task_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& log_gather_task_info::imei() const {
  return *imei_;
}
inline void log_gather_task_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_task_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_task_info::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* log_gather_task_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 task_id = 9;
inline bool log_gather_task_info::has_task_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_task_info::set_has_task_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_task_info::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_task_info::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 log_gather_task_info::task_id() const {
  return task_id_;
}
inline void log_gather_task_info::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional string task_name = 10;
inline bool log_gather_task_info::has_task_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_task_info::set_has_task_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_task_info::clear_has_task_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_task_info::clear_task_name() {
  if (task_name_ != &::google::protobuf::internal::kEmptyString) {
    task_name_->clear();
  }
  clear_has_task_name();
}
inline const ::std::string& log_gather_task_info::task_name() const {
  return *task_name_;
}
inline void log_gather_task_info::set_task_name(const ::std::string& value) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::kEmptyString) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(value);
}
inline void log_gather_task_info::set_task_name(const char* value) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::kEmptyString) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(value);
}
inline void log_gather_task_info::set_task_name(const char* value, size_t size) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::kEmptyString) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_task_name() {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::kEmptyString) {
    task_name_ = new ::std::string;
  }
  return task_name_;
}
inline ::std::string* log_gather_task_info::release_task_name() {
  clear_has_task_name();
  if (task_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_name_;
    task_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_task_name(::std::string* task_name) {
  if (task_name_ != &::google::protobuf::internal::kEmptyString) {
    delete task_name_;
  }
  if (task_name) {
    set_has_task_name();
    task_name_ = task_name;
  } else {
    clear_has_task_name();
    task_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 11;
inline bool log_gather_task_info::has_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_task_info::set_has_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_task_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_task_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 log_gather_task_info::status() const {
  return status_;
}
inline void log_gather_task_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional string task_detail = 12;
inline bool log_gather_task_info::has_task_detail() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_task_info::set_has_task_detail() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_task_info::clear_has_task_detail() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_task_info::clear_task_detail() {
  if (task_detail_ != &::google::protobuf::internal::kEmptyString) {
    task_detail_->clear();
  }
  clear_has_task_detail();
}
inline const ::std::string& log_gather_task_info::task_detail() const {
  return *task_detail_;
}
inline void log_gather_task_info::set_task_detail(const ::std::string& value) {
  set_has_task_detail();
  if (task_detail_ == &::google::protobuf::internal::kEmptyString) {
    task_detail_ = new ::std::string;
  }
  task_detail_->assign(value);
}
inline void log_gather_task_info::set_task_detail(const char* value) {
  set_has_task_detail();
  if (task_detail_ == &::google::protobuf::internal::kEmptyString) {
    task_detail_ = new ::std::string;
  }
  task_detail_->assign(value);
}
inline void log_gather_task_info::set_task_detail(const char* value, size_t size) {
  set_has_task_detail();
  if (task_detail_ == &::google::protobuf::internal::kEmptyString) {
    task_detail_ = new ::std::string;
  }
  task_detail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_task_info::mutable_task_detail() {
  set_has_task_detail();
  if (task_detail_ == &::google::protobuf::internal::kEmptyString) {
    task_detail_ = new ::std::string;
  }
  return task_detail_;
}
inline ::std::string* log_gather_task_info::release_task_detail() {
  clear_has_task_detail();
  if (task_detail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_detail_;
    task_detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_task_info::set_allocated_task_detail(::std::string* task_detail) {
  if (task_detail_ != &::google::protobuf::internal::kEmptyString) {
    delete task_detail_;
  }
  if (task_detail) {
    set_has_task_detail();
    task_detail_ = task_detail;
  } else {
    clear_has_task_detail();
    task_detail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// log_gather_honor_info

// optional uint32 event_id = 1 [default = 3];
inline bool log_gather_honor_info::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_honor_info::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_honor_info::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_honor_info::clear_event_id() {
  event_id_ = 3u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 log_gather_honor_info::event_id() const {
  return event_id_;
}
inline void log_gather_honor_info::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 event_time = 2;
inline bool log_gather_honor_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_honor_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_honor_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_honor_info::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 log_gather_honor_info::event_time() const {
  return event_time_;
}
inline void log_gather_honor_info::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string appid = 3;
inline bool log_gather_honor_info::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_honor_info::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_honor_info::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_honor_info::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& log_gather_honor_info::appid() const {
  return *appid_;
}
inline void log_gather_honor_info::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_honor_info::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_honor_info::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_honor_info::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* log_gather_honor_info::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_honor_info::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 4;
inline bool log_gather_honor_info::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_honor_info::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_honor_info::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_honor_info::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_honor_info::openid() const {
  return *openid_;
}
inline void log_gather_honor_info::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_honor_info::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_honor_info::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_honor_info::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_honor_info::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_honor_info::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 zone_id = 5;
inline bool log_gather_honor_info::has_zone_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_honor_info::set_has_zone_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_honor_info::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_honor_info::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 log_gather_honor_info::zone_id() const {
  return zone_id_;
}
inline void log_gather_honor_info::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
}

// optional string zone_name = 6;
inline bool log_gather_honor_info::has_zone_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_honor_info::set_has_zone_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_honor_info::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_honor_info::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& log_gather_honor_info::zone_name() const {
  return *zone_name_;
}
inline void log_gather_honor_info::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_honor_info::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_honor_info::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_honor_info::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* log_gather_honor_info::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_honor_info::set_allocated_zone_name(::std::string* zone_name) {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_name_;
  }
  if (zone_name) {
    set_has_zone_name();
    zone_name_ = zone_name;
  } else {
    clear_has_zone_name();
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform = 7;
inline bool log_gather_honor_info::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_honor_info::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_honor_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_honor_info::clear_platform() {
  platform_ = 0u;
  clear_has_platform();
}
inline ::google::protobuf::uint32 log_gather_honor_info::platform() const {
  return platform_;
}
inline void log_gather_honor_info::set_platform(::google::protobuf::uint32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string imei = 8;
inline bool log_gather_honor_info::has_imei() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_honor_info::set_has_imei() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_honor_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_honor_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& log_gather_honor_info::imei() const {
  return *imei_;
}
inline void log_gather_honor_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_honor_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_honor_info::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_honor_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* log_gather_honor_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_honor_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 honor_id = 9;
inline bool log_gather_honor_info::has_honor_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_honor_info::set_has_honor_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_honor_info::clear_has_honor_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_honor_info::clear_honor_id() {
  honor_id_ = 0u;
  clear_has_honor_id();
}
inline ::google::protobuf::uint32 log_gather_honor_info::honor_id() const {
  return honor_id_;
}
inline void log_gather_honor_info::set_honor_id(::google::protobuf::uint32 value) {
  set_has_honor_id();
  honor_id_ = value;
}

// optional string honor_name = 10;
inline bool log_gather_honor_info::has_honor_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_honor_info::set_has_honor_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_honor_info::clear_has_honor_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_honor_info::clear_honor_name() {
  if (honor_name_ != &::google::protobuf::internal::kEmptyString) {
    honor_name_->clear();
  }
  clear_has_honor_name();
}
inline const ::std::string& log_gather_honor_info::honor_name() const {
  return *honor_name_;
}
inline void log_gather_honor_info::set_honor_name(const ::std::string& value) {
  set_has_honor_name();
  if (honor_name_ == &::google::protobuf::internal::kEmptyString) {
    honor_name_ = new ::std::string;
  }
  honor_name_->assign(value);
}
inline void log_gather_honor_info::set_honor_name(const char* value) {
  set_has_honor_name();
  if (honor_name_ == &::google::protobuf::internal::kEmptyString) {
    honor_name_ = new ::std::string;
  }
  honor_name_->assign(value);
}
inline void log_gather_honor_info::set_honor_name(const char* value, size_t size) {
  set_has_honor_name();
  if (honor_name_ == &::google::protobuf::internal::kEmptyString) {
    honor_name_ = new ::std::string;
  }
  honor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_honor_info::mutable_honor_name() {
  set_has_honor_name();
  if (honor_name_ == &::google::protobuf::internal::kEmptyString) {
    honor_name_ = new ::std::string;
  }
  return honor_name_;
}
inline ::std::string* log_gather_honor_info::release_honor_name() {
  clear_has_honor_name();
  if (honor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = honor_name_;
    honor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_honor_info::set_allocated_honor_name(::std::string* honor_name) {
  if (honor_name_ != &::google::protobuf::internal::kEmptyString) {
    delete honor_name_;
  }
  if (honor_name) {
    set_has_honor_name();
    honor_name_ = honor_name;
  } else {
    clear_has_honor_name();
    honor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 honor_detail = 11;
inline bool log_gather_honor_info::has_honor_detail() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_honor_info::set_has_honor_detail() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_honor_info::clear_has_honor_detail() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_honor_info::clear_honor_detail() {
  honor_detail_ = 0u;
  clear_has_honor_detail();
}
inline ::google::protobuf::uint32 log_gather_honor_info::honor_detail() const {
  return honor_detail_;
}
inline void log_gather_honor_info::set_honor_detail(::google::protobuf::uint32 value) {
  set_has_honor_detail();
  honor_detail_ = value;
}

// -------------------------------------------------------------------

// log_gather_level_up_info

// optional uint32 event_id = 1 [default = 4];
inline bool log_gather_level_up_info::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_level_up_info::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_level_up_info::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_level_up_info::clear_event_id() {
  event_id_ = 4u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 log_gather_level_up_info::event_id() const {
  return event_id_;
}
inline void log_gather_level_up_info::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 event_time = 2;
inline bool log_gather_level_up_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_level_up_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_level_up_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_level_up_info::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 log_gather_level_up_info::event_time() const {
  return event_time_;
}
inline void log_gather_level_up_info::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string appid = 3;
inline bool log_gather_level_up_info::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_level_up_info::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_level_up_info::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_level_up_info::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& log_gather_level_up_info::appid() const {
  return *appid_;
}
inline void log_gather_level_up_info::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_level_up_info::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_level_up_info::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* log_gather_level_up_info::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 4;
inline bool log_gather_level_up_info::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_level_up_info::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_level_up_info::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_level_up_info::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_level_up_info::openid() const {
  return *openid_;
}
inline void log_gather_level_up_info::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_level_up_info::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_level_up_info::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_level_up_info::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 zone_id = 5;
inline bool log_gather_level_up_info::has_zone_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_level_up_info::set_has_zone_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_level_up_info::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_level_up_info::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 log_gather_level_up_info::zone_id() const {
  return zone_id_;
}
inline void log_gather_level_up_info::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
}

// optional string zone_name = 6;
inline bool log_gather_level_up_info::has_zone_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_level_up_info::set_has_zone_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_level_up_info::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_level_up_info::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& log_gather_level_up_info::zone_name() const {
  return *zone_name_;
}
inline void log_gather_level_up_info::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_level_up_info::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_level_up_info::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* log_gather_level_up_info::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_zone_name(::std::string* zone_name) {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_name_;
  }
  if (zone_name) {
    set_has_zone_name();
    zone_name_ = zone_name;
  } else {
    clear_has_zone_name();
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform = 7;
inline bool log_gather_level_up_info::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_level_up_info::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_level_up_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_level_up_info::clear_platform() {
  platform_ = 0u;
  clear_has_platform();
}
inline ::google::protobuf::uint32 log_gather_level_up_info::platform() const {
  return platform_;
}
inline void log_gather_level_up_info::set_platform(::google::protobuf::uint32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string imei = 8;
inline bool log_gather_level_up_info::has_imei() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_level_up_info::set_has_imei() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_level_up_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_level_up_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& log_gather_level_up_info::imei() const {
  return *imei_;
}
inline void log_gather_level_up_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_level_up_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_level_up_info::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* log_gather_level_up_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 new_level = 9;
inline bool log_gather_level_up_info::has_new_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_level_up_info::set_has_new_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_level_up_info::clear_has_new_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_level_up_info::clear_new_level() {
  new_level_ = 0u;
  clear_has_new_level();
}
inline ::google::protobuf::uint32 log_gather_level_up_info::new_level() const {
  return new_level_;
}
inline void log_gather_level_up_info::set_new_level(::google::protobuf::uint32 value) {
  set_has_new_level();
  new_level_ = value;
}

// optional string name = 10;
inline bool log_gather_level_up_info::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_level_up_info::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_level_up_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_level_up_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& log_gather_level_up_info::name() const {
  return *name_;
}
inline void log_gather_level_up_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_level_up_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_level_up_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* log_gather_level_up_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 old_level = 11;
inline bool log_gather_level_up_info::has_old_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_level_up_info::set_has_old_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_level_up_info::clear_has_old_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_level_up_info::clear_old_level() {
  old_level_ = 0u;
  clear_has_old_level();
}
inline ::google::protobuf::uint32 log_gather_level_up_info::old_level() const {
  return old_level_;
}
inline void log_gather_level_up_info::set_old_level(::google::protobuf::uint32 value) {
  set_has_old_level();
  old_level_ = value;
}

// optional string detail_desc = 12;
inline bool log_gather_level_up_info::has_detail_desc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_level_up_info::set_has_detail_desc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_level_up_info::clear_has_detail_desc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_level_up_info::clear_detail_desc() {
  if (detail_desc_ != &::google::protobuf::internal::kEmptyString) {
    detail_desc_->clear();
  }
  clear_has_detail_desc();
}
inline const ::std::string& log_gather_level_up_info::detail_desc() const {
  return *detail_desc_;
}
inline void log_gather_level_up_info::set_detail_desc(const ::std::string& value) {
  set_has_detail_desc();
  if (detail_desc_ == &::google::protobuf::internal::kEmptyString) {
    detail_desc_ = new ::std::string;
  }
  detail_desc_->assign(value);
}
inline void log_gather_level_up_info::set_detail_desc(const char* value) {
  set_has_detail_desc();
  if (detail_desc_ == &::google::protobuf::internal::kEmptyString) {
    detail_desc_ = new ::std::string;
  }
  detail_desc_->assign(value);
}
inline void log_gather_level_up_info::set_detail_desc(const char* value, size_t size) {
  set_has_detail_desc();
  if (detail_desc_ == &::google::protobuf::internal::kEmptyString) {
    detail_desc_ = new ::std::string;
  }
  detail_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_level_up_info::mutable_detail_desc() {
  set_has_detail_desc();
  if (detail_desc_ == &::google::protobuf::internal::kEmptyString) {
    detail_desc_ = new ::std::string;
  }
  return detail_desc_;
}
inline ::std::string* log_gather_level_up_info::release_detail_desc() {
  clear_has_detail_desc();
  if (detail_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detail_desc_;
    detail_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_level_up_info::set_allocated_detail_desc(::std::string* detail_desc) {
  if (detail_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete detail_desc_;
  }
  if (detail_desc) {
    set_has_detail_desc();
    detail_desc_ = detail_desc;
  } else {
    clear_has_detail_desc();
    detail_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// log_gather_buy_info

// optional uint32 event_id = 1 [default = 5];
inline bool log_gather_buy_info::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void log_gather_buy_info::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void log_gather_buy_info::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void log_gather_buy_info::clear_event_id() {
  event_id_ = 5u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 log_gather_buy_info::event_id() const {
  return event_id_;
}
inline void log_gather_buy_info::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint64 event_time = 2;
inline bool log_gather_buy_info::has_event_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void log_gather_buy_info::set_has_event_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void log_gather_buy_info::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void log_gather_buy_info::clear_event_time() {
  event_time_ = GOOGLE_ULONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::uint64 log_gather_buy_info::event_time() const {
  return event_time_;
}
inline void log_gather_buy_info::set_event_time(::google::protobuf::uint64 value) {
  set_has_event_time();
  event_time_ = value;
}

// optional string appid = 3;
inline bool log_gather_buy_info::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void log_gather_buy_info::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void log_gather_buy_info::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void log_gather_buy_info::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& log_gather_buy_info::appid() const {
  return *appid_;
}
inline void log_gather_buy_info::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_buy_info::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void log_gather_buy_info::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* log_gather_buy_info::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 4;
inline bool log_gather_buy_info::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void log_gather_buy_info::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void log_gather_buy_info::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void log_gather_buy_info::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& log_gather_buy_info::openid() const {
  return *openid_;
}
inline void log_gather_buy_info::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_buy_info::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void log_gather_buy_info::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* log_gather_buy_info::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 zone_id = 5;
inline bool log_gather_buy_info::has_zone_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void log_gather_buy_info::set_has_zone_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void log_gather_buy_info::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void log_gather_buy_info::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 log_gather_buy_info::zone_id() const {
  return zone_id_;
}
inline void log_gather_buy_info::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
}

// optional string zone_name = 6;
inline bool log_gather_buy_info::has_zone_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void log_gather_buy_info::set_has_zone_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void log_gather_buy_info::clear_has_zone_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void log_gather_buy_info::clear_zone_name() {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    zone_name_->clear();
  }
  clear_has_zone_name();
}
inline const ::std::string& log_gather_buy_info::zone_name() const {
  return *zone_name_;
}
inline void log_gather_buy_info::set_zone_name(const ::std::string& value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_buy_info::set_zone_name(const char* value) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(value);
}
inline void log_gather_buy_info::set_zone_name(const char* value, size_t size) {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  zone_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_zone_name() {
  set_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    zone_name_ = new ::std::string;
  }
  return zone_name_;
}
inline ::std::string* log_gather_buy_info::release_zone_name() {
  clear_has_zone_name();
  if (zone_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_name_;
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_zone_name(::std::string* zone_name) {
  if (zone_name_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_name_;
  }
  if (zone_name) {
    set_has_zone_name();
    zone_name_ = zone_name;
  } else {
    clear_has_zone_name();
    zone_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 platform = 7;
inline bool log_gather_buy_info::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void log_gather_buy_info::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void log_gather_buy_info::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void log_gather_buy_info::clear_platform() {
  platform_ = 0u;
  clear_has_platform();
}
inline ::google::protobuf::uint32 log_gather_buy_info::platform() const {
  return platform_;
}
inline void log_gather_buy_info::set_platform(::google::protobuf::uint32 value) {
  set_has_platform();
  platform_ = value;
}

// optional string imei = 8;
inline bool log_gather_buy_info::has_imei() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void log_gather_buy_info::set_has_imei() {
  _has_bits_[0] |= 0x00000080u;
}
inline void log_gather_buy_info::clear_has_imei() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void log_gather_buy_info::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& log_gather_buy_info::imei() const {
  return *imei_;
}
inline void log_gather_buy_info::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_buy_info::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void log_gather_buy_info::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* log_gather_buy_info::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 9;
inline bool log_gather_buy_info::has_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void log_gather_buy_info::set_has_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void log_gather_buy_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void log_gather_buy_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 log_gather_buy_info::level() const {
  return level_;
}
inline void log_gather_buy_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string name = 10;
inline bool log_gather_buy_info::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void log_gather_buy_info::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void log_gather_buy_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void log_gather_buy_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& log_gather_buy_info::name() const {
  return *name_;
}
inline void log_gather_buy_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_buy_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void log_gather_buy_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* log_gather_buy_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 item_id = 11;
inline bool log_gather_buy_info::has_item_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void log_gather_buy_info::set_has_item_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void log_gather_buy_info::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void log_gather_buy_info::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 log_gather_buy_info::item_id() const {
  return item_id_;
}
inline void log_gather_buy_info::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional string item_name = 12;
inline bool log_gather_buy_info::has_item_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void log_gather_buy_info::set_has_item_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void log_gather_buy_info::clear_has_item_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void log_gather_buy_info::clear_item_name() {
  if (item_name_ != &::google::protobuf::internal::kEmptyString) {
    item_name_->clear();
  }
  clear_has_item_name();
}
inline const ::std::string& log_gather_buy_info::item_name() const {
  return *item_name_;
}
inline void log_gather_buy_info::set_item_name(const ::std::string& value) {
  set_has_item_name();
  if (item_name_ == &::google::protobuf::internal::kEmptyString) {
    item_name_ = new ::std::string;
  }
  item_name_->assign(value);
}
inline void log_gather_buy_info::set_item_name(const char* value) {
  set_has_item_name();
  if (item_name_ == &::google::protobuf::internal::kEmptyString) {
    item_name_ = new ::std::string;
  }
  item_name_->assign(value);
}
inline void log_gather_buy_info::set_item_name(const char* value, size_t size) {
  set_has_item_name();
  if (item_name_ == &::google::protobuf::internal::kEmptyString) {
    item_name_ = new ::std::string;
  }
  item_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* log_gather_buy_info::mutable_item_name() {
  set_has_item_name();
  if (item_name_ == &::google::protobuf::internal::kEmptyString) {
    item_name_ = new ::std::string;
  }
  return item_name_;
}
inline ::std::string* log_gather_buy_info::release_item_name() {
  clear_has_item_name();
  if (item_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = item_name_;
    item_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void log_gather_buy_info::set_allocated_item_name(::std::string* item_name) {
  if (item_name_ != &::google::protobuf::internal::kEmptyString) {
    delete item_name_;
  }
  if (item_name) {
    set_has_item_name();
    item_name_ = item_name;
  } else {
    clear_has_item_name();
    item_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 item_count = 13;
inline bool log_gather_buy_info::has_item_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void log_gather_buy_info::set_has_item_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void log_gather_buy_info::clear_has_item_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void log_gather_buy_info::clear_item_count() {
  item_count_ = 0u;
  clear_has_item_count();
}
inline ::google::protobuf::uint32 log_gather_buy_info::item_count() const {
  return item_count_;
}
inline void log_gather_buy_info::set_item_count(::google::protobuf::uint32 value) {
  set_has_item_count();
  item_count_ = value;
}

// optional uint32 cost = 14;
inline bool log_gather_buy_info::has_cost() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void log_gather_buy_info::set_has_cost() {
  _has_bits_[0] |= 0x00002000u;
}
inline void log_gather_buy_info::clear_has_cost() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void log_gather_buy_info::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 log_gather_buy_info::cost() const {
  return cost_;
}
inline void log_gather_buy_info::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
}

// optional uint32 left_coin = 15;
inline bool log_gather_buy_info::has_left_coin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void log_gather_buy_info::set_has_left_coin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void log_gather_buy_info::clear_has_left_coin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void log_gather_buy_info::clear_left_coin() {
  left_coin_ = 0u;
  clear_has_left_coin();
}
inline ::google::protobuf::uint32 log_gather_buy_info::left_coin() const {
  return left_coin_;
}
inline void log_gather_buy_info::set_left_coin(::google::protobuf::uint32 value) {
  set_has_left_coin();
  left_coin_ = value;
}

// -------------------------------------------------------------------

// allocate_chat_room_req

// optional .SProtoSpace.ESSProtoID proto_id = 1 [default = allocate_chat_room_req_id];
inline bool allocate_chat_room_req::has_proto_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void allocate_chat_room_req::set_has_proto_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void allocate_chat_room_req::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void allocate_chat_room_req::clear_proto_id() {
  proto_id_ = 1700;
  clear_has_proto_id();
}
inline ::SProtoSpace::ESSProtoID allocate_chat_room_req::proto_id() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(proto_id_);
}
inline void allocate_chat_room_req::set_proto_id(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_proto_id();
  proto_id_ = value;
}

// repeated int32 room_ids = 2;
inline int allocate_chat_room_req::room_ids_size() const {
  return room_ids_.size();
}
inline void allocate_chat_room_req::clear_room_ids() {
  room_ids_.Clear();
}
inline ::google::protobuf::int32 allocate_chat_room_req::room_ids(int index) const {
  return room_ids_.Get(index);
}
inline void allocate_chat_room_req::set_room_ids(int index, ::google::protobuf::int32 value) {
  room_ids_.Set(index, value);
}
inline void allocate_chat_room_req::add_room_ids(::google::protobuf::int32 value) {
  room_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
allocate_chat_room_req::room_ids() const {
  return room_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
allocate_chat_room_req::mutable_room_ids() {
  return &room_ids_;
}

// -------------------------------------------------------------------

// allocate_chat_room_ack

// optional .SProtoSpace.ESSProtoID proto_id = 1 [default = allocate_chat_room_ack_id];
inline bool allocate_chat_room_ack::has_proto_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void allocate_chat_room_ack::set_has_proto_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void allocate_chat_room_ack::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void allocate_chat_room_ack::clear_proto_id() {
  proto_id_ = 1701;
  clear_has_proto_id();
}
inline ::SProtoSpace::ESSProtoID allocate_chat_room_ack::proto_id() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(proto_id_);
}
inline void allocate_chat_room_ack::set_proto_id(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_proto_id();
  proto_id_ = value;
}

// optional int32 ret = 2;
inline bool allocate_chat_room_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void allocate_chat_room_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void allocate_chat_room_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void allocate_chat_room_ack::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 allocate_chat_room_ack::ret() const {
  return ret_;
}
inline void allocate_chat_room_ack::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// repeated int32 room_ids = 3;
inline int allocate_chat_room_ack::room_ids_size() const {
  return room_ids_.size();
}
inline void allocate_chat_room_ack::clear_room_ids() {
  room_ids_.Clear();
}
inline ::google::protobuf::int32 allocate_chat_room_ack::room_ids(int index) const {
  return room_ids_.Get(index);
}
inline void allocate_chat_room_ack::set_room_ids(int index, ::google::protobuf::int32 value) {
  room_ids_.Set(index, value);
}
inline void allocate_chat_room_ack::add_room_ids(::google::protobuf::int32 value) {
  room_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
allocate_chat_room_ack::room_ids() const {
  return room_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
allocate_chat_room_ack::mutable_room_ids() {
  return &room_ids_;
}

// -------------------------------------------------------------------

// gs_get_role_position_req

// optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gs_get_role_position_req_id];
inline bool gs_get_role_position_req::has_proto_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_get_role_position_req::set_has_proto_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_get_role_position_req::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_get_role_position_req::clear_proto_id() {
  proto_id_ = 1708;
  clear_has_proto_id();
}
inline ::SProtoSpace::ESSProtoID gs_get_role_position_req::proto_id() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(proto_id_);
}
inline void gs_get_role_position_req::set_proto_id(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_proto_id();
  proto_id_ = value;
}

// optional uint64 dest_id = 2;
inline bool gs_get_role_position_req::has_dest_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_get_role_position_req::set_has_dest_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_get_role_position_req::clear_has_dest_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_get_role_position_req::clear_dest_id() {
  dest_id_ = GOOGLE_ULONGLONG(0);
  clear_has_dest_id();
}
inline ::google::protobuf::uint64 gs_get_role_position_req::dest_id() const {
  return dest_id_;
}
inline void gs_get_role_position_req::set_dest_id(::google::protobuf::uint64 value) {
  set_has_dest_id();
  dest_id_ = value;
}

// optional uint64 sour_id = 3;
inline bool gs_get_role_position_req::has_sour_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_get_role_position_req::set_has_sour_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_get_role_position_req::clear_has_sour_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_get_role_position_req::clear_sour_id() {
  sour_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sour_id();
}
inline ::google::protobuf::uint64 gs_get_role_position_req::sour_id() const {
  return sour_id_;
}
inline void gs_get_role_position_req::set_sour_id(::google::protobuf::uint64 value) {
  set_has_sour_id();
  sour_id_ = value;
}

// -------------------------------------------------------------------

// gs_get_role_position_ack

// optional .SProtoSpace.ESSProtoID proto_id = 1 [default = gs_get_role_position_ack_id];
inline bool gs_get_role_position_ack::has_proto_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_get_role_position_ack::set_has_proto_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_get_role_position_ack::clear_has_proto_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_get_role_position_ack::clear_proto_id() {
  proto_id_ = 1709;
  clear_has_proto_id();
}
inline ::SProtoSpace::ESSProtoID gs_get_role_position_ack::proto_id() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(proto_id_);
}
inline void gs_get_role_position_ack::set_proto_id(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_proto_id();
  proto_id_ = value;
}

// optional uint32 ret = 2;
inline bool gs_get_role_position_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_get_role_position_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_get_role_position_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_get_role_position_ack::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 gs_get_role_position_ack::ret() const {
  return ret_;
}
inline void gs_get_role_position_ack::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 room_id = 3;
inline bool gs_get_role_position_ack::has_room_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_get_role_position_ack::set_has_room_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_get_role_position_ack::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_get_role_position_ack::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 gs_get_role_position_ack::room_id() const {
  return room_id_;
}
inline void gs_get_role_position_ack::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// optional .SProtoSpace.role_position dest_pos = 4;
inline bool gs_get_role_position_ack::has_dest_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_get_role_position_ack::set_has_dest_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_get_role_position_ack::clear_has_dest_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_get_role_position_ack::clear_dest_pos() {
  if (dest_pos_ != NULL) dest_pos_->::SProtoSpace::role_position::Clear();
  clear_has_dest_pos();
}
inline const ::SProtoSpace::role_position& gs_get_role_position_ack::dest_pos() const {
  return dest_pos_ != NULL ? *dest_pos_ : *default_instance_->dest_pos_;
}
inline ::SProtoSpace::role_position* gs_get_role_position_ack::mutable_dest_pos() {
  set_has_dest_pos();
  if (dest_pos_ == NULL) dest_pos_ = new ::SProtoSpace::role_position;
  return dest_pos_;
}
inline ::SProtoSpace::role_position* gs_get_role_position_ack::release_dest_pos() {
  clear_has_dest_pos();
  ::SProtoSpace::role_position* temp = dest_pos_;
  dest_pos_ = NULL;
  return temp;
}
inline void gs_get_role_position_ack::set_allocated_dest_pos(::SProtoSpace::role_position* dest_pos) {
  delete dest_pos_;
  dest_pos_ = dest_pos;
  if (dest_pos) {
    set_has_dest_pos();
  } else {
    clear_has_dest_pos();
  }
}

// optional uint64 sour_id = 5;
inline bool gs_get_role_position_ack::has_sour_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_get_role_position_ack::set_has_sour_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_get_role_position_ack::clear_has_sour_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_get_role_position_ack::clear_sour_id() {
  sour_id_ = GOOGLE_ULONGLONG(0);
  clear_has_sour_id();
}
inline ::google::protobuf::uint64 gs_get_role_position_ack::sour_id() const {
  return sour_id_;
}
inline void gs_get_role_position_ack::set_sour_id(::google::protobuf::uint64 value) {
  set_has_sour_id();
  sour_id_ = value;
}

// -------------------------------------------------------------------

// red_pt_ss_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = red_pt_ss_ntf_id];
inline bool red_pt_ss_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void red_pt_ss_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void red_pt_ss_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void red_pt_ss_ntf::clear_protoid() {
  protoid_ = 1801;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID red_pt_ss_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void red_pt_ss_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 role_id = 2;
inline bool red_pt_ss_ntf::has_role_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void red_pt_ss_ntf::set_has_role_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void red_pt_ss_ntf::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void red_pt_ss_ntf::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 red_pt_ss_ntf::role_id() const {
  return role_id_;
}
inline void red_pt_ss_ntf::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional .SProtoSpace.red_pt_infos infos = 3;
inline bool red_pt_ss_ntf::has_infos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void red_pt_ss_ntf::set_has_infos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void red_pt_ss_ntf::clear_has_infos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void red_pt_ss_ntf::clear_infos() {
  if (infos_ != NULL) infos_->::SProtoSpace::red_pt_infos::Clear();
  clear_has_infos();
}
inline const ::SProtoSpace::red_pt_infos& red_pt_ss_ntf::infos() const {
  return infos_ != NULL ? *infos_ : *default_instance_->infos_;
}
inline ::SProtoSpace::red_pt_infos* red_pt_ss_ntf::mutable_infos() {
  set_has_infos();
  if (infos_ == NULL) infos_ = new ::SProtoSpace::red_pt_infos;
  return infos_;
}
inline ::SProtoSpace::red_pt_infos* red_pt_ss_ntf::release_infos() {
  clear_has_infos();
  ::SProtoSpace::red_pt_infos* temp = infos_;
  infos_ = NULL;
  return temp;
}
inline void red_pt_ss_ntf::set_allocated_infos(::SProtoSpace::red_pt_infos* infos) {
  delete infos_;
  infos_ = infos;
  if (infos) {
    set_has_infos();
  } else {
    clear_has_infos();
  }
}

// -------------------------------------------------------------------

// get_other_role_fashion_ss_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = get_other_role_fashion_ss_req_id];
inline bool get_other_role_fashion_ss_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_other_role_fashion_ss_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_other_role_fashion_ss_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_other_role_fashion_ss_req::clear_protoid() {
  protoid_ = 1810;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID get_other_role_fashion_ss_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void get_other_role_fashion_ss_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated uint64 role_id_s = 2;
inline int get_other_role_fashion_ss_req::role_id_s_size() const {
  return role_id_s_.size();
}
inline void get_other_role_fashion_ss_req::clear_role_id_s() {
  role_id_s_.Clear();
}
inline ::google::protobuf::uint64 get_other_role_fashion_ss_req::role_id_s(int index) const {
  return role_id_s_.Get(index);
}
inline void get_other_role_fashion_ss_req::set_role_id_s(int index, ::google::protobuf::uint64 value) {
  role_id_s_.Set(index, value);
}
inline void get_other_role_fashion_ss_req::add_role_id_s(::google::protobuf::uint64 value) {
  role_id_s_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
get_other_role_fashion_ss_req::role_id_s() const {
  return role_id_s_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
get_other_role_fashion_ss_req::mutable_role_id_s() {
  return &role_id_s_;
}

// repeated string role_name_s = 3;
inline int get_other_role_fashion_ss_req::role_name_s_size() const {
  return role_name_s_.size();
}
inline void get_other_role_fashion_ss_req::clear_role_name_s() {
  role_name_s_.Clear();
}
inline const ::std::string& get_other_role_fashion_ss_req::role_name_s(int index) const {
  return role_name_s_.Get(index);
}
inline ::std::string* get_other_role_fashion_ss_req::mutable_role_name_s(int index) {
  return role_name_s_.Mutable(index);
}
inline void get_other_role_fashion_ss_req::set_role_name_s(int index, const ::std::string& value) {
  role_name_s_.Mutable(index)->assign(value);
}
inline void get_other_role_fashion_ss_req::set_role_name_s(int index, const char* value) {
  role_name_s_.Mutable(index)->assign(value);
}
inline void get_other_role_fashion_ss_req::set_role_name_s(int index, const char* value, size_t size) {
  role_name_s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_other_role_fashion_ss_req::add_role_name_s() {
  return role_name_s_.Add();
}
inline void get_other_role_fashion_ss_req::add_role_name_s(const ::std::string& value) {
  role_name_s_.Add()->assign(value);
}
inline void get_other_role_fashion_ss_req::add_role_name_s(const char* value) {
  role_name_s_.Add()->assign(value);
}
inline void get_other_role_fashion_ss_req::add_role_name_s(const char* value, size_t size) {
  role_name_s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
get_other_role_fashion_ss_req::role_name_s() const {
  return role_name_s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
get_other_role_fashion_ss_req::mutable_role_name_s() {
  return &role_name_s_;
}

// -------------------------------------------------------------------

// get_other_role_fashion_ss_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = get_other_role_fashion_ss_ack_id];
inline bool get_other_role_fashion_ss_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_other_role_fashion_ss_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_other_role_fashion_ss_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_other_role_fashion_ss_ack::clear_protoid() {
  protoid_ = 1811;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID get_other_role_fashion_ss_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void get_other_role_fashion_ss_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.fashions_pack fashions_p_wearing = 2;
inline bool get_other_role_fashion_ss_ack::has_fashions_p_wearing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_other_role_fashion_ss_ack::set_has_fashions_p_wearing() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_other_role_fashion_ss_ack::clear_has_fashions_p_wearing() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_other_role_fashion_ss_ack::clear_fashions_p_wearing() {
  if (fashions_p_wearing_ != NULL) fashions_p_wearing_->::SProtoSpace::fashions_pack::Clear();
  clear_has_fashions_p_wearing();
}
inline const ::SProtoSpace::fashions_pack& get_other_role_fashion_ss_ack::fashions_p_wearing() const {
  return fashions_p_wearing_ != NULL ? *fashions_p_wearing_ : *default_instance_->fashions_p_wearing_;
}
inline ::SProtoSpace::fashions_pack* get_other_role_fashion_ss_ack::mutable_fashions_p_wearing() {
  set_has_fashions_p_wearing();
  if (fashions_p_wearing_ == NULL) fashions_p_wearing_ = new ::SProtoSpace::fashions_pack;
  return fashions_p_wearing_;
}
inline ::SProtoSpace::fashions_pack* get_other_role_fashion_ss_ack::release_fashions_p_wearing() {
  clear_has_fashions_p_wearing();
  ::SProtoSpace::fashions_pack* temp = fashions_p_wearing_;
  fashions_p_wearing_ = NULL;
  return temp;
}
inline void get_other_role_fashion_ss_ack::set_allocated_fashions_p_wearing(::SProtoSpace::fashions_pack* fashions_p_wearing) {
  delete fashions_p_wearing_;
  fashions_p_wearing_ = fashions_p_wearing;
  if (fashions_p_wearing) {
    set_has_fashions_p_wearing();
  } else {
    clear_has_fashions_p_wearing();
  }
}

// optional .SProtoSpace.MsgErrorType error_code = 3;
inline bool get_other_role_fashion_ss_ack::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void get_other_role_fashion_ss_ack::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void get_other_role_fashion_ss_ack::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void get_other_role_fashion_ss_ack::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::SProtoSpace::MsgErrorType get_other_role_fashion_ss_ack::error_code() const {
  return static_cast< ::SProtoSpace::MsgErrorType >(error_code_);
}
inline void get_other_role_fashion_ss_ack::set_error_code(::SProtoSpace::MsgErrorType value) {
  assert(::SProtoSpace::MsgErrorType_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// -------------------------------------------------------------------

// gs_chat_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_chat_req_id];
inline bool gs_chat_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_chat_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_chat_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_chat_req::clear_protoid() {
  protoid_ = 1710;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_chat_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_chat_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.CHAT_TYPE type = 2;
inline bool gs_chat_req::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_chat_req::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_chat_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_chat_req::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::CHAT_TYPE gs_chat_req::type() const {
  return static_cast< ::SProtoSpace::CHAT_TYPE >(type_);
}
inline void gs_chat_req::set_type(::SProtoSpace::CHAT_TYPE value) {
  assert(::SProtoSpace::CHAT_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 module_id = 3;
inline bool gs_chat_req::has_module_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_chat_req::set_has_module_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_chat_req::clear_has_module_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_chat_req::clear_module_id() {
  module_id_ = GOOGLE_ULONGLONG(0);
  clear_has_module_id();
}
inline ::google::protobuf::uint64 gs_chat_req::module_id() const {
  return module_id_;
}
inline void gs_chat_req::set_module_id(::google::protobuf::uint64 value) {
  set_has_module_id();
  module_id_ = value;
}

// optional string content = 4;
inline bool gs_chat_req::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_chat_req::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_chat_req::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_chat_req::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& gs_chat_req::content() const {
  return *content_;
}
inline void gs_chat_req::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gs_chat_req::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gs_chat_req::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gs_chat_req::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* gs_chat_req::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gs_chat_req::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 role_id = 5;
inline bool gs_chat_req::has_role_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gs_chat_req::set_has_role_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gs_chat_req::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gs_chat_req::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 gs_chat_req::role_id() const {
  return role_id_;
}
inline void gs_chat_req::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// -------------------------------------------------------------------

// gs_chat_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gs_chat_ack_id];
inline bool gs_chat_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gs_chat_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gs_chat_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gs_chat_ack::clear_protoid() {
  protoid_ = 1711;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gs_chat_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gs_chat_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.CHAT_TYPE type = 2;
inline bool gs_chat_ack::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gs_chat_ack::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gs_chat_ack::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gs_chat_ack::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::CHAT_TYPE gs_chat_ack::type() const {
  return static_cast< ::SProtoSpace::CHAT_TYPE >(type_);
}
inline void gs_chat_ack::set_type(::SProtoSpace::CHAT_TYPE value) {
  assert(::SProtoSpace::CHAT_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string content = 3;
inline bool gs_chat_ack::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gs_chat_ack::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gs_chat_ack::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gs_chat_ack::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& gs_chat_ack::content() const {
  return *content_;
}
inline void gs_chat_ack::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gs_chat_ack::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gs_chat_ack::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gs_chat_ack::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* gs_chat_ack::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gs_chat_ack::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.public_role_base_info sour_data = 4;
inline bool gs_chat_ack::has_sour_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gs_chat_ack::set_has_sour_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gs_chat_ack::clear_has_sour_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gs_chat_ack::clear_sour_data() {
  if (sour_data_ != NULL) sour_data_->::SProtoSpace::public_role_base_info::Clear();
  clear_has_sour_data();
}
inline const ::SProtoSpace::public_role_base_info& gs_chat_ack::sour_data() const {
  return sour_data_ != NULL ? *sour_data_ : *default_instance_->sour_data_;
}
inline ::SProtoSpace::public_role_base_info* gs_chat_ack::mutable_sour_data() {
  set_has_sour_data();
  if (sour_data_ == NULL) sour_data_ = new ::SProtoSpace::public_role_base_info;
  return sour_data_;
}
inline ::SProtoSpace::public_role_base_info* gs_chat_ack::release_sour_data() {
  clear_has_sour_data();
  ::SProtoSpace::public_role_base_info* temp = sour_data_;
  sour_data_ = NULL;
  return temp;
}
inline void gs_chat_ack::set_allocated_sour_data(::SProtoSpace::public_role_base_info* sour_data) {
  delete sour_data_;
  sour_data_ = sour_data;
  if (sour_data) {
    set_has_sour_data();
  } else {
    clear_has_sour_data();
  }
}

// -------------------------------------------------------------------

// user_event_track_ss_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = user_event_track_ss_ntf_id];
inline bool user_event_track_ss_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_event_track_ss_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_event_track_ss_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_event_track_ss_ntf::clear_protoid() {
  protoid_ = 1830;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID user_event_track_ss_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void user_event_track_ss_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated string log_s = 2;
inline int user_event_track_ss_ntf::log_s_size() const {
  return log_s_.size();
}
inline void user_event_track_ss_ntf::clear_log_s() {
  log_s_.Clear();
}
inline const ::std::string& user_event_track_ss_ntf::log_s(int index) const {
  return log_s_.Get(index);
}
inline ::std::string* user_event_track_ss_ntf::mutable_log_s(int index) {
  return log_s_.Mutable(index);
}
inline void user_event_track_ss_ntf::set_log_s(int index, const ::std::string& value) {
  log_s_.Mutable(index)->assign(value);
}
inline void user_event_track_ss_ntf::set_log_s(int index, const char* value) {
  log_s_.Mutable(index)->assign(value);
}
inline void user_event_track_ss_ntf::set_log_s(int index, const char* value, size_t size) {
  log_s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_event_track_ss_ntf::add_log_s() {
  return log_s_.Add();
}
inline void user_event_track_ss_ntf::add_log_s(const ::std::string& value) {
  log_s_.Add()->assign(value);
}
inline void user_event_track_ss_ntf::add_log_s(const char* value) {
  log_s_.Add()->assign(value);
}
inline void user_event_track_ss_ntf::add_log_s(const char* value, size_t size) {
  log_s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
user_event_track_ss_ntf::log_s() const {
  return log_s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
user_event_track_ss_ntf::mutable_log_s() {
  return &log_s_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SProtoSpace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ELogEventType>() {
  return ::SProtoSpace::ELogEventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EConomicAnalysisType>() {
  return ::SProtoSpace::EConomicAnalysisType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EAddItemReasonLv1>() {
  return ::SProtoSpace::EAddItemReasonLv1_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ss_5fgame_2eproto__INCLUDED
