// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cm_battletype.proto

#ifndef PROTOBUF_cm_5fbattletype_2eproto__INCLUDED
#define PROTOBUF_cm_5fbattletype_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cm_roletype.pb.h"
// @@protoc_insertion_point(includes)

namespace SProtoSpace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cm_5fbattletype_2eproto();
void protobuf_AssignDesc_cm_5fbattletype_2eproto();
void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

class reward_item;
class battle_reward;
class round_op_skill;
class round_op_param;
class damage_data;
class obj_state;
class round_skill_data_damage;
class round_skill_data_cure;
class round_buff_data;
class round_state_data;
class round_data;
class seq_useskill;
class seq_buff;
class seq_state;
class seq_damage;
class seq_relive;
class seq_attr;
class seq_extra_action;
class seq_sp;
class opt_seq;
class hit_seq;
class opt_seqs;
class battle_hero_info;
class battle_player_base_info;
class battle_player_info;
class battle_role_info;
class battle_camp_info;
class pvp_battle_init_data;
class battle_end_data;
class pve_check_battle_init_data;
class create_battle_data;
class running_entity;
class running_queue;
class client_hero_info;
class client_battle_player_info;
class client_pvp_battle_camp_data;
class client_pvp_battle_data;
class client_battle_data;
class battle_check_opt_data;
class office_end_info;
class battle_replay_round_info;
class battle_replay_turn_info;
class battle_replay_info;
class lsg_position_info;
class comment_info;
class comment_all;
class date_info;
class show_player_base;

enum ECrossServerType {
  BACK_NORMAL_SERVER = 0,
  CROSS_LOCAL_SERVER = 1,
  CROSS_GLOBAL_SERVER = 2
};
bool ECrossServerType_IsValid(int value);
const ECrossServerType ECrossServerType_MIN = BACK_NORMAL_SERVER;
const ECrossServerType ECrossServerType_MAX = CROSS_GLOBAL_SERVER;
const int ECrossServerType_ARRAYSIZE = ECrossServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECrossServerType_descriptor();
inline const ::std::string& ECrossServerType_Name(ECrossServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECrossServerType_descriptor(), value);
}
inline bool ECrossServerType_Parse(
    const ::std::string& name, ECrossServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECrossServerType>(
    ECrossServerType_descriptor(), name, value);
}
enum EBattleType {
  BATTLE_TYPE_PVP = 1,
  BATTLE_TYPE_PVE_DISCOVER = 2,
  BATTLE_TYPE_PVE_CHALLENGE = 3,
  BATTLE_TYPE_PVE_CHECK = 4,
  BATTLE_TYPE_OPERA = 5,
  BATTLE_TYPE_JJC = 6,
  BATTLE_TYPE_OFFICE = 7,
  BATTLE_TYPE_OFFICE_NPC = 8,
  BATTLE_TYPE_OFFICE_CHALLENGE = 9,
  BATTLE_TYPE_PVE = 10,
  BATTLE_TYPE_TOWER = 11,
  BATTLE_TYPE_ADV = 12,
  BATTLE_TYPE_ROYAL = 13,
  BATTLE_TYPE_CUSTOM = 14
};
bool EBattleType_IsValid(int value);
const EBattleType EBattleType_MIN = BATTLE_TYPE_PVP;
const EBattleType EBattleType_MAX = BATTLE_TYPE_CUSTOM;
const int EBattleType_ARRAYSIZE = EBattleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBattleType_descriptor();
inline const ::std::string& EBattleType_Name(EBattleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBattleType_descriptor(), value);
}
inline bool EBattleType_Parse(
    const ::std::string& name, EBattleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBattleType>(
    EBattleType_descriptor(), name, value);
}
enum EHeroFormationType {
  HERO_FORMATION_TMP = 1,
  HERO_FORMATION_COMMON = 2,
  HERO_FORMATION_OPERA = 3,
  HERO_FORMATION_OFFICAL_NPC = 4,
  HERO_FORMATION_BASE_POOL = 9
};
bool EHeroFormationType_IsValid(int value);
const EHeroFormationType EHeroFormationType_MIN = HERO_FORMATION_TMP;
const EHeroFormationType EHeroFormationType_MAX = HERO_FORMATION_BASE_POOL;
const int EHeroFormationType_ARRAYSIZE = EHeroFormationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHeroFormationType_descriptor();
inline const ::std::string& EHeroFormationType_Name(EHeroFormationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHeroFormationType_descriptor(), value);
}
inline bool EHeroFormationType_Parse(
    const ::std::string& name, EHeroFormationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHeroFormationType>(
    EHeroFormationType_descriptor(), name, value);
}
enum EObjType {
  OBJ_TYPE_NONE = 0,
  OBJ_TYPE_PLAYER = 1,
  OBJ_TYPE_HERO = 2,
  OBJ_TYPE_MONSTER = 3,
  OBJ_TYPE_SUMMON = 4
};
bool EObjType_IsValid(int value);
const EObjType EObjType_MIN = OBJ_TYPE_NONE;
const EObjType EObjType_MAX = OBJ_TYPE_SUMMON;
const int EObjType_ARRAYSIZE = EObjType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EObjType_descriptor();
inline const ::std::string& EObjType_Name(EObjType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EObjType_descriptor(), value);
}
inline bool EObjType_Parse(
    const ::std::string& name, EObjType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EObjType>(
    EObjType_descriptor(), name, value);
}
enum ECampType {
  CAMP_TYPE_0 = 0,
  CAMP_TYPE_1 = 1
};
bool ECampType_IsValid(int value);
const ECampType ECampType_MIN = CAMP_TYPE_0;
const ECampType ECampType_MAX = CAMP_TYPE_1;
const int ECampType_ARRAYSIZE = ECampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECampType_descriptor();
inline const ::std::string& ECampType_Name(ECampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECampType_descriptor(), value);
}
inline bool ECampType_Parse(
    const ::std::string& name, ECampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECampType>(
    ECampType_descriptor(), name, value);
}
enum EPlayerType {
  PLAYER_TYPE_NONE = 0,
  PLAYER_TYPE_PLAYER = 1,
  PLAYER_TYPE_NPC = 2
};
bool EPlayerType_IsValid(int value);
const EPlayerType EPlayerType_MIN = PLAYER_TYPE_NONE;
const EPlayerType EPlayerType_MAX = PLAYER_TYPE_NPC;
const int EPlayerType_ARRAYSIZE = EPlayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPlayerType_descriptor();
inline const ::std::string& EPlayerType_Name(EPlayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPlayerType_descriptor(), value);
}
inline bool EPlayerType_Parse(
    const ::std::string& name, EPlayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPlayerType>(
    EPlayerType_descriptor(), name, value);
}
enum ERoundOP {
  ROUND_OP_TYPE_SKILL = 1
};
bool ERoundOP_IsValid(int value);
const ERoundOP ERoundOP_MIN = ROUND_OP_TYPE_SKILL;
const ERoundOP ERoundOP_MAX = ROUND_OP_TYPE_SKILL;
const int ERoundOP_ARRAYSIZE = ERoundOP_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERoundOP_descriptor();
inline const ::std::string& ERoundOP_Name(ERoundOP value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERoundOP_descriptor(), value);
}
inline bool ERoundOP_Parse(
    const ::std::string& name, ERoundOP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERoundOP>(
    ERoundOP_descriptor(), name, value);
}
enum ERoundDataType {
  ROUND_DATA_TYPE_NONE = 0,
  ROUND_DATA_TYPE_SKILL_DAMAGE = 1,
  ROUND_DATA_TYPE_SKILL_CURE = 2,
  ROUND_DATA_TYPE_BUFF = 3,
  ROUND_DATA_TYPE_STATE = 4
};
bool ERoundDataType_IsValid(int value);
const ERoundDataType ERoundDataType_MIN = ROUND_DATA_TYPE_NONE;
const ERoundDataType ERoundDataType_MAX = ROUND_DATA_TYPE_STATE;
const int ERoundDataType_ARRAYSIZE = ERoundDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERoundDataType_descriptor();
inline const ::std::string& ERoundDataType_Name(ERoundDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERoundDataType_descriptor(), value);
}
inline bool ERoundDataType_Parse(
    const ::std::string& name, ERoundDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERoundDataType>(
    ERoundDataType_descriptor(), name, value);
}
enum EBuffDataType {
  BUFF_DATA_TYPE_NONE = 0,
  BUFF_DATA_TYPE_ADD = 1,
  BUFF_DATA_TYPE_REMOVE = 2,
  BUFF_DATA_TYPE_REFRESH = 3
};
bool EBuffDataType_IsValid(int value);
const EBuffDataType EBuffDataType_MIN = BUFF_DATA_TYPE_NONE;
const EBuffDataType EBuffDataType_MAX = BUFF_DATA_TYPE_REFRESH;
const int EBuffDataType_ARRAYSIZE = EBuffDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffDataType_descriptor();
inline const ::std::string& EBuffDataType_Name(EBuffDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffDataType_descriptor(), value);
}
inline bool EBuffDataType_Parse(
    const ::std::string& name, EBuffDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffDataType>(
    EBuffDataType_descriptor(), name, value);
}
enum EStateDataType {
  STATE_DATA_TYPE_NONE = 0,
  STATE_DATA_TYPE_ADD = 1,
  STATE_DATA_TYPE_REMOVE = 2
};
bool EStateDataType_IsValid(int value);
const EStateDataType EStateDataType_MIN = STATE_DATA_TYPE_NONE;
const EStateDataType EStateDataType_MAX = STATE_DATA_TYPE_REMOVE;
const int EStateDataType_ARRAYSIZE = EStateDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStateDataType_descriptor();
inline const ::std::string& EStateDataType_Name(EStateDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStateDataType_descriptor(), value);
}
inline bool EStateDataType_Parse(
    const ::std::string& name, EStateDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStateDataType>(
    EStateDataType_descriptor(), name, value);
}
enum EBattleTargetType {
  BATTLE_TARGET_TYPE_CLICK = 0,
  BATTLE_TARGET_TYPE_ALL = 1,
  BATTLE_TARGET_TYPE_SELF = 4,
  BATTLE_TARGET_TYPE_FRIEND_OTHER = 5,
  BATTLE_TARGET_TYPE_ENEMY_OTHER = 6,
  BATTLE_TARGET_TYPE_OTHER_ALL = 7,
  BATTLE_TARGET_TYPE_FRIEND_DEAD = 8,
  BATTLE_TARGET_TYPE_FRIEND_SUMMON = 9,
  BATTLE_TARGET_TYPE_ENEMY_FRONT_SINGLE = 10,
  BATTLE_TARGET_TYPE_ENEMY_BACK_SINGLE = 11,
  BATTLE_TARGET_TYPE_ENEMY_FRONT_AROUNT = 12,
  BATTLE_TARGET_TYPE_ENEMY_BACK_AROUNT = 13,
  BATTLE_TARGET_TYPE_ENEMY_FRONT = 14,
  BATTLE_TARGET_TYPE_ENEMY_BACK = 15,
  BATTLE_TARGET_TYPE_ENEMY_COLUMN = 16,
  BATTLE_TARGET_TYPE_ENEMY_ALL = 17,
  BATTLE_TARGET_TYPE_ENEMY_COLUMN_RANDOM = 18,
  BATTLE_TARGET_TYPE_ENEMY_ALL_RANDOM = 19,
  BATTLE_TARGET_TYPE_ENEMY_MIN_HP = 20,
  BATTLE_TARGET_TYPE_ENEMY_MAX_HP = 21,
  BATTLE_TARGET_TYPE_ENEMY_MAX_SP = 22,
  BATTLE_TARGET_TYPE_ENEMY_MAX_ATK = 23,
  BATTLE_TARGET_TYPE_ENEMY_MALE = 24,
  BATTLE_TARGET_TYPE_ENEMY_FEMALE = 25,
  BATTLE_TARGET_TYPE_ENEMY_ATTACK = 26,
  BATTLE_TARGET_TYPE_SELF_SINGLE = 100,
  BATTLE_TARGET_TYPE_FRIEND_FRONT = 101,
  BATTLE_TARGET_TYPE_FRIEND_BACK = 102,
  BATTLE_TARGET_TYPE_FRIEND_ALL = 103,
  BATTLE_TARGET_TYPE_FRIEND_ALL_RANDOM = 104,
  BATTLE_TARGET_TYPE_FRIEND_MIN_HP = 105,
  BATTLE_TARGET_TYPE_FRIEND_MALE = 106,
  BATTLE_TARGET_TYPE_FRIEND_FEMALE = 107,
  BATTLE_TARGET_TYPE_FRIEND_SELF_COMBOL = 108
};
bool EBattleTargetType_IsValid(int value);
const EBattleTargetType EBattleTargetType_MIN = BATTLE_TARGET_TYPE_CLICK;
const EBattleTargetType EBattleTargetType_MAX = BATTLE_TARGET_TYPE_FRIEND_SELF_COMBOL;
const int EBattleTargetType_ARRAYSIZE = EBattleTargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBattleTargetType_descriptor();
inline const ::std::string& EBattleTargetType_Name(EBattleTargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBattleTargetType_descriptor(), value);
}
inline bool EBattleTargetType_Parse(
    const ::std::string& name, EBattleTargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBattleTargetType>(
    EBattleTargetType_descriptor(), name, value);
}
enum EDamageType {
  DAMAGE_TYPE_NONE = 0,
  DAMAGE_TYPE_DAMAGE = 1,
  DAMAGE_TYPE_CURE = 2,
  DAMAGE_TYPE_ADD_BUFF = 3,
  DAMAGE_TYPE_CLEAR_BUFF = 4
};
bool EDamageType_IsValid(int value);
const EDamageType EDamageType_MIN = DAMAGE_TYPE_NONE;
const EDamageType EDamageType_MAX = DAMAGE_TYPE_CLEAR_BUFF;
const int EDamageType_ARRAYSIZE = EDamageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDamageType_descriptor();
inline const ::std::string& EDamageType_Name(EDamageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDamageType_descriptor(), value);
}
inline bool EDamageType_Parse(
    const ::std::string& name, EDamageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDamageType>(
    EDamageType_descriptor(), name, value);
}
enum EBuffType {
  BUFF_TYPE_DAMAGE = 1,
  BUFF_TYPE_CHANGE_ATTR = 2,
  BUFF_TYPE_STATE = 3,
  BUFF_TYPE_AURA = 4,
  BUFF_TYPE_SHIELD = 5,
  BUFF_TYPE_ACTION_BAR = 6,
  BUFF_TYPE_EXTRA_ACTION = 7,
  BUFF_TYPE_USE_SKILL = 8,
  BUFF_TYPE_DISPEL_BUFF = 9,
  BUFF_TYPE_ADD_BUFF = 10,
  BUFF_TYPE_HP_CHANGE = 11,
  BUFF_TYPE_CONVERT_PRO = 12,
  BUFF_TYPE_DAMAGE_TO_HEAL = 13,
  BUFF_TYPE_SELF_DAMAGE_SCALE = 14,
  BUFF_TYPE_MULTI_HP_CHANGE = 15,
  BUFF_TYPE_STATE_TO_ATTR = 16,
  BUFF_TYPE_STATE_TO_BUFF = 17,
  BUFF_TYPE_SUMMON = 18,
  BUFF_TYPE_RELIVE = 19,
  BUFF_TYPE_MARK = 20,
  BUFF_TYPE_MARK_ADD = 21,
  BUFF_TYPE_MARK_TO_BUFF = 22,
  BUFF_TYPE_POWER = 23,
  BUFF_TYPE_LOSE_HP_TO_SCALE = 24,
  BUFF_TYPE_SEAL_PASSIVE = 100,
  BUFF_TYPE_SEAL_SOUL = 101
};
bool EBuffType_IsValid(int value);
const EBuffType EBuffType_MIN = BUFF_TYPE_DAMAGE;
const EBuffType EBuffType_MAX = BUFF_TYPE_SEAL_SOUL;
const int EBuffType_ARRAYSIZE = EBuffType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffType_descriptor();
inline const ::std::string& EBuffType_Name(EBuffType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffType_descriptor(), value);
}
inline bool EBuffType_Parse(
    const ::std::string& name, EBuffType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffType>(
    EBuffType_descriptor(), name, value);
}
enum EBuffTriggerType {
  BUFF_TRIGGER_TYPE_NONE = 0,
  BUFF_TRIGGER_TYPE_ATTACK_BEFORE = 1,
  BUFF_TRIGGER_TYPE_ATTACK = 2,
  BUFF_TRIGGER_TYPE_ATTACK_CRIT = 3,
  BUFF_TRIGGER_TYPE_ATTACK_AFTER = 4,
  BUFF_TRIGGER_TYPE_BE_ATTACK = 5,
  BUFF_TRIGGER_TYPE_BE_ATTACK_CRIT = 6,
  BUFF_TRIGGER_TYPE_CURE_BEFORE = 7,
  BUFF_TRIGGER_TYPE_CURE = 8,
  BUFF_TRIGGER_TYPE_CURE_CRIT = 9,
  BUFF_TRIGGER_TYPE_CURE_AFTER = 10,
  BUFF_TRIGGER_TYPE_BE_CURE = 11,
  BUFF_TRIGGER_TYPE_BE_CURE_CRIT = 12,
  BUFF_TRIGGER_TYPE_ROUND_END = 13,
  BUFF_TRIGGER_TYPE_ROUND_START = 14,
  BUFF_TRIGGER_TYPE_ACTIVE_END = 15,
  BUFF_TRIGGER_TYPE_ACTIVE_START = 16,
  BUFF_TRIGGER_TYPE_SKILL_END = 17,
  BUFF_TRIGGER_TYPE_SKILL_START = 18,
  BUFF_TRIGGER_TYPE_KILL = 19,
  BUFF_TRIGGER_TYPE_DEAD = 20,
  BUFF_TRIGGER_TYPE_RELIVE = 21,
  BUFF_TRIGGER_TYPE_HP_CHANGE = 22,
  BUFF_TRIGGER_TYPE_BUFF_BREAKUP = 23,
  BUFF_TRIGGER_TYPE_DEBUFF_BREAKUP = 24
};
bool EBuffTriggerType_IsValid(int value);
const EBuffTriggerType EBuffTriggerType_MIN = BUFF_TRIGGER_TYPE_NONE;
const EBuffTriggerType EBuffTriggerType_MAX = BUFF_TRIGGER_TYPE_DEBUFF_BREAKUP;
const int EBuffTriggerType_ARRAYSIZE = EBuffTriggerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffTriggerType_descriptor();
inline const ::std::string& EBuffTriggerType_Name(EBuffTriggerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffTriggerType_descriptor(), value);
}
inline bool EBuffTriggerType_Parse(
    const ::std::string& name, EBuffTriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffTriggerType>(
    EBuffTriggerType_descriptor(), name, value);
}
enum EBuffReasonType {
  BUFF_REASON_TYPE_START = 0,
  BUFF_REASON_TYPE_TRIGGER = 1,
  BUFF_REASON_TYPE_END = 2
};
bool EBuffReasonType_IsValid(int value);
const EBuffReasonType EBuffReasonType_MIN = BUFF_REASON_TYPE_START;
const EBuffReasonType EBuffReasonType_MAX = BUFF_REASON_TYPE_END;
const int EBuffReasonType_ARRAYSIZE = EBuffReasonType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffReasonType_descriptor();
inline const ::std::string& EBuffReasonType_Name(EBuffReasonType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffReasonType_descriptor(), value);
}
inline bool EBuffReasonType_Parse(
    const ::std::string& name, EBuffReasonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffReasonType>(
    EBuffReasonType_descriptor(), name, value);
}
enum EBuffEndType {
  BUFF_END_TYPE_NORMAL = 0,
  BUFF_END_TYPE_AURA = 1,
  BUFF_END_TYPE_DISPEL = 2,
  BUFF_END_TYPE_FORCE = 3
};
bool EBuffEndType_IsValid(int value);
const EBuffEndType EBuffEndType_MIN = BUFF_END_TYPE_NORMAL;
const EBuffEndType EBuffEndType_MAX = BUFF_END_TYPE_FORCE;
const int EBuffEndType_ARRAYSIZE = EBuffEndType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffEndType_descriptor();
inline const ::std::string& EBuffEndType_Name(EBuffEndType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffEndType_descriptor(), value);
}
inline bool EBuffEndType_Parse(
    const ::std::string& name, EBuffEndType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffEndType>(
    EBuffEndType_descriptor(), name, value);
}
enum EStateType {
  STATE_TYPE_NONE = 0,
  STATE_TYPE_FREEZE = 1,
  STATE_TYPE_STUN = 2,
  STATE_TYPE_SLEEP = 3,
  STATE_TYPE_HEX = 4,
  STATE_TYPE_CHARM = 5,
  STATE_TYPE_CONFUSION = 6,
  STATE_TYPE_SILENCE = 7,
  STATE_TYPE_TAUNT = 8,
  STATE_TYPE_NO_CRIT = 9,
  STATE_TYPE_NO_CURE = 10,
  STATE_TYPE_IMMUNE_STUN = 11,
  STATE_TYPE_IMMUNE_SILENCE = 12,
  STATE_TYPE_IMMUNE_REDUCE_SP = 13
};
bool EStateType_IsValid(int value);
const EStateType EStateType_MIN = STATE_TYPE_NONE;
const EStateType EStateType_MAX = STATE_TYPE_IMMUNE_REDUCE_SP;
const int EStateType_ARRAYSIZE = EStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStateType_descriptor();
inline const ::std::string& EStateType_Name(EStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStateType_descriptor(), value);
}
inline bool EStateType_Parse(
    const ::std::string& name, EStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStateType>(
    EStateType_descriptor(), name, value);
}
enum EGetValueType {
  GET_VALUE_TYPE_NONE = 0,
  GET_VALUE_TYPE_ATTACK_ATK = 1,
  GET_VALUE_TYPE_ATTACK_CURHP = 2,
  GET_VALUE_TYPE_ATTACK_MAXHP = 3,
  GET_VALUE_TYPE_ATTACK_DEF = 4,
  GET_VALUE_TYPE_TARGET_CURHP = 5,
  GET_VALUE_TYPE_TARGET_MAXHP = 6,
  GET_VALUE_TYPE_TARGET_ATK = 7,
  GET_VALUE_TYPE_TARGET_DEF = 8,
  GET_VALUE_TYPE_TARGET_LOST_HP = 9
};
bool EGetValueType_IsValid(int value);
const EGetValueType EGetValueType_MIN = GET_VALUE_TYPE_NONE;
const EGetValueType EGetValueType_MAX = GET_VALUE_TYPE_TARGET_LOST_HP;
const int EGetValueType_ARRAYSIZE = EGetValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGetValueType_descriptor();
inline const ::std::string& EGetValueType_Name(EGetValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGetValueType_descriptor(), value);
}
inline bool EGetValueType_Parse(
    const ::std::string& name, EGetValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGetValueType>(
    EGetValueType_descriptor(), name, value);
}
enum EDispelBuffType {
  DISPEL_BUFF_TYPE_EFFECT_TYPE = 1,
  DISPEL_BUFF_TYPE_BUFF_TYPE = 2,
  DISPEL_BUFF_TYPE_BUFF_CONFIG_ID = 3
};
bool EDispelBuffType_IsValid(int value);
const EDispelBuffType EDispelBuffType_MIN = DISPEL_BUFF_TYPE_EFFECT_TYPE;
const EDispelBuffType EDispelBuffType_MAX = DISPEL_BUFF_TYPE_BUFF_CONFIG_ID;
const int EDispelBuffType_ARRAYSIZE = EDispelBuffType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDispelBuffType_descriptor();
inline const ::std::string& EDispelBuffType_Name(EDispelBuffType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDispelBuffType_descriptor(), value);
}
inline bool EDispelBuffType_Parse(
    const ::std::string& name, EDispelBuffType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDispelBuffType>(
    EDispelBuffType_descriptor(), name, value);
}
enum EMarkEffectType {
  MARK_EFFECT_TYPE_INCREASE_DMG = 1,
  MARK_EFFECT_TYPE_INCREASE_ATTACK_COUNT = 2,
  MARK_EFFECT_TYPE_RECOVER_HP = 3
};
bool EMarkEffectType_IsValid(int value);
const EMarkEffectType EMarkEffectType_MIN = MARK_EFFECT_TYPE_INCREASE_DMG;
const EMarkEffectType EMarkEffectType_MAX = MARK_EFFECT_TYPE_RECOVER_HP;
const int EMarkEffectType_ARRAYSIZE = EMarkEffectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EMarkEffectType_descriptor();
inline const ::std::string& EMarkEffectType_Name(EMarkEffectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EMarkEffectType_descriptor(), value);
}
inline bool EMarkEffectType_Parse(
    const ::std::string& name, EMarkEffectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMarkEffectType>(
    EMarkEffectType_descriptor(), name, value);
}
enum ESeqOptType {
  SEQ_OPT_TYPE_NONE = 0,
  SEQ_OPT_TYPE_DAMAGE = 1,
  SEQ_OPT_TYPE_CURE = 2,
  SEQ_OPT_TYPE_RELIVE = 3,
  SEQ_OPT_TYPE_UPDATE_BUFF = 4,
  SEQ_OPT_TYPE_REMOVE_BUFF = 5,
  SEQ_OPT_TYPE_UPDATE_STATE = 6,
  SEQ_OPT_TYPE_REMOVE_STATE = 7,
  SEQ_OPT_TYPE_TRIGGER = 8,
  SEQ_OPT_TYPE_ATTR = 9,
  SEQ_OPT_TYPE_EXTRA_ACTION = 10
};
bool ESeqOptType_IsValid(int value);
const ESeqOptType ESeqOptType_MIN = SEQ_OPT_TYPE_NONE;
const ESeqOptType ESeqOptType_MAX = SEQ_OPT_TYPE_EXTRA_ACTION;
const int ESeqOptType_ARRAYSIZE = ESeqOptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESeqOptType_descriptor();
inline const ::std::string& ESeqOptType_Name(ESeqOptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESeqOptType_descriptor(), value);
}
inline bool ESeqOptType_Parse(
    const ::std::string& name, ESeqOptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESeqOptType>(
    ESeqOptType_descriptor(), name, value);
}
enum EOptSeqTimeLine {
  SEQ_TIME_LINE_SKILL_START = 1,
  SEQ_TIME_LINE_SKILL_USING = 2,
  SEQ_TIME_LINE_SKILL_END = 3,
  SEQ_TIME_LINE_SHOT_END = 4,
  SEQ_TIME_LINE_SHOT_START = 5,
  SEQ_TIME_LINE_ROUND_START = 6,
  SEQ_TIME_LINE_ROUND_END = 7,
  SEQ_TIME_LINE_EXTRA_ACTION = 8
};
bool EOptSeqTimeLine_IsValid(int value);
const EOptSeqTimeLine EOptSeqTimeLine_MIN = SEQ_TIME_LINE_SKILL_START;
const EOptSeqTimeLine EOptSeqTimeLine_MAX = SEQ_TIME_LINE_EXTRA_ACTION;
const int EOptSeqTimeLine_ARRAYSIZE = EOptSeqTimeLine_MAX + 1;

const ::google::protobuf::EnumDescriptor* EOptSeqTimeLine_descriptor();
inline const ::std::string& EOptSeqTimeLine_Name(EOptSeqTimeLine value) {
  return ::google::protobuf::internal::NameOfEnum(
    EOptSeqTimeLine_descriptor(), value);
}
inline bool EOptSeqTimeLine_Parse(
    const ::std::string& name, EOptSeqTimeLine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EOptSeqTimeLine>(
    EOptSeqTimeLine_descriptor(), name, value);
}
enum ETriggerConditionClass {
  TRIGGER_CONDITION_CLASS_ATTR = 1,
  TRIGGER_CONDITION_CLASS_ATTACK = 2
};
bool ETriggerConditionClass_IsValid(int value);
const ETriggerConditionClass ETriggerConditionClass_MIN = TRIGGER_CONDITION_CLASS_ATTR;
const ETriggerConditionClass ETriggerConditionClass_MAX = TRIGGER_CONDITION_CLASS_ATTACK;
const int ETriggerConditionClass_ARRAYSIZE = ETriggerConditionClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETriggerConditionClass_descriptor();
inline const ::std::string& ETriggerConditionClass_Name(ETriggerConditionClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETriggerConditionClass_descriptor(), value);
}
inline bool ETriggerConditionClass_Parse(
    const ::std::string& name, ETriggerConditionClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETriggerConditionClass>(
    ETriggerConditionClass_descriptor(), name, value);
}
enum ETriggerConditionAttrType {
  TRIGGER_CONDITION_ATTR_TYPE_LESS_PER = 1,
  TRIGGER_CONDITION_ATTR_TYPE_MORE_PER = 2,
  TRIGGER_CONDITION_ATTR_TYPE_LOSE_PER = 3,
  TRIGGER_CONDITION_ATTR_TYPE_LESS_VAL = 4,
  TRIGGER_CONDITION_ATTR_TYPE_MORE_VAL = 5,
  TRIGGER_CONDITION_ATTR_TYPE_LOSE_VAL = 6,
  TRIGGER_CONDITION_ATTR_TYPE_LESS_TRIGGER = 7,
  TRIGGER_CONDITION_ATTR_TYPE_MORE_TRIGGER = 8
};
bool ETriggerConditionAttrType_IsValid(int value);
const ETriggerConditionAttrType ETriggerConditionAttrType_MIN = TRIGGER_CONDITION_ATTR_TYPE_LESS_PER;
const ETriggerConditionAttrType ETriggerConditionAttrType_MAX = TRIGGER_CONDITION_ATTR_TYPE_MORE_TRIGGER;
const int ETriggerConditionAttrType_ARRAYSIZE = ETriggerConditionAttrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETriggerConditionAttrType_descriptor();
inline const ::std::string& ETriggerConditionAttrType_Name(ETriggerConditionAttrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETriggerConditionAttrType_descriptor(), value);
}
inline bool ETriggerConditionAttrType_Parse(
    const ::std::string& name, ETriggerConditionAttrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETriggerConditionAttrType>(
    ETriggerConditionAttrType_descriptor(), name, value);
}
enum EBuffEffectType {
  BUFF_EFFECT_TYPE_STUN = 1,
  BUFF_EFFECT_TYPE_SILENCE = 2,
  BUFF_EFFECT_TYPE_REDUCE_SP = 3
};
bool EBuffEffectType_IsValid(int value);
const EBuffEffectType EBuffEffectType_MIN = BUFF_EFFECT_TYPE_STUN;
const EBuffEffectType EBuffEffectType_MAX = BUFF_EFFECT_TYPE_REDUCE_SP;
const int EBuffEffectType_ARRAYSIZE = EBuffEffectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffEffectType_descriptor();
inline const ::std::string& EBuffEffectType_Name(EBuffEffectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffEffectType_descriptor(), value);
}
inline bool EBuffEffectType_Parse(
    const ::std::string& name, EBuffEffectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffEffectType>(
    EBuffEffectType_descriptor(), name, value);
}
// ===================================================================

class reward_item : public ::google::protobuf::Message {
 public:
  reward_item();
  virtual ~reward_item();

  reward_item(const reward_item& from);

  inline reward_item& operator=(const reward_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reward_item& default_instance();

  void Swap(reward_item* other);

  // implements Message ----------------------------------------------

  reward_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reward_item& from);
  void MergeFrom(const reward_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional int32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::int32 tid() const;
  inline void set_tid(::google::protobuf::int32 value);

  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.reward_item)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int32 tid_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static reward_item* default_instance_;
};
// -------------------------------------------------------------------

class battle_reward : public ::google::protobuf::Message {
 public:
  battle_reward();
  virtual ~battle_reward();

  battle_reward(const battle_reward& from);

  inline battle_reward& operator=(const battle_reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_reward& default_instance();

  void Swap(battle_reward* other);

  // implements Message ----------------------------------------------

  battle_reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_reward& from);
  void MergeFrom(const battle_reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 hero_exp = 3;
  inline bool has_hero_exp() const;
  inline void clear_hero_exp();
  static const int kHeroExpFieldNumber = 3;
  inline ::google::protobuf::int32 hero_exp() const;
  inline void set_hero_exp(::google::protobuf::int32 value);

  // optional int32 view_hero_exp = 4;
  inline bool has_view_hero_exp() const;
  inline void clear_view_hero_exp();
  static const int kViewHeroExpFieldNumber = 4;
  inline ::google::protobuf::int32 view_hero_exp() const;
  inline void set_view_hero_exp(::google::protobuf::int32 value);

  // repeated .SProtoSpace.reward_item items = 5;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 5;
  inline const ::SProtoSpace::reward_item& items(int index) const;
  inline ::SProtoSpace::reward_item* mutable_items(int index);
  inline ::SProtoSpace::reward_item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::reward_item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::reward_item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_reward)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_hero_exp();
  inline void clear_has_hero_exp();
  inline void set_has_view_hero_exp();
  inline void clear_has_view_hero_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 hero_exp_;
  ::google::protobuf::int32 view_hero_exp_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::reward_item > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_reward* default_instance_;
};
// -------------------------------------------------------------------

class round_op_skill : public ::google::protobuf::Message {
 public:
  round_op_skill();
  virtual ~round_op_skill();

  round_op_skill(const round_op_skill& from);

  inline round_op_skill& operator=(const round_op_skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_op_skill& default_instance();

  void Swap(round_op_skill* other);

  // implements Message ----------------------------------------------

  round_op_skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_op_skill& from);
  void MergeFrom(const round_op_skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint64 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_op_skill)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 obj_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_op_skill* default_instance_;
};
// -------------------------------------------------------------------

class round_op_param : public ::google::protobuf::Message {
 public:
  round_op_param();
  virtual ~round_op_param();

  round_op_param(const round_op_param& from);

  inline round_op_param& operator=(const round_op_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_op_param& default_instance();

  void Swap(round_op_param* other);

  // implements Message ----------------------------------------------

  round_op_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_op_param& from);
  void MergeFrom(const round_op_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ERoundOP type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SProtoSpace::ERoundOP type() const;
  inline void set_type(::SProtoSpace::ERoundOP value);

  // optional .SProtoSpace.round_op_skill skill = 2;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 2;
  inline const ::SProtoSpace::round_op_skill& skill() const;
  inline ::SProtoSpace::round_op_skill* mutable_skill();
  inline ::SProtoSpace::round_op_skill* release_skill();
  inline void set_allocated_skill(::SProtoSpace::round_op_skill* skill);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_op_param)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_skill();
  inline void clear_has_skill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::round_op_skill* skill_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_op_param* default_instance_;
};
// -------------------------------------------------------------------

class damage_data : public ::google::protobuf::Message {
 public:
  damage_data();
  virtual ~damage_data();

  damage_data(const damage_data& from);

  inline damage_data& operator=(const damage_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const damage_data& default_instance();

  void Swap(damage_data* other);

  // implements Message ----------------------------------------------

  damage_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const damage_data& from);
  void MergeFrom(const damage_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint32 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint32 value);

  // required uint32 damage = 2;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // required uint32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required bool critical = 4;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 4;
  inline bool critical() const;
  inline void set_critical(bool value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.damage_data)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_critical();
  inline void clear_has_critical();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 obj_id_;
  ::google::protobuf::uint32 damage_;
  ::google::protobuf::uint32 hp_;
  bool critical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static damage_data* default_instance_;
};
// -------------------------------------------------------------------

class obj_state : public ::google::protobuf::Message {
 public:
  obj_state();
  virtual ~obj_state();

  obj_state(const obj_state& from);

  inline obj_state& operator=(const obj_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const obj_state& default_instance();

  void Swap(obj_state* other);

  // implements Message ----------------------------------------------

  obj_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const obj_state& from);
  void MergeFrom(const obj_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint64 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint64 value);

  // repeated uint32 buff_list = 2;
  inline int buff_list_size() const;
  inline void clear_buff_list();
  static const int kBuffListFieldNumber = 2;
  inline ::google::protobuf::uint32 buff_list(int index) const;
  inline void set_buff_list(int index, ::google::protobuf::uint32 value);
  inline void add_buff_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buff_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buff_list();

  // required int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.obj_state)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 obj_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buff_list_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static obj_state* default_instance_;
};
// -------------------------------------------------------------------

class round_skill_data_damage : public ::google::protobuf::Message {
 public:
  round_skill_data_damage();
  virtual ~round_skill_data_damage();

  round_skill_data_damage(const round_skill_data_damage& from);

  inline round_skill_data_damage& operator=(const round_skill_data_damage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_skill_data_damage& default_instance();

  void Swap(round_skill_data_damage* other);

  // implements Message ----------------------------------------------

  round_skill_data_damage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_skill_data_damage& from);
  void MergeFrom(const round_skill_data_damage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint64 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint64 value);

  // required uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // required uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // required uint32 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // required uint32 hp = 5;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 5;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required bool critical = 6;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 6;
  inline bool critical() const;
  inline void set_critical(bool value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_skill_data_damage)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_critical();
  inline void clear_has_critical();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 obj_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 damage_;
  ::google::protobuf::uint32 hp_;
  bool critical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_skill_data_damage* default_instance_;
};
// -------------------------------------------------------------------

class round_skill_data_cure : public ::google::protobuf::Message {
 public:
  round_skill_data_cure();
  virtual ~round_skill_data_cure();

  round_skill_data_cure(const round_skill_data_cure& from);

  inline round_skill_data_cure& operator=(const round_skill_data_cure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_skill_data_cure& default_instance();

  void Swap(round_skill_data_cure* other);

  // implements Message ----------------------------------------------

  round_skill_data_cure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_skill_data_cure& from);
  void MergeFrom(const round_skill_data_cure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint64 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint64 value);

  // required uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // required uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // required uint32 add_hp = 4;
  inline bool has_add_hp() const;
  inline void clear_add_hp();
  static const int kAddHpFieldNumber = 4;
  inline ::google::protobuf::uint32 add_hp() const;
  inline void set_add_hp(::google::protobuf::uint32 value);

  // required uint32 hp = 5;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 5;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required bool critical = 6;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 6;
  inline bool critical() const;
  inline void set_critical(bool value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_skill_data_cure)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_add_hp();
  inline void clear_has_add_hp();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_critical();
  inline void clear_has_critical();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 obj_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 add_hp_;
  ::google::protobuf::uint32 hp_;
  bool critical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_skill_data_cure* default_instance_;
};
// -------------------------------------------------------------------

class round_buff_data : public ::google::protobuf::Message {
 public:
  round_buff_data();
  virtual ~round_buff_data();

  round_buff_data(const round_buff_data& from);

  inline round_buff_data& operator=(const round_buff_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_buff_data& default_instance();

  void Swap(round_buff_data* other);

  // implements Message ----------------------------------------------

  round_buff_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_buff_data& from);
  void MergeFrom(const round_buff_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 buff_tid = 1;
  inline bool has_buff_tid() const;
  inline void clear_buff_tid();
  static const int kBuffTidFieldNumber = 1;
  inline ::google::protobuf::uint32 buff_tid() const;
  inline void set_buff_tid(::google::protobuf::uint32 value);

  // optional int32 lasttime = 2;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLasttimeFieldNumber = 2;
  inline ::google::protobuf::int32 lasttime() const;
  inline void set_lasttime(::google::protobuf::int32 value);

  // optional uint32 buff_uid = 3;
  inline bool has_buff_uid() const;
  inline void clear_buff_uid();
  static const int kBuffUidFieldNumber = 3;
  inline ::google::protobuf::uint32 buff_uid() const;
  inline void set_buff_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_buff_data)
 private:
  inline void set_has_buff_tid();
  inline void clear_has_buff_tid();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_buff_uid();
  inline void clear_has_buff_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 buff_tid_;
  ::google::protobuf::int32 lasttime_;
  ::google::protobuf::uint32 buff_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_buff_data* default_instance_;
};
// -------------------------------------------------------------------

class round_state_data : public ::google::protobuf::Message {
 public:
  round_state_data();
  virtual ~round_state_data();

  round_state_data(const round_state_data& from);

  inline round_state_data& operator=(const round_state_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_state_data& default_instance();

  void Swap(round_state_data* other);

  // implements Message ----------------------------------------------

  round_state_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_state_data& from);
  void MergeFrom(const round_state_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 state_flag = 1;
  inline bool has_state_flag() const;
  inline void clear_state_flag();
  static const int kStateFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 state_flag() const;
  inline void set_state_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_state_data)
 private:
  inline void set_has_state_flag();
  inline void clear_has_state_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_state_data* default_instance_;
};
// -------------------------------------------------------------------

class round_data : public ::google::protobuf::Message {
 public:
  round_data();
  virtual ~round_data();

  round_data(const round_data& from);

  inline round_data& operator=(const round_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const round_data& default_instance();

  void Swap(round_data* other);

  // implements Message ----------------------------------------------

  round_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const round_data& from);
  void MergeFrom(const round_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 obj_id = 1;
  inline bool has_obj_id() const;
  inline void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  inline ::google::protobuf::uint64 obj_id() const;
  inline void set_obj_id(::google::protobuf::uint64 value);

  // repeated .SProtoSpace.round_buff_data buff_data = 2;
  inline int buff_data_size() const;
  inline void clear_buff_data();
  static const int kBuffDataFieldNumber = 2;
  inline const ::SProtoSpace::round_buff_data& buff_data(int index) const;
  inline ::SProtoSpace::round_buff_data* mutable_buff_data(int index);
  inline ::SProtoSpace::round_buff_data* add_buff_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_buff_data >&
      buff_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_buff_data >*
      mutable_buff_data();

  // optional .SProtoSpace.round_state_data state_data = 3;
  inline bool has_state_data() const;
  inline void clear_state_data();
  static const int kStateDataFieldNumber = 3;
  inline const ::SProtoSpace::round_state_data& state_data() const;
  inline ::SProtoSpace::round_state_data* mutable_state_data();
  inline ::SProtoSpace::round_state_data* release_state_data();
  inline void set_allocated_state_data(::SProtoSpace::round_state_data* state_data);

  // optional int32 hp = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 4;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 camp = 5;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 5;
  inline ::google::protobuf::int32 camp() const;
  inline void set_camp(::google::protobuf::int32 value);

  // optional int32 maxhp = 6;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 6;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // optional int32 sp = 7;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 7;
  inline ::google::protobuf::int32 sp() const;
  inline void set_sp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.round_data)
 private:
  inline void set_has_obj_id();
  inline void clear_has_obj_id();
  inline void set_has_state_data();
  inline void clear_has_state_data();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_sp();
  inline void clear_has_sp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 obj_id_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_buff_data > buff_data_;
  ::SProtoSpace::round_state_data* state_data_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 camp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 sp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static round_data* default_instance_;
};
// -------------------------------------------------------------------

class seq_useskill : public ::google::protobuf::Message {
 public:
  seq_useskill();
  virtual ~seq_useskill();

  seq_useskill(const seq_useskill& from);

  inline seq_useskill& operator=(const seq_useskill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_useskill& default_instance();

  void Swap(seq_useskill* other);

  // implements Message ----------------------------------------------

  seq_useskill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_useskill& from);
  void MergeFrom(const seq_useskill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_useskill)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_useskill* default_instance_;
};
// -------------------------------------------------------------------

class seq_buff : public ::google::protobuf::Message {
 public:
  seq_buff();
  virtual ~seq_buff();

  seq_buff(const seq_buff& from);

  inline seq_buff& operator=(const seq_buff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_buff& default_instance();

  void Swap(seq_buff* other);

  // implements Message ----------------------------------------------

  seq_buff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_buff& from);
  void MergeFrom(const seq_buff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 buff_uid = 3;
  inline bool has_buff_uid() const;
  inline void clear_buff_uid();
  static const int kBuffUidFieldNumber = 3;
  inline ::google::protobuf::uint32 buff_uid() const;
  inline void set_buff_uid(::google::protobuf::uint32 value);

  // optional uint32 buff_tid = 4;
  inline bool has_buff_tid() const;
  inline void clear_buff_tid();
  static const int kBuffTidFieldNumber = 4;
  inline ::google::protobuf::uint32 buff_tid() const;
  inline void set_buff_tid(::google::protobuf::uint32 value);

  // optional uint32 last_round = 5;
  inline bool has_last_round() const;
  inline void clear_last_round();
  static const int kLastRoundFieldNumber = 5;
  inline ::google::protobuf::uint32 last_round() const;
  inline void set_last_round(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_buff)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_buff_uid();
  inline void clear_has_buff_uid();
  inline void set_has_buff_tid();
  inline void clear_has_buff_tid();
  inline void set_has_last_round();
  inline void clear_has_last_round();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 buff_uid_;
  ::google::protobuf::uint32 buff_tid_;
  ::google::protobuf::uint32 last_round_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_buff* default_instance_;
};
// -------------------------------------------------------------------

class seq_state : public ::google::protobuf::Message {
 public:
  seq_state();
  virtual ~seq_state();

  seq_state(const seq_state& from);

  inline seq_state& operator=(const seq_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_state& default_instance();

  void Swap(seq_state* other);

  // implements Message ----------------------------------------------

  seq_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_state& from);
  void MergeFrom(const seq_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 state_index = 3;
  inline bool has_state_index() const;
  inline void clear_state_index();
  static const int kStateIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 state_index() const;
  inline void set_state_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_state)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_state_index();
  inline void clear_has_state_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 state_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_state* default_instance_;
};
// -------------------------------------------------------------------

class seq_damage : public ::google::protobuf::Message {
 public:
  seq_damage();
  virtual ~seq_damage();

  seq_damage(const seq_damage& from);

  inline seq_damage& operator=(const seq_damage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_damage& default_instance();

  void Swap(seq_damage* other);

  // implements Message ----------------------------------------------

  seq_damage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_damage& from);
  void MergeFrom(const seq_damage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional bool dodge = 3;
  inline bool has_dodge() const;
  inline void clear_dodge();
  static const int kDodgeFieldNumber = 3;
  inline bool dodge() const;
  inline void set_dodge(bool value);

  // optional uint32 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // optional uint32 hp = 5;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 5;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // optional bool critical = 6;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 6;
  inline bool critical() const;
  inline void set_critical(bool value);

  // optional uint32 buff_id = 7 [default = 0];
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 7;
  inline ::google::protobuf::uint32 buff_id() const;
  inline void set_buff_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_damage)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_dodge();
  inline void clear_has_dodge();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_critical();
  inline void clear_has_critical();
  inline void set_has_buff_id();
  inline void clear_has_buff_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 damage_;
  bool dodge_;
  bool critical_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 buff_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_damage* default_instance_;
};
// -------------------------------------------------------------------

class seq_relive : public ::google::protobuf::Message {
 public:
  seq_relive();
  virtual ~seq_relive();

  seq_relive(const seq_relive& from);

  inline seq_relive& operator=(const seq_relive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_relive& default_instance();

  void Swap(seq_relive* other);

  // implements Message ----------------------------------------------

  seq_relive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_relive& from);
  void MergeFrom(const seq_relive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 hp = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 4;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_relive)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_relive* default_instance_;
};
// -------------------------------------------------------------------

class seq_attr : public ::google::protobuf::Message {
 public:
  seq_attr();
  virtual ~seq_attr();

  seq_attr(const seq_attr& from);

  inline seq_attr& operator=(const seq_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_attr& default_instance();

  void Swap(seq_attr* other);

  // implements Message ----------------------------------------------

  seq_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_attr& from);
  void MergeFrom(const seq_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint32 attr = 2;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 2;
  inline ::google::protobuf::uint32 attr() const;
  inline void set_attr(::google::protobuf::uint32 value);

  // optional int32 change_attr = 3;
  inline bool has_change_attr() const;
  inline void clear_change_attr();
  static const int kChangeAttrFieldNumber = 3;
  inline ::google::protobuf::int32 change_attr() const;
  inline void set_change_attr(::google::protobuf::int32 value);

  // optional int32 val = 4;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::int32 val() const;
  inline void set_val(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_attr)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_change_attr();
  inline void clear_has_change_attr();
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint32 attr_;
  ::google::protobuf::int32 change_attr_;
  ::google::protobuf::int32 val_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_attr* default_instance_;
};
// -------------------------------------------------------------------

class seq_extra_action : public ::google::protobuf::Message {
 public:
  seq_extra_action();
  virtual ~seq_extra_action();

  seq_extra_action(const seq_extra_action& from);

  inline seq_extra_action& operator=(const seq_extra_action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_extra_action& default_instance();

  void Swap(seq_extra_action* other);

  // implements Message ----------------------------------------------

  seq_extra_action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_extra_action& from);
  void MergeFrom(const seq_extra_action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 2;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_extra_action)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 skill_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_extra_action* default_instance_;
};
// -------------------------------------------------------------------

class seq_sp : public ::google::protobuf::Message {
 public:
  seq_sp();
  virtual ~seq_sp();

  seq_sp(const seq_sp& from);

  inline seq_sp& operator=(const seq_sp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const seq_sp& default_instance();

  void Swap(seq_sp* other);

  // implements Message ----------------------------------------------

  seq_sp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const seq_sp& from);
  void MergeFrom(const seq_sp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 cast_id = 1;
  inline bool has_cast_id() const;
  inline void clear_cast_id();
  static const int kCastIdFieldNumber = 1;
  inline ::google::protobuf::uint64 cast_id() const;
  inline void set_cast_id(::google::protobuf::uint64 value);

  // optional uint32 change_sp = 2;
  inline bool has_change_sp() const;
  inline void clear_change_sp();
  static const int kChangeSpFieldNumber = 2;
  inline ::google::protobuf::uint32 change_sp() const;
  inline void set_change_sp(::google::protobuf::uint32 value);

  // optional uint32 sp = 3;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 3;
  inline ::google::protobuf::uint32 sp() const;
  inline void set_sp(::google::protobuf::uint32 value);

  // optional uint32 max_sp = 4;
  inline bool has_max_sp() const;
  inline void clear_max_sp();
  static const int kMaxSpFieldNumber = 4;
  inline ::google::protobuf::uint32 max_sp() const;
  inline void set_max_sp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.seq_sp)
 private:
  inline void set_has_cast_id();
  inline void clear_has_cast_id();
  inline void set_has_change_sp();
  inline void clear_has_change_sp();
  inline void set_has_sp();
  inline void clear_has_sp();
  inline void set_has_max_sp();
  inline void clear_has_max_sp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cast_id_;
  ::google::protobuf::uint32 change_sp_;
  ::google::protobuf::uint32 sp_;
  ::google::protobuf::uint32 max_sp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static seq_sp* default_instance_;
};
// -------------------------------------------------------------------

class opt_seq : public ::google::protobuf::Message {
 public:
  opt_seq();
  virtual ~opt_seq();

  opt_seq(const opt_seq& from);

  inline opt_seq& operator=(const opt_seq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const opt_seq& default_instance();

  void Swap(opt_seq* other);

  // implements Message ----------------------------------------------

  opt_seq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const opt_seq& from);
  void MergeFrom(const opt_seq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESeqOptType opt_type = 1;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 1;
  inline ::SProtoSpace::ESeqOptType opt_type() const;
  inline void set_opt_type(::SProtoSpace::ESeqOptType value);

  // optional .SProtoSpace.seq_buff buff = 2;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 2;
  inline const ::SProtoSpace::seq_buff& buff() const;
  inline ::SProtoSpace::seq_buff* mutable_buff();
  inline ::SProtoSpace::seq_buff* release_buff();
  inline void set_allocated_buff(::SProtoSpace::seq_buff* buff);

  // optional .SProtoSpace.seq_state state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::SProtoSpace::seq_state& state() const;
  inline ::SProtoSpace::seq_state* mutable_state();
  inline ::SProtoSpace::seq_state* release_state();
  inline void set_allocated_state(::SProtoSpace::seq_state* state);

  // optional .SProtoSpace.seq_damage damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline const ::SProtoSpace::seq_damage& damage() const;
  inline ::SProtoSpace::seq_damage* mutable_damage();
  inline ::SProtoSpace::seq_damage* release_damage();
  inline void set_allocated_damage(::SProtoSpace::seq_damage* damage);

  // optional .SProtoSpace.seq_relive relive = 5;
  inline bool has_relive() const;
  inline void clear_relive();
  static const int kReliveFieldNumber = 5;
  inline const ::SProtoSpace::seq_relive& relive() const;
  inline ::SProtoSpace::seq_relive* mutable_relive();
  inline ::SProtoSpace::seq_relive* release_relive();
  inline void set_allocated_relive(::SProtoSpace::seq_relive* relive);

  // optional .SProtoSpace.seq_attr attr = 6;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 6;
  inline const ::SProtoSpace::seq_attr& attr() const;
  inline ::SProtoSpace::seq_attr* mutable_attr();
  inline ::SProtoSpace::seq_attr* release_attr();
  inline void set_allocated_attr(::SProtoSpace::seq_attr* attr);

  // optional .SProtoSpace.seq_extra_action extra_action = 7;
  inline bool has_extra_action() const;
  inline void clear_extra_action();
  static const int kExtraActionFieldNumber = 7;
  inline const ::SProtoSpace::seq_extra_action& extra_action() const;
  inline ::SProtoSpace::seq_extra_action* mutable_extra_action();
  inline ::SProtoSpace::seq_extra_action* release_extra_action();
  inline void set_allocated_extra_action(::SProtoSpace::seq_extra_action* extra_action);

  // @@protoc_insertion_point(class_scope:SProtoSpace.opt_seq)
 private:
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_buff();
  inline void clear_has_buff();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_relive();
  inline void clear_has_relive();
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_extra_action();
  inline void clear_has_extra_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::seq_buff* buff_;
  ::SProtoSpace::seq_state* state_;
  ::SProtoSpace::seq_damage* damage_;
  ::SProtoSpace::seq_relive* relive_;
  ::SProtoSpace::seq_attr* attr_;
  ::SProtoSpace::seq_extra_action* extra_action_;
  int opt_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static opt_seq* default_instance_;
};
// -------------------------------------------------------------------

class hit_seq : public ::google::protobuf::Message {
 public:
  hit_seq();
  virtual ~hit_seq();

  hit_seq(const hit_seq& from);

  inline hit_seq& operator=(const hit_seq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hit_seq& default_instance();

  void Swap(hit_seq* other);

  // implements Message ----------------------------------------------

  hit_seq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hit_seq& from);
  void MergeFrom(const hit_seq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.EOptSeqTimeLine time_type = 1;
  inline bool has_time_type() const;
  inline void clear_time_type();
  static const int kTimeTypeFieldNumber = 1;
  inline ::SProtoSpace::EOptSeqTimeLine time_type() const;
  inline void set_time_type(::SProtoSpace::EOptSeqTimeLine value);

  // optional uint32 hit_index = 2;
  inline bool has_hit_index() const;
  inline void clear_hit_index();
  static const int kHitIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 hit_index() const;
  inline void set_hit_index(::google::protobuf::uint32 value);

  // repeated .SProtoSpace.opt_seq seqs = 3;
  inline int seqs_size() const;
  inline void clear_seqs();
  static const int kSeqsFieldNumber = 3;
  inline const ::SProtoSpace::opt_seq& seqs(int index) const;
  inline ::SProtoSpace::opt_seq* mutable_seqs(int index);
  inline ::SProtoSpace::opt_seq* add_seqs();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::opt_seq >&
      seqs() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::opt_seq >*
      mutable_seqs();

  // @@protoc_insertion_point(class_scope:SProtoSpace.hit_seq)
 private:
  inline void set_has_time_type();
  inline void clear_has_time_type();
  inline void set_has_hit_index();
  inline void clear_has_hit_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int time_type_;
  ::google::protobuf::uint32 hit_index_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::opt_seq > seqs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static hit_seq* default_instance_;
};
// -------------------------------------------------------------------

class opt_seqs : public ::google::protobuf::Message {
 public:
  opt_seqs();
  virtual ~opt_seqs();

  opt_seqs(const opt_seqs& from);

  inline opt_seqs& operator=(const opt_seqs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const opt_seqs& default_instance();

  void Swap(opt_seqs* other);

  // implements Message ----------------------------------------------

  opt_seqs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const opt_seqs& from);
  void MergeFrom(const opt_seqs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.round_op_param opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline const ::SProtoSpace::round_op_param& opt() const;
  inline ::SProtoSpace::round_op_param* mutable_opt();
  inline ::SProtoSpace::round_op_param* release_opt();
  inline void set_allocated_opt(::SProtoSpace::round_op_param* opt);

  // repeated .SProtoSpace.hit_seq seqs = 2;
  inline int seqs_size() const;
  inline void clear_seqs();
  static const int kSeqsFieldNumber = 2;
  inline const ::SProtoSpace::hit_seq& seqs(int index) const;
  inline ::SProtoSpace::hit_seq* mutable_seqs(int index);
  inline ::SProtoSpace::hit_seq* add_seqs();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hit_seq >&
      seqs() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hit_seq >*
      mutable_seqs();

  // @@protoc_insertion_point(class_scope:SProtoSpace.opt_seqs)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::round_op_param* opt_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hit_seq > seqs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static opt_seqs* default_instance_;
};
// -------------------------------------------------------------------

class battle_hero_info : public ::google::protobuf::Message {
 public:
  battle_hero_info();
  virtual ~battle_hero_info();

  battle_hero_info(const battle_hero_info& from);

  inline battle_hero_info& operator=(const battle_hero_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_hero_info& default_instance();

  void Swap(battle_hero_info* other);

  // implements Message ----------------------------------------------

  battle_hero_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_hero_info& from);
  void MergeFrom(const battle_hero_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.hero_base_info base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::SProtoSpace::hero_base_info& base() const;
  inline ::SProtoSpace::hero_base_info* mutable_base();
  inline ::SProtoSpace::hero_base_info* release_base();
  inline void set_allocated_base(::SProtoSpace::hero_base_info* base);

  // repeated .SProtoSpace.hero_attr_value base_attr = 2;
  inline int base_attr_size() const;
  inline void clear_base_attr();
  static const int kBaseAttrFieldNumber = 2;
  inline const ::SProtoSpace::hero_attr_value& base_attr(int index) const;
  inline ::SProtoSpace::hero_attr_value* mutable_base_attr(int index);
  inline ::SProtoSpace::hero_attr_value* add_base_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
      base_attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
      mutable_base_attr();

  // repeated .SProtoSpace.client_skill_data skill_data = 3;
  inline int skill_data_size() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 3;
  inline const ::SProtoSpace::client_skill_data& skill_data(int index) const;
  inline ::SProtoSpace::client_skill_data* mutable_skill_data(int index);
  inline ::SProtoSpace::client_skill_data* add_skill_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >&
      skill_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >*
      mutable_skill_data();

  // optional .SProtoSpace.round_data rd_data = 4;
  inline bool has_rd_data() const;
  inline void clear_rd_data();
  static const int kRdDataFieldNumber = 4;
  inline const ::SProtoSpace::round_data& rd_data() const;
  inline ::SProtoSpace::round_data* mutable_rd_data();
  inline ::SProtoSpace::round_data* release_rd_data();
  inline void set_allocated_rd_data(::SProtoSpace::round_data* rd_data);

  // repeated .SProtoSpace.hero_attr_value total_attr = 5;
  inline int total_attr_size() const;
  inline void clear_total_attr();
  static const int kTotalAttrFieldNumber = 5;
  inline const ::SProtoSpace::hero_attr_value& total_attr(int index) const;
  inline ::SProtoSpace::hero_attr_value* mutable_total_attr(int index);
  inline ::SProtoSpace::hero_attr_value* add_total_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
      total_attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
      mutable_total_attr();

  // optional int32 formation_index = 6;
  inline bool has_formation_index() const;
  inline void clear_formation_index();
  static const int kFormationIndexFieldNumber = 6;
  inline ::google::protobuf::int32 formation_index() const;
  inline void set_formation_index(::google::protobuf::int32 value);

  // optional int32 create_type = 7;
  inline bool has_create_type() const;
  inline void clear_create_type();
  static const int kCreateTypeFieldNumber = 7;
  inline ::google::protobuf::int32 create_type() const;
  inline void set_create_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_hero_info)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_rd_data();
  inline void clear_has_rd_data();
  inline void set_has_formation_index();
  inline void clear_has_formation_index();
  inline void set_has_create_type();
  inline void clear_has_create_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::hero_base_info* base_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value > base_attr_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data > skill_data_;
  ::SProtoSpace::round_data* rd_data_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value > total_attr_;
  ::google::protobuf::int32 formation_index_;
  ::google::protobuf::int32 create_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_hero_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_player_base_info : public ::google::protobuf::Message {
 public:
  battle_player_base_info();
  virtual ~battle_player_base_info();

  battle_player_base_info(const battle_player_base_info& from);

  inline battle_player_base_info& operator=(const battle_player_base_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_player_base_info& default_instance();

  void Swap(battle_player_base_info* other);

  // implements Message ----------------------------------------------

  battle_player_base_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_player_base_info& from);
  void MergeFrom(const battle_player_base_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 template_id = 2;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 2;
  inline ::google::protobuf::uint32 template_id() const;
  inline void set_template_id(::google::protobuf::uint32 value);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_player_base_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_template_id();
  inline void clear_has_template_id();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 template_id_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_player_base_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_player_info : public ::google::protobuf::Message {
 public:
  battle_player_info();
  virtual ~battle_player_info();

  battle_player_info(const battle_player_info& from);

  inline battle_player_info& operator=(const battle_player_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_player_info& default_instance();

  void Swap(battle_player_info* other);

  // implements Message ----------------------------------------------

  battle_player_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_player_info& from);
  void MergeFrom(const battle_player_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.battle_player_base_info base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::SProtoSpace::battle_player_base_info& base() const;
  inline ::SProtoSpace::battle_player_base_info* mutable_base();
  inline ::SProtoSpace::battle_player_base_info* release_base();
  inline void set_allocated_base(::SProtoSpace::battle_player_base_info* base);

  // repeated .SProtoSpace.hero_attr_value base_attr = 2;
  inline int base_attr_size() const;
  inline void clear_base_attr();
  static const int kBaseAttrFieldNumber = 2;
  inline const ::SProtoSpace::hero_attr_value& base_attr(int index) const;
  inline ::SProtoSpace::hero_attr_value* mutable_base_attr(int index);
  inline ::SProtoSpace::hero_attr_value* add_base_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
      base_attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
      mutable_base_attr();

  // repeated .SProtoSpace.client_skill_data skill_data = 3;
  inline int skill_data_size() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 3;
  inline const ::SProtoSpace::client_skill_data& skill_data(int index) const;
  inline ::SProtoSpace::client_skill_data* mutable_skill_data(int index);
  inline ::SProtoSpace::client_skill_data* add_skill_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >&
      skill_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >*
      mutable_skill_data();

  // optional .SProtoSpace.round_data rd_data = 4;
  inline bool has_rd_data() const;
  inline void clear_rd_data();
  static const int kRdDataFieldNumber = 4;
  inline const ::SProtoSpace::round_data& rd_data() const;
  inline ::SProtoSpace::round_data* mutable_rd_data();
  inline ::SProtoSpace::round_data* release_rd_data();
  inline void set_allocated_rd_data(::SProtoSpace::round_data* rd_data);

  // optional int32 formation_index = 5;
  inline bool has_formation_index() const;
  inline void clear_formation_index();
  static const int kFormationIndexFieldNumber = 5;
  inline ::google::protobuf::int32 formation_index() const;
  inline void set_formation_index(::google::protobuf::int32 value);

  // repeated .SProtoSpace.hero_attr_value total_attr = 6;
  inline int total_attr_size() const;
  inline void clear_total_attr();
  static const int kTotalAttrFieldNumber = 6;
  inline const ::SProtoSpace::hero_attr_value& total_attr(int index) const;
  inline ::SProtoSpace::hero_attr_value* mutable_total_attr(int index);
  inline ::SProtoSpace::hero_attr_value* add_total_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
      total_attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
      mutable_total_attr();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_player_info)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_rd_data();
  inline void clear_has_rd_data();
  inline void set_has_formation_index();
  inline void clear_has_formation_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::battle_player_base_info* base_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value > base_attr_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data > skill_data_;
  ::SProtoSpace::round_data* rd_data_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value > total_attr_;
  ::google::protobuf::int32 formation_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_player_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_role_info : public ::google::protobuf::Message {
 public:
  battle_role_info();
  virtual ~battle_role_info();

  battle_role_info(const battle_role_info& from);

  inline battle_role_info& operator=(const battle_role_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_role_info& default_instance();

  void Swap(battle_role_info* other);

  // implements Message ----------------------------------------------

  battle_role_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_role_info& from);
  void MergeFrom(const battle_role_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.EPlayerType type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::SProtoSpace::EPlayerType type() const;
  inline void set_type(::SProtoSpace::EPlayerType value);

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // repeated .SProtoSpace.battle_hero_info heroes = 4;
  inline int heroes_size() const;
  inline void clear_heroes();
  static const int kHeroesFieldNumber = 4;
  inline const ::SProtoSpace::battle_hero_info& heroes(int index) const;
  inline ::SProtoSpace::battle_hero_info* mutable_heroes(int index);
  inline ::SProtoSpace::battle_hero_info* add_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_hero_info >&
      heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_hero_info >*
      mutable_heroes();

  // optional uint64 gsid = 5;
  inline bool has_gsid() const;
  inline void clear_gsid();
  static const int kGsidFieldNumber = 5;
  inline ::google::protobuf::uint64 gsid() const;
  inline void set_gsid(::google::protobuf::uint64 value);

  // optional .SProtoSpace.battle_player_info player = 6;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 6;
  inline const ::SProtoSpace::battle_player_info& player() const;
  inline ::SProtoSpace::battle_player_info* mutable_player();
  inline ::SProtoSpace::battle_player_info* release_player();
  inline void set_allocated_player(::SProtoSpace::battle_player_info* player);

  // optional uint64 gtid = 8;
  inline bool has_gtid() const;
  inline void clear_gtid();
  static const int kGtidFieldNumber = 8;
  inline ::google::protobuf::uint64 gtid() const;
  inline void set_gtid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_role_info)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gsid();
  inline void clear_has_gsid();
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_gtid();
  inline void clear_has_gtid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int type_;
  ::google::protobuf::int32 level_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_hero_info > heroes_;
  ::google::protobuf::uint64 gsid_;
  ::SProtoSpace::battle_player_info* player_;
  ::google::protobuf::uint64 gtid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_role_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_camp_info : public ::google::protobuf::Message {
 public:
  battle_camp_info();
  virtual ~battle_camp_info();

  battle_camp_info(const battle_camp_info& from);

  inline battle_camp_info& operator=(const battle_camp_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_camp_info& default_instance();

  void Swap(battle_camp_info* other);

  // implements Message ----------------------------------------------

  battle_camp_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_camp_info& from);
  void MergeFrom(const battle_camp_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.battle_role_info roles = 1;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 1;
  inline const ::SProtoSpace::battle_role_info& roles(int index) const;
  inline ::SProtoSpace::battle_role_info* mutable_roles(int index);
  inline ::SProtoSpace::battle_role_info* add_roles();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_role_info >&
      roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_role_info >*
      mutable_roles();

  // optional int32 init_power = 2;
  inline bool has_init_power() const;
  inline void clear_init_power();
  static const int kInitPowerFieldNumber = 2;
  inline ::google::protobuf::int32 init_power() const;
  inline void set_init_power(::google::protobuf::int32 value);

  // optional int32 camp = 3;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 3;
  inline ::google::protobuf::int32 camp() const;
  inline void set_camp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_camp_info)
 private:
  inline void set_has_init_power();
  inline void clear_has_init_power();
  inline void set_has_camp();
  inline void clear_has_camp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_role_info > roles_;
  ::google::protobuf::int32 init_power_;
  ::google::protobuf::int32 camp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_camp_info* default_instance_;
};
// -------------------------------------------------------------------

class pvp_battle_init_data : public ::google::protobuf::Message {
 public:
  pvp_battle_init_data();
  virtual ~pvp_battle_init_data();

  pvp_battle_init_data(const pvp_battle_init_data& from);

  inline pvp_battle_init_data& operator=(const pvp_battle_init_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pvp_battle_init_data& default_instance();

  void Swap(pvp_battle_init_data* other);

  // implements Message ----------------------------------------------

  pvp_battle_init_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pvp_battle_init_data& from);
  void MergeFrom(const pvp_battle_init_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.battle_camp_info camps = 1;
  inline int camps_size() const;
  inline void clear_camps();
  static const int kCampsFieldNumber = 1;
  inline const ::SProtoSpace::battle_camp_info& camps(int index) const;
  inline ::SProtoSpace::battle_camp_info* mutable_camps(int index);
  inline ::SProtoSpace::battle_camp_info* add_camps();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >&
      camps() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >*
      mutable_camps();

  // @@protoc_insertion_point(class_scope:SProtoSpace.pvp_battle_init_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info > camps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static pvp_battle_init_data* default_instance_;
};
// -------------------------------------------------------------------

class battle_end_data : public ::google::protobuf::Message {
 public:
  battle_end_data();
  virtual ~battle_end_data();

  battle_end_data(const battle_end_data& from);

  inline battle_end_data& operator=(const battle_end_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_end_data& default_instance();

  void Swap(battle_end_data* other);

  // implements Message ----------------------------------------------

  battle_end_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_end_data& from);
  void MergeFrom(const battle_end_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 battle_id = 2;
  inline bool has_battle_id() const;
  inline void clear_battle_id();
  static const int kBattleIdFieldNumber = 2;
  inline ::google::protobuf::int32 battle_id() const;
  inline void set_battle_id(::google::protobuf::int32 value);

  // optional bool is_win = 3;
  inline bool has_is_win() const;
  inline void clear_is_win();
  static const int kIsWinFieldNumber = 3;
  inline bool is_win() const;
  inline void set_is_win(bool value);

  // repeated .SProtoSpace.battle_check_opt_data opts = 4;
  inline int opts_size() const;
  inline void clear_opts();
  static const int kOptsFieldNumber = 4;
  inline const ::SProtoSpace::battle_check_opt_data& opts(int index) const;
  inline ::SProtoSpace::battle_check_opt_data* mutable_opts(int index);
  inline ::SProtoSpace::battle_check_opt_data* add_opts();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >&
      opts() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >*
      mutable_opts();

  // optional int32 module_id = 5;
  inline bool has_module_id() const;
  inline void clear_module_id();
  static const int kModuleIdFieldNumber = 5;
  inline ::google::protobuf::int32 module_id() const;
  inline void set_module_id(::google::protobuf::int32 value);

  // optional .SProtoSpace.EHeroFormationType formation_type = 6;
  inline bool has_formation_type() const;
  inline void clear_formation_type();
  static const int kFormationTypeFieldNumber = 6;
  inline ::SProtoSpace::EHeroFormationType formation_type() const;
  inline void set_formation_type(::SProtoSpace::EHeroFormationType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_end_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_battle_id();
  inline void clear_has_battle_id();
  inline void set_has_is_win();
  inline void clear_has_is_win();
  inline void set_has_module_id();
  inline void clear_has_module_id();
  inline void set_has_formation_type();
  inline void clear_has_formation_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 battle_id_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data > opts_;
  bool is_win_;
  ::google::protobuf::int32 module_id_;
  int formation_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_end_data* default_instance_;
};
// -------------------------------------------------------------------

class pve_check_battle_init_data : public ::google::protobuf::Message {
 public:
  pve_check_battle_init_data();
  virtual ~pve_check_battle_init_data();

  pve_check_battle_init_data(const pve_check_battle_init_data& from);

  inline pve_check_battle_init_data& operator=(const pve_check_battle_init_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pve_check_battle_init_data& default_instance();

  void Swap(pve_check_battle_init_data* other);

  // implements Message ----------------------------------------------

  pve_check_battle_init_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pve_check_battle_init_data& from);
  void MergeFrom(const pve_check_battle_init_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional uint64 gs_id = 2;
  inline bool has_gs_id() const;
  inline void clear_gs_id();
  static const int kGsIdFieldNumber = 2;
  inline ::google::protobuf::uint64 gs_id() const;
  inline void set_gs_id(::google::protobuf::uint64 value);

  // optional .SProtoSpace.battle_end_data battle_end_info = 3;
  inline bool has_battle_end_info() const;
  inline void clear_battle_end_info();
  static const int kBattleEndInfoFieldNumber = 3;
  inline const ::SProtoSpace::battle_end_data& battle_end_info() const;
  inline ::SProtoSpace::battle_end_data* mutable_battle_end_info();
  inline ::SProtoSpace::battle_end_data* release_battle_end_info();
  inline void set_allocated_battle_end_info(::SProtoSpace::battle_end_data* battle_end_info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.pve_check_battle_init_data)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_gs_id();
  inline void clear_has_gs_id();
  inline void set_has_battle_end_info();
  inline void clear_has_battle_end_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  ::google::protobuf::uint64 gs_id_;
  ::SProtoSpace::battle_end_data* battle_end_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static pve_check_battle_init_data* default_instance_;
};
// -------------------------------------------------------------------

class create_battle_data : public ::google::protobuf::Message {
 public:
  create_battle_data();
  virtual ~create_battle_data();

  create_battle_data(const create_battle_data& from);

  inline create_battle_data& operator=(const create_battle_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const create_battle_data& default_instance();

  void Swap(create_battle_data* other);

  // implements Message ----------------------------------------------

  create_battle_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const create_battle_data& from);
  void MergeFrom(const create_battle_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.EBattleType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SProtoSpace::EBattleType type() const;
  inline void set_type(::SProtoSpace::EBattleType value);

  // optional uint32 combat_id = 2;
  inline bool has_combat_id() const;
  inline void clear_combat_id();
  static const int kCombatIdFieldNumber = 2;
  inline ::google::protobuf::uint32 combat_id() const;
  inline void set_combat_id(::google::protobuf::uint32 value);

  // optional uint32 seed = 3;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 3;
  inline ::google::protobuf::uint32 seed() const;
  inline void set_seed(::google::protobuf::uint32 value);

  // optional .SProtoSpace.pvp_battle_init_data pvp_data = 4;
  inline bool has_pvp_data() const;
  inline void clear_pvp_data();
  static const int kPvpDataFieldNumber = 4;
  inline const ::SProtoSpace::pvp_battle_init_data& pvp_data() const;
  inline ::SProtoSpace::pvp_battle_init_data* mutable_pvp_data();
  inline ::SProtoSpace::pvp_battle_init_data* release_pvp_data();
  inline void set_allocated_pvp_data(::SProtoSpace::pvp_battle_init_data* pvp_data);

  // optional .SProtoSpace.pve_check_battle_init_data pve_check_data = 5;
  inline bool has_pve_check_data() const;
  inline void clear_pve_check_data();
  static const int kPveCheckDataFieldNumber = 5;
  inline const ::SProtoSpace::pve_check_battle_init_data& pve_check_data() const;
  inline ::SProtoSpace::pve_check_battle_init_data* mutable_pve_check_data();
  inline ::SProtoSpace::pve_check_battle_init_data* release_pve_check_data();
  inline void set_allocated_pve_check_data(::SProtoSpace::pve_check_battle_init_data* pve_check_data);

  // @@protoc_insertion_point(class_scope:SProtoSpace.create_battle_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_combat_id();
  inline void clear_has_combat_id();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_pvp_data();
  inline void clear_has_pvp_data();
  inline void set_has_pve_check_data();
  inline void clear_has_pve_check_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 combat_id_;
  ::SProtoSpace::pvp_battle_init_data* pvp_data_;
  ::SProtoSpace::pve_check_battle_init_data* pve_check_data_;
  ::google::protobuf::uint32 seed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static create_battle_data* default_instance_;
};
// -------------------------------------------------------------------

class running_entity : public ::google::protobuf::Message {
 public:
  running_entity();
  virtual ~running_entity();

  running_entity(const running_entity& from);

  inline running_entity& operator=(const running_entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const running_entity& default_instance();

  void Swap(running_entity* other);

  // implements Message ----------------------------------------------

  running_entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const running_entity& from);
  void MergeFrom(const running_entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 objid = 1;
  inline bool has_objid() const;
  inline void clear_objid();
  static const int kObjidFieldNumber = 1;
  inline ::google::protobuf::uint64 objid() const;
  inline void set_objid(::google::protobuf::uint64 value);

  // optional int32 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.running_entity)
 private:
  inline void set_has_objid();
  inline void clear_has_objid();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 objid_;
  ::google::protobuf::int32 position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static running_entity* default_instance_;
};
// -------------------------------------------------------------------

class running_queue : public ::google::protobuf::Message {
 public:
  running_queue();
  virtual ~running_queue();

  running_queue(const running_queue& from);

  inline running_queue& operator=(const running_queue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const running_queue& default_instance();

  void Swap(running_queue* other);

  // implements Message ----------------------------------------------

  running_queue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const running_queue& from);
  void MergeFrom(const running_queue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 lenth = 1;
  inline bool has_lenth() const;
  inline void clear_lenth();
  static const int kLenthFieldNumber = 1;
  inline ::google::protobuf::int32 lenth() const;
  inline void set_lenth(::google::protobuf::int32 value);

  // repeated .SProtoSpace.running_entity enities = 2;
  inline int enities_size() const;
  inline void clear_enities();
  static const int kEnitiesFieldNumber = 2;
  inline const ::SProtoSpace::running_entity& enities(int index) const;
  inline ::SProtoSpace::running_entity* mutable_enities(int index);
  inline ::SProtoSpace::running_entity* add_enities();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >&
      enities() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >*
      mutable_enities();

  // repeated .SProtoSpace.running_entity wait_enities = 3;
  inline int wait_enities_size() const;
  inline void clear_wait_enities();
  static const int kWaitEnitiesFieldNumber = 3;
  inline const ::SProtoSpace::running_entity& wait_enities(int index) const;
  inline ::SProtoSpace::running_entity* mutable_wait_enities(int index);
  inline ::SProtoSpace::running_entity* add_wait_enities();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >&
      wait_enities() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >*
      mutable_wait_enities();

  // @@protoc_insertion_point(class_scope:SProtoSpace.running_queue)
 private:
  inline void set_has_lenth();
  inline void clear_has_lenth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity > enities_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity > wait_enities_;
  ::google::protobuf::int32 lenth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static running_queue* default_instance_;
};
// -------------------------------------------------------------------

class client_hero_info : public ::google::protobuf::Message {
 public:
  client_hero_info();
  virtual ~client_hero_info();

  client_hero_info(const client_hero_info& from);

  inline client_hero_info& operator=(const client_hero_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_hero_info& default_instance();

  void Swap(client_hero_info* other);

  // implements Message ----------------------------------------------

  client_hero_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_hero_info& from);
  void MergeFrom(const client_hero_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required uint32 objid = 2;
  inline bool has_objid() const;
  inline void clear_objid();
  static const int kObjidFieldNumber = 2;
  inline ::google::protobuf::uint32 objid() const;
  inline void set_objid(::google::protobuf::uint32 value);

  // required uint32 template_id = 3;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 3;
  inline ::google::protobuf::uint32 template_id() const;
  inline void set_template_id(::google::protobuf::uint32 value);

  // required int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 star = 5;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 5;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // optional int32 quality = 6;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 6;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.client_hero_info)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_objid();
  inline void clear_has_objid();
  inline void set_has_template_id();
  inline void clear_has_template_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::uint32 objid_;
  ::google::protobuf::uint32 template_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 star_;
  ::std::string* name_;
  ::google::protobuf::int32 quality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static client_hero_info* default_instance_;
};
// -------------------------------------------------------------------

class client_battle_player_info : public ::google::protobuf::Message {
 public:
  client_battle_player_info();
  virtual ~client_battle_player_info();

  client_battle_player_info(const client_battle_player_info& from);

  inline client_battle_player_info& operator=(const client_battle_player_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_battle_player_info& default_instance();

  void Swap(client_battle_player_info* other);

  // implements Message ----------------------------------------------

  client_battle_player_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_battle_player_info& from);
  void MergeFrom(const client_battle_player_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 camp = 4;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 4;
  inline ::google::protobuf::int32 camp() const;
  inline void set_camp(::google::protobuf::int32 value);

  // required .SProtoSpace.EPlayerType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::SProtoSpace::EPlayerType type() const;
  inline void set_type(::SProtoSpace::EPlayerType value);

  // repeated .SProtoSpace.client_hero_info heroes = 6;
  inline int heroes_size() const;
  inline void clear_heroes();
  static const int kHeroesFieldNumber = 6;
  inline const ::SProtoSpace::client_hero_info& heroes(int index) const;
  inline ::SProtoSpace::client_hero_info* mutable_heroes(int index);
  inline ::SProtoSpace::client_hero_info* add_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_hero_info >&
      heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_hero_info >*
      mutable_heroes();

  // @@protoc_insertion_point(class_scope:SProtoSpace.client_battle_player_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 camp_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_hero_info > heroes_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static client_battle_player_info* default_instance_;
};
// -------------------------------------------------------------------

class client_pvp_battle_camp_data : public ::google::protobuf::Message {
 public:
  client_pvp_battle_camp_data();
  virtual ~client_pvp_battle_camp_data();

  client_pvp_battle_camp_data(const client_pvp_battle_camp_data& from);

  inline client_pvp_battle_camp_data& operator=(const client_pvp_battle_camp_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_pvp_battle_camp_data& default_instance();

  void Swap(client_pvp_battle_camp_data* other);

  // implements Message ----------------------------------------------

  client_pvp_battle_camp_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_pvp_battle_camp_data& from);
  void MergeFrom(const client_pvp_battle_camp_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.client_battle_player_info players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::SProtoSpace::client_battle_player_info& players(int index) const;
  inline ::SProtoSpace::client_battle_player_info* mutable_players(int index);
  inline ::SProtoSpace::client_battle_player_info* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_battle_player_info >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_battle_player_info >*
      mutable_players();

  // required int32 init_power = 2;
  inline bool has_init_power() const;
  inline void clear_init_power();
  static const int kInitPowerFieldNumber = 2;
  inline ::google::protobuf::int32 init_power() const;
  inline void set_init_power(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.client_pvp_battle_camp_data)
 private:
  inline void set_has_init_power();
  inline void clear_has_init_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_battle_player_info > players_;
  ::google::protobuf::int32 init_power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static client_pvp_battle_camp_data* default_instance_;
};
// -------------------------------------------------------------------

class client_pvp_battle_data : public ::google::protobuf::Message {
 public:
  client_pvp_battle_data();
  virtual ~client_pvp_battle_data();

  client_pvp_battle_data(const client_pvp_battle_data& from);

  inline client_pvp_battle_data& operator=(const client_pvp_battle_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_pvp_battle_data& default_instance();

  void Swap(client_pvp_battle_data* other);

  // implements Message ----------------------------------------------

  client_pvp_battle_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_pvp_battle_data& from);
  void MergeFrom(const client_pvp_battle_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.battle_camp_info camps = 1;
  inline int camps_size() const;
  inline void clear_camps();
  static const int kCampsFieldNumber = 1;
  inline const ::SProtoSpace::battle_camp_info& camps(int index) const;
  inline ::SProtoSpace::battle_camp_info* mutable_camps(int index);
  inline ::SProtoSpace::battle_camp_info* add_camps();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >&
      camps() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >*
      mutable_camps();

  // optional .SProtoSpace.running_queue running_data = 2;
  inline bool has_running_data() const;
  inline void clear_running_data();
  static const int kRunningDataFieldNumber = 2;
  inline const ::SProtoSpace::running_queue& running_data() const;
  inline ::SProtoSpace::running_queue* mutable_running_data();
  inline ::SProtoSpace::running_queue* release_running_data();
  inline void set_allocated_running_data(::SProtoSpace::running_queue* running_data);

  // optional int32 round_index = 3;
  inline bool has_round_index() const;
  inline void clear_round_index();
  static const int kRoundIndexFieldNumber = 3;
  inline ::google::protobuf::int32 round_index() const;
  inline void set_round_index(::google::protobuf::int32 value);

  // optional .SProtoSpace.round_op_param opt = 4;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 4;
  inline const ::SProtoSpace::round_op_param& opt() const;
  inline ::SProtoSpace::round_op_param* mutable_opt();
  inline ::SProtoSpace::round_op_param* release_opt();
  inline void set_allocated_opt(::SProtoSpace::round_op_param* opt);

  // optional uint32 seed = 5;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 5;
  inline ::google::protobuf::uint32 seed() const;
  inline void set_seed(::google::protobuf::uint32 value);

  // optional uint32 seed_count = 6;
  inline bool has_seed_count() const;
  inline void clear_seed_count();
  static const int kSeedCountFieldNumber = 6;
  inline ::google::protobuf::uint32 seed_count() const;
  inline void set_seed_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.client_pvp_battle_data)
 private:
  inline void set_has_running_data();
  inline void clear_has_running_data();
  inline void set_has_round_index();
  inline void clear_has_round_index();
  inline void set_has_opt();
  inline void clear_has_opt();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_seed_count();
  inline void clear_has_seed_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info > camps_;
  ::SProtoSpace::running_queue* running_data_;
  ::SProtoSpace::round_op_param* opt_;
  ::google::protobuf::int32 round_index_;
  ::google::protobuf::uint32 seed_;
  ::google::protobuf::uint32 seed_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static client_pvp_battle_data* default_instance_;
};
// -------------------------------------------------------------------

class client_battle_data : public ::google::protobuf::Message {
 public:
  client_battle_data();
  virtual ~client_battle_data();

  client_battle_data(const client_battle_data& from);

  inline client_battle_data& operator=(const client_battle_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_battle_data& default_instance();

  void Swap(client_battle_data* other);

  // implements Message ----------------------------------------------

  client_battle_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_battle_data& from);
  void MergeFrom(const client_battle_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SProtoSpace.EBattleType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SProtoSpace::EBattleType type() const;
  inline void set_type(::SProtoSpace::EBattleType value);

  // optional .SProtoSpace.client_pvp_battle_data pvp_data = 2;
  inline bool has_pvp_data() const;
  inline void clear_pvp_data();
  static const int kPvpDataFieldNumber = 2;
  inline const ::SProtoSpace::client_pvp_battle_data& pvp_data() const;
  inline ::SProtoSpace::client_pvp_battle_data* mutable_pvp_data();
  inline ::SProtoSpace::client_pvp_battle_data* release_pvp_data();
  inline void set_allocated_pvp_data(::SProtoSpace::client_pvp_battle_data* pvp_data);

  // @@protoc_insertion_point(class_scope:SProtoSpace.client_battle_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pvp_data();
  inline void clear_has_pvp_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::client_pvp_battle_data* pvp_data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static client_battle_data* default_instance_;
};
// -------------------------------------------------------------------

class battle_check_opt_data : public ::google::protobuf::Message {
 public:
  battle_check_opt_data();
  virtual ~battle_check_opt_data();

  battle_check_opt_data(const battle_check_opt_data& from);

  inline battle_check_opt_data& operator=(const battle_check_opt_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_check_opt_data& default_instance();

  void Swap(battle_check_opt_data* other);

  // implements Message ----------------------------------------------

  battle_check_opt_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_check_opt_data& from);
  void MergeFrom(const battle_check_opt_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 round_index = 1;
  inline bool has_round_index() const;
  inline void clear_round_index();
  static const int kRoundIndexFieldNumber = 1;
  inline ::google::protobuf::int32 round_index() const;
  inline void set_round_index(::google::protobuf::int32 value);

  // optional .SProtoSpace.round_op_param opt = 2;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 2;
  inline const ::SProtoSpace::round_op_param& opt() const;
  inline ::SProtoSpace::round_op_param* mutable_opt();
  inline ::SProtoSpace::round_op_param* release_opt();
  inline void set_allocated_opt(::SProtoSpace::round_op_param* opt);

  // repeated .SProtoSpace.round_data data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::SProtoSpace::round_data& data(int index) const;
  inline ::SProtoSpace::round_data* mutable_data(int index);
  inline ::SProtoSpace::round_data* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_check_opt_data)
 private:
  inline void set_has_round_index();
  inline void clear_has_round_index();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::round_op_param* opt_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data > data_;
  ::google::protobuf::int32 round_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_check_opt_data* default_instance_;
};
// -------------------------------------------------------------------

class office_end_info : public ::google::protobuf::Message {
 public:
  office_end_info();
  virtual ~office_end_info();

  office_end_info(const office_end_info& from);

  inline office_end_info& operator=(const office_end_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const office_end_info& default_instance();

  void Swap(office_end_info* other);

  // implements Message ----------------------------------------------

  office_end_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const office_end_info& from);
  void MergeFrom(const office_end_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 round_index = 1;
  inline bool has_round_index() const;
  inline void clear_round_index();
  static const int kRoundIndexFieldNumber = 1;
  inline ::google::protobuf::int32 round_index() const;
  inline void set_round_index(::google::protobuf::int32 value);

  // optional .SProtoSpace.round_op_param opt = 2;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 2;
  inline const ::SProtoSpace::round_op_param& opt() const;
  inline ::SProtoSpace::round_op_param* mutable_opt();
  inline ::SProtoSpace::round_op_param* release_opt();
  inline void set_allocated_opt(::SProtoSpace::round_op_param* opt);

  // repeated .SProtoSpace.round_data data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::SProtoSpace::round_data& data(int index) const;
  inline ::SProtoSpace::round_data* mutable_data(int index);
  inline ::SProtoSpace::round_data* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:SProtoSpace.office_end_info)
 private:
  inline void set_has_round_index();
  inline void clear_has_round_index();
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::round_op_param* opt_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data > data_;
  ::google::protobuf::int32 round_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static office_end_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_replay_round_info : public ::google::protobuf::Message {
 public:
  battle_replay_round_info();
  virtual ~battle_replay_round_info();

  battle_replay_round_info(const battle_replay_round_info& from);

  inline battle_replay_round_info& operator=(const battle_replay_round_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_replay_round_info& default_instance();

  void Swap(battle_replay_round_info* other);

  // implements Message ----------------------------------------------

  battle_replay_round_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_replay_round_info& from);
  void MergeFrom(const battle_replay_round_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 round_index = 1;
  inline bool has_round_index() const;
  inline void clear_round_index();
  static const int kRoundIndexFieldNumber = 1;
  inline ::google::protobuf::int32 round_index() const;
  inline void set_round_index(::google::protobuf::int32 value);

  // repeated .SProtoSpace.battle_check_opt_data opts = 2;
  inline int opts_size() const;
  inline void clear_opts();
  static const int kOptsFieldNumber = 2;
  inline const ::SProtoSpace::battle_check_opt_data& opts(int index) const;
  inline ::SProtoSpace::battle_check_opt_data* mutable_opts(int index);
  inline ::SProtoSpace::battle_check_opt_data* add_opts();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >&
      opts() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >*
      mutable_opts();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_replay_round_info)
 private:
  inline void set_has_round_index();
  inline void clear_has_round_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data > opts_;
  ::google::protobuf::int32 round_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_replay_round_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_replay_turn_info : public ::google::protobuf::Message {
 public:
  battle_replay_turn_info();
  virtual ~battle_replay_turn_info();

  battle_replay_turn_info(const battle_replay_turn_info& from);

  inline battle_replay_turn_info& operator=(const battle_replay_turn_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_replay_turn_info& default_instance();

  void Swap(battle_replay_turn_info* other);

  // implements Message ----------------------------------------------

  battle_replay_turn_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_replay_turn_info& from);
  void MergeFrom(const battle_replay_turn_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 turn_index = 1;
  inline bool has_turn_index() const;
  inline void clear_turn_index();
  static const int kTurnIndexFieldNumber = 1;
  inline ::google::protobuf::int32 turn_index() const;
  inline void set_turn_index(::google::protobuf::int32 value);

  // optional .SProtoSpace.pvp_battle_init_data init_data = 2;
  inline bool has_init_data() const;
  inline void clear_init_data();
  static const int kInitDataFieldNumber = 2;
  inline const ::SProtoSpace::pvp_battle_init_data& init_data() const;
  inline ::SProtoSpace::pvp_battle_init_data* mutable_init_data();
  inline ::SProtoSpace::pvp_battle_init_data* release_init_data();
  inline void set_allocated_init_data(::SProtoSpace::pvp_battle_init_data* init_data);

  // repeated .SProtoSpace.battle_replay_round_info opts = 3;
  inline int opts_size() const;
  inline void clear_opts();
  static const int kOptsFieldNumber = 3;
  inline const ::SProtoSpace::battle_replay_round_info& opts(int index) const;
  inline ::SProtoSpace::battle_replay_round_info* mutable_opts(int index);
  inline ::SProtoSpace::battle_replay_round_info* add_opts();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_round_info >&
      opts() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_round_info >*
      mutable_opts();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_replay_turn_info)
 private:
  inline void set_has_turn_index();
  inline void clear_has_turn_index();
  inline void set_has_init_data();
  inline void clear_has_init_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::pvp_battle_init_data* init_data_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_round_info > opts_;
  ::google::protobuf::int32 turn_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_replay_turn_info* default_instance_;
};
// -------------------------------------------------------------------

class battle_replay_info : public ::google::protobuf::Message {
 public:
  battle_replay_info();
  virtual ~battle_replay_info();

  battle_replay_info(const battle_replay_info& from);

  inline battle_replay_info& operator=(const battle_replay_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const battle_replay_info& default_instance();

  void Swap(battle_replay_info* other);

  // implements Message ----------------------------------------------

  battle_replay_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const battle_replay_info& from);
  void MergeFrom(const battle_replay_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.EBattleType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SProtoSpace::EBattleType type() const;
  inline void set_type(::SProtoSpace::EBattleType value);

  // optional uint32 combat_id = 2;
  inline bool has_combat_id() const;
  inline void clear_combat_id();
  static const int kCombatIdFieldNumber = 2;
  inline ::google::protobuf::uint32 combat_id() const;
  inline void set_combat_id(::google::protobuf::uint32 value);

  // optional uint32 seed = 3;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 3;
  inline ::google::protobuf::uint32 seed() const;
  inline void set_seed(::google::protobuf::uint32 value);

  // optional int32 winner_camp = 4;
  inline bool has_winner_camp() const;
  inline void clear_winner_camp();
  static const int kWinnerCampFieldNumber = 4;
  inline ::google::protobuf::int32 winner_camp() const;
  inline void set_winner_camp(::google::protobuf::int32 value);

  // repeated .SProtoSpace.battle_replay_turn_info opts = 5;
  inline int opts_size() const;
  inline void clear_opts();
  static const int kOptsFieldNumber = 5;
  inline const ::SProtoSpace::battle_replay_turn_info& opts(int index) const;
  inline ::SProtoSpace::battle_replay_turn_info* mutable_opts(int index);
  inline ::SProtoSpace::battle_replay_turn_info* add_opts();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_turn_info >&
      opts() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_turn_info >*
      mutable_opts();

  // @@protoc_insertion_point(class_scope:SProtoSpace.battle_replay_info)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_combat_id();
  inline void clear_has_combat_id();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_winner_camp();
  inline void clear_has_winner_camp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 combat_id_;
  ::google::protobuf::uint32 seed_;
  ::google::protobuf::int32 winner_camp_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_turn_info > opts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static battle_replay_info* default_instance_;
};
// -------------------------------------------------------------------

class lsg_position_info : public ::google::protobuf::Message {
 public:
  lsg_position_info();
  virtual ~lsg_position_info();

  lsg_position_info(const lsg_position_info& from);

  inline lsg_position_info& operator=(const lsg_position_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lsg_position_info& default_instance();

  void Swap(lsg_position_info* other);

  // implements Message ----------------------------------------------

  lsg_position_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lsg_position_info& from);
  void MergeFrom(const lsg_position_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional string position_name = 3;
  inline bool has_position_name() const;
  inline void clear_position_name();
  static const int kPositionNameFieldNumber = 3;
  inline const ::std::string& position_name() const;
  inline void set_position_name(const ::std::string& value);
  inline void set_position_name(const char* value);
  inline void set_position_name(const char* value, size_t size);
  inline ::std::string* mutable_position_name();
  inline ::std::string* release_position_name();
  inline void set_allocated_position_name(::std::string* position_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.lsg_position_info)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_position_name();
  inline void clear_has_position_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  ::std::string* position_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static lsg_position_info* default_instance_;
};
// -------------------------------------------------------------------

class comment_info : public ::google::protobuf::Message {
 public:
  comment_info();
  virtual ~comment_info();

  comment_info(const comment_info& from);

  inline comment_info& operator=(const comment_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comment_info& default_instance();

  void Swap(comment_info* other);

  // implements Message ----------------------------------------------

  comment_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comment_info& from);
  void MergeFrom(const comment_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 comment_id = 1;
  inline bool has_comment_id() const;
  inline void clear_comment_id();
  static const int kCommentIdFieldNumber = 1;
  inline ::google::protobuf::uint64 comment_id() const;
  inline void set_comment_id(::google::protobuf::uint64 value);

  // optional uint64 role_id = 2;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 2;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 role_sex = 4;
  inline bool has_role_sex() const;
  inline void clear_role_sex();
  static const int kRoleSexFieldNumber = 4;
  inline ::google::protobuf::int32 role_sex() const;
  inline void set_role_sex(::google::protobuf::int32 value);

  // optional int32 role_border = 5;
  inline bool has_role_border() const;
  inline void clear_role_border();
  static const int kRoleBorderFieldNumber = 5;
  inline ::google::protobuf::int32 role_border() const;
  inline void set_role_border(::google::protobuf::int32 value);

  // optional int32 role_lv = 6;
  inline bool has_role_lv() const;
  inline void clear_role_lv();
  static const int kRoleLvFieldNumber = 6;
  inline ::google::protobuf::int32 role_lv() const;
  inline void set_role_lv(::google::protobuf::int32 value);

  // optional uint64 to_role_id = 7;
  inline bool has_to_role_id() const;
  inline void clear_to_role_id();
  static const int kToRoleIdFieldNumber = 7;
  inline ::google::protobuf::uint64 to_role_id() const;
  inline void set_to_role_id(::google::protobuf::uint64 value);

  // optional string to_role_name = 8;
  inline bool has_to_role_name() const;
  inline void clear_to_role_name();
  static const int kToRoleNameFieldNumber = 8;
  inline const ::std::string& to_role_name() const;
  inline void set_to_role_name(const ::std::string& value);
  inline void set_to_role_name(const char* value);
  inline void set_to_role_name(const char* value, size_t size);
  inline ::std::string* mutable_to_role_name();
  inline ::std::string* release_to_role_name();
  inline void set_allocated_to_role_name(::std::string* to_role_name);

  // optional string comment = 9;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 9;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional uint64 time = 10;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.comment_info)
 private:
  inline void set_has_comment_id();
  inline void clear_has_comment_id();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_sex();
  inline void clear_has_role_sex();
  inline void set_has_role_border();
  inline void clear_has_role_border();
  inline void set_has_role_lv();
  inline void clear_has_role_lv();
  inline void set_has_to_role_id();
  inline void clear_has_to_role_id();
  inline void set_has_to_role_name();
  inline void clear_has_to_role_name();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 comment_id_;
  ::google::protobuf::uint64 role_id_;
  ::std::string* role_name_;
  ::google::protobuf::int32 role_sex_;
  ::google::protobuf::int32 role_border_;
  ::google::protobuf::uint64 to_role_id_;
  ::std::string* to_role_name_;
  ::std::string* comment_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::int32 role_lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static comment_info* default_instance_;
};
// -------------------------------------------------------------------

class comment_all : public ::google::protobuf::Message {
 public:
  comment_all();
  virtual ~comment_all();

  comment_all(const comment_all& from);

  inline comment_all& operator=(const comment_all& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comment_all& default_instance();

  void Swap(comment_all* other);

  // implements Message ----------------------------------------------

  comment_all* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comment_all& from);
  void MergeFrom(const comment_all& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.comment_info comment_list = 1;
  inline int comment_list_size() const;
  inline void clear_comment_list();
  static const int kCommentListFieldNumber = 1;
  inline const ::SProtoSpace::comment_info& comment_list(int index) const;
  inline ::SProtoSpace::comment_info* mutable_comment_list(int index);
  inline ::SProtoSpace::comment_info* add_comment_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::comment_info >&
      comment_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::comment_info >*
      mutable_comment_list();

  // optional int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.comment_all)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::comment_info > comment_list_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static comment_all* default_instance_;
};
// -------------------------------------------------------------------

class date_info : public ::google::protobuf::Message {
 public:
  date_info();
  virtual ~date_info();

  date_info(const date_info& from);

  inline date_info& operator=(const date_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const date_info& default_instance();

  void Swap(date_info* other);

  // implements Message ----------------------------------------------

  date_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const date_info& from);
  void MergeFrom(const date_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 year = 1 [default = 2000];
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 1;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  // optional uint32 month = 2 [default = 1];
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 day = 3 [default = 1];
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.date_info)
 private:
  inline void set_has_year();
  inline void clear_has_year();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_day();
  inline void clear_has_day();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 year_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 day_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static date_info* default_instance_;
};
// -------------------------------------------------------------------

class show_player_base : public ::google::protobuf::Message {
 public:
  show_player_base();
  virtual ~show_player_base();

  show_player_base(const show_player_base& from);

  inline show_player_base& operator=(const show_player_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const show_player_base& default_instance();

  void Swap(show_player_base* other);

  // implements Message ----------------------------------------------

  show_player_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const show_player_base& from);
  void MergeFrom(const show_player_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional uint32 like = 6;
  inline bool has_like() const;
  inline void clear_like();
  static const int kLikeFieldNumber = 6;
  inline ::google::protobuf::uint32 like() const;
  inline void set_like(::google::protobuf::uint32 value);

  // optional uint32 title = 7;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 7;
  inline ::google::protobuf::uint32 title() const;
  inline void set_title(::google::protobuf::uint32 value);

  // optional uint64 partner_id = 8;
  inline bool has_partner_id() const;
  inline void clear_partner_id();
  static const int kPartnerIdFieldNumber = 8;
  inline ::google::protobuf::uint64 partner_id() const;
  inline void set_partner_id(::google::protobuf::uint64 value);

  // optional string partner_name = 9;
  inline bool has_partner_name() const;
  inline void clear_partner_name();
  static const int kPartnerNameFieldNumber = 9;
  inline const ::std::string& partner_name() const;
  inline void set_partner_name(const ::std::string& value);
  inline void set_partner_name(const char* value);
  inline void set_partner_name(const char* value, size_t size);
  inline ::std::string* mutable_partner_name();
  inline ::std::string* release_partner_name();
  inline void set_allocated_partner_name(::std::string* partner_name);

  // optional uint32 office = 10;
  inline bool has_office() const;
  inline void clear_office();
  static const int kOfficeFieldNumber = 10;
  inline ::google::protobuf::uint32 office() const;
  inline void set_office(::google::protobuf::uint32 value);

  // optional uint64 fimily_id = 11;
  inline bool has_fimily_id() const;
  inline void clear_fimily_id();
  static const int kFimilyIdFieldNumber = 11;
  inline ::google::protobuf::uint64 fimily_id() const;
  inline void set_fimily_id(::google::protobuf::uint64 value);

  // optional string fimily_name = 12;
  inline bool has_fimily_name() const;
  inline void clear_fimily_name();
  static const int kFimilyNameFieldNumber = 12;
  inline const ::std::string& fimily_name() const;
  inline void set_fimily_name(const ::std::string& value);
  inline void set_fimily_name(const char* value);
  inline void set_fimily_name(const char* value, size_t size);
  inline ::std::string* mutable_fimily_name();
  inline ::std::string* release_fimily_name();
  inline void set_allocated_fimily_name(::std::string* fimily_name);

  // optional string signature = 13;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 13;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional .SProtoSpace.lsg_position_info position = 14;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 14;
  inline const ::SProtoSpace::lsg_position_info& position() const;
  inline ::SProtoSpace::lsg_position_info* mutable_position();
  inline ::SProtoSpace::lsg_position_info* release_position();
  inline void set_allocated_position(::SProtoSpace::lsg_position_info* position);

  // repeated uint64 liked_list = 16;
  inline int liked_list_size() const;
  inline void clear_liked_list();
  static const int kLikedListFieldNumber = 16;
  inline ::google::protobuf::uint64 liked_list(int index) const;
  inline void set_liked_list(int index, ::google::protobuf::uint64 value);
  inline void add_liked_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      liked_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_liked_list();

  // optional uint32 border = 18;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 18;
  inline ::google::protobuf::uint32 border() const;
  inline void set_border(::google::protobuf::uint32 value);

  // optional .SProtoSpace.date_info birthday = 19;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 19;
  inline const ::SProtoSpace::date_info& birthday() const;
  inline ::SProtoSpace::date_info* mutable_birthday();
  inline ::SProtoSpace::date_info* release_birthday();
  inline void set_allocated_birthday(::SProtoSpace::date_info* birthday);

  // optional uint32 star_sign = 20 [default = 1];
  inline bool has_star_sign() const;
  inline void clear_star_sign();
  static const int kStarSignFieldNumber = 20;
  inline ::google::protobuf::uint32 star_sign() const;
  inline void set_star_sign(::google::protobuf::uint32 value);

  // optional uint32 popularity = 21 [default = 0];
  inline bool has_popularity() const;
  inline void clear_popularity();
  static const int kPopularityFieldNumber = 21;
  inline ::google::protobuf::uint32 popularity() const;
  inline void set_popularity(::google::protobuf::uint32 value);

  // optional uint32 charm = 22 [default = 0];
  inline bool has_charm() const;
  inline void clear_charm();
  static const int kCharmFieldNumber = 22;
  inline ::google::protobuf::uint32 charm() const;
  inline void set_charm(::google::protobuf::uint32 value);

  // repeated uint32 labels = 23;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 23;
  inline ::google::protobuf::uint32 labels(int index) const;
  inline void set_labels(int index, ::google::protobuf::uint32 value);
  inline void add_labels(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      labels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_labels();

  // optional int32 fight_value = 24;
  inline bool has_fight_value() const;
  inline void clear_fight_value();
  static const int kFightValueFieldNumber = 24;
  inline ::google::protobuf::int32 fight_value() const;
  inline void set_fight_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.show_player_base)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_like();
  inline void clear_has_like();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_partner_id();
  inline void clear_has_partner_id();
  inline void set_has_partner_name();
  inline void clear_has_partner_name();
  inline void set_has_office();
  inline void clear_has_office();
  inline void set_has_fimily_id();
  inline void clear_has_fimily_id();
  inline void set_has_fimily_name();
  inline void clear_has_fimily_name();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_border();
  inline void clear_has_border();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_star_sign();
  inline void clear_has_star_sign();
  inline void set_has_popularity();
  inline void clear_has_popularity();
  inline void set_has_charm();
  inline void clear_has_charm();
  inline void set_has_fight_value();
  inline void clear_has_fight_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uuid_;
  ::std::string* name_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::uint32 like_;
  ::google::protobuf::uint32 title_;
  ::google::protobuf::uint64 partner_id_;
  ::std::string* partner_name_;
  ::google::protobuf::uint64 fimily_id_;
  ::std::string* fimily_name_;
  ::std::string* signature_;
  ::google::protobuf::uint32 office_;
  ::google::protobuf::uint32 border_;
  ::SProtoSpace::lsg_position_info* position_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > liked_list_;
  ::SProtoSpace::date_info* birthday_;
  ::google::protobuf::uint32 star_sign_;
  ::google::protobuf::uint32 popularity_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > labels_;
  ::google::protobuf::uint32 charm_;
  ::google::protobuf::int32 fight_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fbattletype_2eproto();
  friend void protobuf_AssignDesc_cm_5fbattletype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fbattletype_2eproto();

  void InitAsDefaultInstance();
  static show_player_base* default_instance_;
};
// ===================================================================


// ===================================================================

// reward_item

// optional int64 uid = 1;
inline bool reward_item::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void reward_item::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void reward_item::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void reward_item::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 reward_item::uid() const {
  return uid_;
}
inline void reward_item::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 tid = 2;
inline bool reward_item::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void reward_item::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void reward_item::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void reward_item::clear_tid() {
  tid_ = 0;
  clear_has_tid();
}
inline ::google::protobuf::int32 reward_item::tid() const {
  return tid_;
}
inline void reward_item::set_tid(::google::protobuf::int32 value) {
  set_has_tid();
  tid_ = value;
}

// optional int32 count = 3;
inline bool reward_item::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void reward_item::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void reward_item::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void reward_item::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 reward_item::count() const {
  return count_;
}
inline void reward_item::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// battle_reward

// optional int32 gold = 1;
inline bool battle_reward::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_reward::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_reward::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_reward::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 battle_reward::gold() const {
  return gold_;
}
inline void battle_reward::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// optional int32 exp = 2;
inline bool battle_reward::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_reward::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_reward::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_reward::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 battle_reward::exp() const {
  return exp_;
}
inline void battle_reward::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 hero_exp = 3;
inline bool battle_reward::has_hero_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_reward::set_has_hero_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_reward::clear_has_hero_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_reward::clear_hero_exp() {
  hero_exp_ = 0;
  clear_has_hero_exp();
}
inline ::google::protobuf::int32 battle_reward::hero_exp() const {
  return hero_exp_;
}
inline void battle_reward::set_hero_exp(::google::protobuf::int32 value) {
  set_has_hero_exp();
  hero_exp_ = value;
}

// optional int32 view_hero_exp = 4;
inline bool battle_reward::has_view_hero_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void battle_reward::set_has_view_hero_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void battle_reward::clear_has_view_hero_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void battle_reward::clear_view_hero_exp() {
  view_hero_exp_ = 0;
  clear_has_view_hero_exp();
}
inline ::google::protobuf::int32 battle_reward::view_hero_exp() const {
  return view_hero_exp_;
}
inline void battle_reward::set_view_hero_exp(::google::protobuf::int32 value) {
  set_has_view_hero_exp();
  view_hero_exp_ = value;
}

// repeated .SProtoSpace.reward_item items = 5;
inline int battle_reward::items_size() const {
  return items_.size();
}
inline void battle_reward::clear_items() {
  items_.Clear();
}
inline const ::SProtoSpace::reward_item& battle_reward::items(int index) const {
  return items_.Get(index);
}
inline ::SProtoSpace::reward_item* battle_reward::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::SProtoSpace::reward_item* battle_reward::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::reward_item >&
battle_reward::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::reward_item >*
battle_reward::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// round_op_skill

// optional uint64 obj_id = 1;
inline bool round_op_skill::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_op_skill::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_op_skill::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_op_skill::clear_obj_id() {
  obj_id_ = GOOGLE_ULONGLONG(0);
  clear_has_obj_id();
}
inline ::google::protobuf::uint64 round_op_skill::obj_id() const {
  return obj_id_;
}
inline void round_op_skill::set_obj_id(::google::protobuf::uint64 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// optional uint64 target_id = 2;
inline bool round_op_skill::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void round_op_skill::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void round_op_skill::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void round_op_skill::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 round_op_skill::target_id() const {
  return target_id_;
}
inline void round_op_skill::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 skill_id = 3;
inline bool round_op_skill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void round_op_skill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void round_op_skill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void round_op_skill::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 round_op_skill::skill_id() const {
  return skill_id_;
}
inline void round_op_skill::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// round_op_param

// optional .SProtoSpace.ERoundOP type = 1;
inline bool round_op_param::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_op_param::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_op_param::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_op_param::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::ERoundOP round_op_param::type() const {
  return static_cast< ::SProtoSpace::ERoundOP >(type_);
}
inline void round_op_param::set_type(::SProtoSpace::ERoundOP value) {
  assert(::SProtoSpace::ERoundOP_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .SProtoSpace.round_op_skill skill = 2;
inline bool round_op_param::has_skill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void round_op_param::set_has_skill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void round_op_param::clear_has_skill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void round_op_param::clear_skill() {
  if (skill_ != NULL) skill_->::SProtoSpace::round_op_skill::Clear();
  clear_has_skill();
}
inline const ::SProtoSpace::round_op_skill& round_op_param::skill() const {
  return skill_ != NULL ? *skill_ : *default_instance_->skill_;
}
inline ::SProtoSpace::round_op_skill* round_op_param::mutable_skill() {
  set_has_skill();
  if (skill_ == NULL) skill_ = new ::SProtoSpace::round_op_skill;
  return skill_;
}
inline ::SProtoSpace::round_op_skill* round_op_param::release_skill() {
  clear_has_skill();
  ::SProtoSpace::round_op_skill* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline void round_op_param::set_allocated_skill(::SProtoSpace::round_op_skill* skill) {
  delete skill_;
  skill_ = skill;
  if (skill) {
    set_has_skill();
  } else {
    clear_has_skill();
  }
}

// -------------------------------------------------------------------

// damage_data

// required uint32 obj_id = 1;
inline bool damage_data::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void damage_data::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void damage_data::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void damage_data::clear_obj_id() {
  obj_id_ = 0u;
  clear_has_obj_id();
}
inline ::google::protobuf::uint32 damage_data::obj_id() const {
  return obj_id_;
}
inline void damage_data::set_obj_id(::google::protobuf::uint32 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// required uint32 damage = 2;
inline bool damage_data::has_damage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void damage_data::set_has_damage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void damage_data::clear_has_damage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void damage_data::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 damage_data::damage() const {
  return damage_;
}
inline void damage_data::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// required uint32 hp = 3;
inline bool damage_data::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void damage_data::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void damage_data::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void damage_data::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 damage_data::hp() const {
  return hp_;
}
inline void damage_data::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required bool critical = 4;
inline bool damage_data::has_critical() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void damage_data::set_has_critical() {
  _has_bits_[0] |= 0x00000008u;
}
inline void damage_data::clear_has_critical() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void damage_data::clear_critical() {
  critical_ = false;
  clear_has_critical();
}
inline bool damage_data::critical() const {
  return critical_;
}
inline void damage_data::set_critical(bool value) {
  set_has_critical();
  critical_ = value;
}

// -------------------------------------------------------------------

// obj_state

// required uint64 obj_id = 1;
inline bool obj_state::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void obj_state::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void obj_state::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void obj_state::clear_obj_id() {
  obj_id_ = GOOGLE_ULONGLONG(0);
  clear_has_obj_id();
}
inline ::google::protobuf::uint64 obj_state::obj_id() const {
  return obj_id_;
}
inline void obj_state::set_obj_id(::google::protobuf::uint64 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// repeated uint32 buff_list = 2;
inline int obj_state::buff_list_size() const {
  return buff_list_.size();
}
inline void obj_state::clear_buff_list() {
  buff_list_.Clear();
}
inline ::google::protobuf::uint32 obj_state::buff_list(int index) const {
  return buff_list_.Get(index);
}
inline void obj_state::set_buff_list(int index, ::google::protobuf::uint32 value) {
  buff_list_.Set(index, value);
}
inline void obj_state::add_buff_list(::google::protobuf::uint32 value) {
  buff_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
obj_state::buff_list() const {
  return buff_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
obj_state::mutable_buff_list() {
  return &buff_list_;
}

// required int32 hp = 3;
inline bool obj_state::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void obj_state::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void obj_state::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void obj_state::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 obj_state::hp() const {
  return hp_;
}
inline void obj_state::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// round_skill_data_damage

// required uint64 obj_id = 1;
inline bool round_skill_data_damage::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_skill_data_damage::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_skill_data_damage::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_skill_data_damage::clear_obj_id() {
  obj_id_ = GOOGLE_ULONGLONG(0);
  clear_has_obj_id();
}
inline ::google::protobuf::uint64 round_skill_data_damage::obj_id() const {
  return obj_id_;
}
inline void round_skill_data_damage::set_obj_id(::google::protobuf::uint64 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// required uint64 target_id = 2;
inline bool round_skill_data_damage::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void round_skill_data_damage::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void round_skill_data_damage::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void round_skill_data_damage::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 round_skill_data_damage::target_id() const {
  return target_id_;
}
inline void round_skill_data_damage::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// required uint32 skill_id = 3;
inline bool round_skill_data_damage::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void round_skill_data_damage::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void round_skill_data_damage::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void round_skill_data_damage::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 round_skill_data_damage::skill_id() const {
  return skill_id_;
}
inline void round_skill_data_damage::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// required uint32 damage = 4;
inline bool round_skill_data_damage::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void round_skill_data_damage::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void round_skill_data_damage::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void round_skill_data_damage::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 round_skill_data_damage::damage() const {
  return damage_;
}
inline void round_skill_data_damage::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// required uint32 hp = 5;
inline bool round_skill_data_damage::has_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void round_skill_data_damage::set_has_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void round_skill_data_damage::clear_has_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void round_skill_data_damage::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 round_skill_data_damage::hp() const {
  return hp_;
}
inline void round_skill_data_damage::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required bool critical = 6;
inline bool round_skill_data_damage::has_critical() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void round_skill_data_damage::set_has_critical() {
  _has_bits_[0] |= 0x00000020u;
}
inline void round_skill_data_damage::clear_has_critical() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void round_skill_data_damage::clear_critical() {
  critical_ = false;
  clear_has_critical();
}
inline bool round_skill_data_damage::critical() const {
  return critical_;
}
inline void round_skill_data_damage::set_critical(bool value) {
  set_has_critical();
  critical_ = value;
}

// -------------------------------------------------------------------

// round_skill_data_cure

// required uint64 obj_id = 1;
inline bool round_skill_data_cure::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_skill_data_cure::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_skill_data_cure::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_skill_data_cure::clear_obj_id() {
  obj_id_ = GOOGLE_ULONGLONG(0);
  clear_has_obj_id();
}
inline ::google::protobuf::uint64 round_skill_data_cure::obj_id() const {
  return obj_id_;
}
inline void round_skill_data_cure::set_obj_id(::google::protobuf::uint64 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// required uint64 target_id = 2;
inline bool round_skill_data_cure::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void round_skill_data_cure::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void round_skill_data_cure::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void round_skill_data_cure::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 round_skill_data_cure::target_id() const {
  return target_id_;
}
inline void round_skill_data_cure::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// required uint32 skill_id = 3;
inline bool round_skill_data_cure::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void round_skill_data_cure::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void round_skill_data_cure::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void round_skill_data_cure::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 round_skill_data_cure::skill_id() const {
  return skill_id_;
}
inline void round_skill_data_cure::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// required uint32 add_hp = 4;
inline bool round_skill_data_cure::has_add_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void round_skill_data_cure::set_has_add_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void round_skill_data_cure::clear_has_add_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void round_skill_data_cure::clear_add_hp() {
  add_hp_ = 0u;
  clear_has_add_hp();
}
inline ::google::protobuf::uint32 round_skill_data_cure::add_hp() const {
  return add_hp_;
}
inline void round_skill_data_cure::set_add_hp(::google::protobuf::uint32 value) {
  set_has_add_hp();
  add_hp_ = value;
}

// required uint32 hp = 5;
inline bool round_skill_data_cure::has_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void round_skill_data_cure::set_has_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void round_skill_data_cure::clear_has_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void round_skill_data_cure::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 round_skill_data_cure::hp() const {
  return hp_;
}
inline void round_skill_data_cure::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required bool critical = 6;
inline bool round_skill_data_cure::has_critical() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void round_skill_data_cure::set_has_critical() {
  _has_bits_[0] |= 0x00000020u;
}
inline void round_skill_data_cure::clear_has_critical() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void round_skill_data_cure::clear_critical() {
  critical_ = false;
  clear_has_critical();
}
inline bool round_skill_data_cure::critical() const {
  return critical_;
}
inline void round_skill_data_cure::set_critical(bool value) {
  set_has_critical();
  critical_ = value;
}

// -------------------------------------------------------------------

// round_buff_data

// optional uint32 buff_tid = 1;
inline bool round_buff_data::has_buff_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_buff_data::set_has_buff_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_buff_data::clear_has_buff_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_buff_data::clear_buff_tid() {
  buff_tid_ = 0u;
  clear_has_buff_tid();
}
inline ::google::protobuf::uint32 round_buff_data::buff_tid() const {
  return buff_tid_;
}
inline void round_buff_data::set_buff_tid(::google::protobuf::uint32 value) {
  set_has_buff_tid();
  buff_tid_ = value;
}

// optional int32 lasttime = 2;
inline bool round_buff_data::has_lasttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void round_buff_data::set_has_lasttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void round_buff_data::clear_has_lasttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void round_buff_data::clear_lasttime() {
  lasttime_ = 0;
  clear_has_lasttime();
}
inline ::google::protobuf::int32 round_buff_data::lasttime() const {
  return lasttime_;
}
inline void round_buff_data::set_lasttime(::google::protobuf::int32 value) {
  set_has_lasttime();
  lasttime_ = value;
}

// optional uint32 buff_uid = 3;
inline bool round_buff_data::has_buff_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void round_buff_data::set_has_buff_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void round_buff_data::clear_has_buff_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void round_buff_data::clear_buff_uid() {
  buff_uid_ = 0u;
  clear_has_buff_uid();
}
inline ::google::protobuf::uint32 round_buff_data::buff_uid() const {
  return buff_uid_;
}
inline void round_buff_data::set_buff_uid(::google::protobuf::uint32 value) {
  set_has_buff_uid();
  buff_uid_ = value;
}

// -------------------------------------------------------------------

// round_state_data

// required uint32 state_flag = 1;
inline bool round_state_data::has_state_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_state_data::set_has_state_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_state_data::clear_has_state_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_state_data::clear_state_flag() {
  state_flag_ = 0u;
  clear_has_state_flag();
}
inline ::google::protobuf::uint32 round_state_data::state_flag() const {
  return state_flag_;
}
inline void round_state_data::set_state_flag(::google::protobuf::uint32 value) {
  set_has_state_flag();
  state_flag_ = value;
}

// -------------------------------------------------------------------

// round_data

// optional uint64 obj_id = 1;
inline bool round_data::has_obj_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void round_data::set_has_obj_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void round_data::clear_has_obj_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void round_data::clear_obj_id() {
  obj_id_ = GOOGLE_ULONGLONG(0);
  clear_has_obj_id();
}
inline ::google::protobuf::uint64 round_data::obj_id() const {
  return obj_id_;
}
inline void round_data::set_obj_id(::google::protobuf::uint64 value) {
  set_has_obj_id();
  obj_id_ = value;
}

// repeated .SProtoSpace.round_buff_data buff_data = 2;
inline int round_data::buff_data_size() const {
  return buff_data_.size();
}
inline void round_data::clear_buff_data() {
  buff_data_.Clear();
}
inline const ::SProtoSpace::round_buff_data& round_data::buff_data(int index) const {
  return buff_data_.Get(index);
}
inline ::SProtoSpace::round_buff_data* round_data::mutable_buff_data(int index) {
  return buff_data_.Mutable(index);
}
inline ::SProtoSpace::round_buff_data* round_data::add_buff_data() {
  return buff_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_buff_data >&
round_data::buff_data() const {
  return buff_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_buff_data >*
round_data::mutable_buff_data() {
  return &buff_data_;
}

// optional .SProtoSpace.round_state_data state_data = 3;
inline bool round_data::has_state_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void round_data::set_has_state_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void round_data::clear_has_state_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void round_data::clear_state_data() {
  if (state_data_ != NULL) state_data_->::SProtoSpace::round_state_data::Clear();
  clear_has_state_data();
}
inline const ::SProtoSpace::round_state_data& round_data::state_data() const {
  return state_data_ != NULL ? *state_data_ : *default_instance_->state_data_;
}
inline ::SProtoSpace::round_state_data* round_data::mutable_state_data() {
  set_has_state_data();
  if (state_data_ == NULL) state_data_ = new ::SProtoSpace::round_state_data;
  return state_data_;
}
inline ::SProtoSpace::round_state_data* round_data::release_state_data() {
  clear_has_state_data();
  ::SProtoSpace::round_state_data* temp = state_data_;
  state_data_ = NULL;
  return temp;
}
inline void round_data::set_allocated_state_data(::SProtoSpace::round_state_data* state_data) {
  delete state_data_;
  state_data_ = state_data;
  if (state_data) {
    set_has_state_data();
  } else {
    clear_has_state_data();
  }
}

// optional int32 hp = 4;
inline bool round_data::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void round_data::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void round_data::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void round_data::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 round_data::hp() const {
  return hp_;
}
inline void round_data::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 camp = 5;
inline bool round_data::has_camp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void round_data::set_has_camp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void round_data::clear_has_camp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void round_data::clear_camp() {
  camp_ = 0;
  clear_has_camp();
}
inline ::google::protobuf::int32 round_data::camp() const {
  return camp_;
}
inline void round_data::set_camp(::google::protobuf::int32 value) {
  set_has_camp();
  camp_ = value;
}

// optional int32 maxhp = 6;
inline bool round_data::has_maxhp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void round_data::set_has_maxhp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void round_data::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void round_data::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 round_data::maxhp() const {
  return maxhp_;
}
inline void round_data::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// optional int32 sp = 7;
inline bool round_data::has_sp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void round_data::set_has_sp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void round_data::clear_has_sp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void round_data::clear_sp() {
  sp_ = 0;
  clear_has_sp();
}
inline ::google::protobuf::int32 round_data::sp() const {
  return sp_;
}
inline void round_data::set_sp(::google::protobuf::int32 value) {
  set_has_sp();
  sp_ = value;
}

// -------------------------------------------------------------------

// seq_useskill

// optional uint64 cast_id = 1;
inline bool seq_useskill::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_useskill::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_useskill::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_useskill::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_useskill::cast_id() const {
  return cast_id_;
}
inline void seq_useskill::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_useskill::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_useskill::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_useskill::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_useskill::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_useskill::target_id() const {
  return target_id_;
}
inline void seq_useskill::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 skill_id = 3;
inline bool seq_useskill::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_useskill::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_useskill::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_useskill::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 seq_useskill::skill_id() const {
  return skill_id_;
}
inline void seq_useskill::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// seq_buff

// optional uint64 cast_id = 1;
inline bool seq_buff::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_buff::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_buff::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_buff::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_buff::cast_id() const {
  return cast_id_;
}
inline void seq_buff::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_buff::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_buff::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_buff::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_buff::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_buff::target_id() const {
  return target_id_;
}
inline void seq_buff::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 buff_uid = 3;
inline bool seq_buff::has_buff_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_buff::set_has_buff_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_buff::clear_has_buff_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_buff::clear_buff_uid() {
  buff_uid_ = 0u;
  clear_has_buff_uid();
}
inline ::google::protobuf::uint32 seq_buff::buff_uid() const {
  return buff_uid_;
}
inline void seq_buff::set_buff_uid(::google::protobuf::uint32 value) {
  set_has_buff_uid();
  buff_uid_ = value;
}

// optional uint32 buff_tid = 4;
inline bool seq_buff::has_buff_tid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void seq_buff::set_has_buff_tid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void seq_buff::clear_has_buff_tid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void seq_buff::clear_buff_tid() {
  buff_tid_ = 0u;
  clear_has_buff_tid();
}
inline ::google::protobuf::uint32 seq_buff::buff_tid() const {
  return buff_tid_;
}
inline void seq_buff::set_buff_tid(::google::protobuf::uint32 value) {
  set_has_buff_tid();
  buff_tid_ = value;
}

// optional uint32 last_round = 5;
inline bool seq_buff::has_last_round() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void seq_buff::set_has_last_round() {
  _has_bits_[0] |= 0x00000010u;
}
inline void seq_buff::clear_has_last_round() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void seq_buff::clear_last_round() {
  last_round_ = 0u;
  clear_has_last_round();
}
inline ::google::protobuf::uint32 seq_buff::last_round() const {
  return last_round_;
}
inline void seq_buff::set_last_round(::google::protobuf::uint32 value) {
  set_has_last_round();
  last_round_ = value;
}

// -------------------------------------------------------------------

// seq_state

// optional uint64 cast_id = 1;
inline bool seq_state::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_state::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_state::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_state::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_state::cast_id() const {
  return cast_id_;
}
inline void seq_state::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_state::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_state::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_state::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_state::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_state::target_id() const {
  return target_id_;
}
inline void seq_state::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 state_index = 3;
inline bool seq_state::has_state_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_state::set_has_state_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_state::clear_has_state_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_state::clear_state_index() {
  state_index_ = 0u;
  clear_has_state_index();
}
inline ::google::protobuf::uint32 seq_state::state_index() const {
  return state_index_;
}
inline void seq_state::set_state_index(::google::protobuf::uint32 value) {
  set_has_state_index();
  state_index_ = value;
}

// -------------------------------------------------------------------

// seq_damage

// optional uint64 cast_id = 1;
inline bool seq_damage::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_damage::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_damage::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_damage::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_damage::cast_id() const {
  return cast_id_;
}
inline void seq_damage::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_damage::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_damage::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_damage::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_damage::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_damage::target_id() const {
  return target_id_;
}
inline void seq_damage::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional bool dodge = 3;
inline bool seq_damage::has_dodge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_damage::set_has_dodge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_damage::clear_has_dodge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_damage::clear_dodge() {
  dodge_ = false;
  clear_has_dodge();
}
inline bool seq_damage::dodge() const {
  return dodge_;
}
inline void seq_damage::set_dodge(bool value) {
  set_has_dodge();
  dodge_ = value;
}

// optional uint32 damage = 4;
inline bool seq_damage::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void seq_damage::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void seq_damage::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void seq_damage::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 seq_damage::damage() const {
  return damage_;
}
inline void seq_damage::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// optional uint32 hp = 5;
inline bool seq_damage::has_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void seq_damage::set_has_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void seq_damage::clear_has_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void seq_damage::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 seq_damage::hp() const {
  return hp_;
}
inline void seq_damage::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// optional bool critical = 6;
inline bool seq_damage::has_critical() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void seq_damage::set_has_critical() {
  _has_bits_[0] |= 0x00000020u;
}
inline void seq_damage::clear_has_critical() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void seq_damage::clear_critical() {
  critical_ = false;
  clear_has_critical();
}
inline bool seq_damage::critical() const {
  return critical_;
}
inline void seq_damage::set_critical(bool value) {
  set_has_critical();
  critical_ = value;
}

// optional uint32 buff_id = 7 [default = 0];
inline bool seq_damage::has_buff_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void seq_damage::set_has_buff_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void seq_damage::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void seq_damage::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 seq_damage::buff_id() const {
  return buff_id_;
}
inline void seq_damage::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// -------------------------------------------------------------------

// seq_relive

// optional uint64 cast_id = 1;
inline bool seq_relive::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_relive::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_relive::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_relive::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_relive::cast_id() const {
  return cast_id_;
}
inline void seq_relive::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_relive::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_relive::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_relive::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_relive::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_relive::target_id() const {
  return target_id_;
}
inline void seq_relive::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 skill_id = 3;
inline bool seq_relive::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_relive::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_relive::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_relive::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 seq_relive::skill_id() const {
  return skill_id_;
}
inline void seq_relive::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 hp = 4;
inline bool seq_relive::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void seq_relive::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void seq_relive::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void seq_relive::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 seq_relive::hp() const {
  return hp_;
}
inline void seq_relive::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// seq_attr

// optional uint64 cast_id = 1;
inline bool seq_attr::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_attr::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_attr::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_attr::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_attr::cast_id() const {
  return cast_id_;
}
inline void seq_attr::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint32 attr = 2;
inline bool seq_attr::has_attr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_attr::set_has_attr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_attr::clear_has_attr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_attr::clear_attr() {
  attr_ = 0u;
  clear_has_attr();
}
inline ::google::protobuf::uint32 seq_attr::attr() const {
  return attr_;
}
inline void seq_attr::set_attr(::google::protobuf::uint32 value) {
  set_has_attr();
  attr_ = value;
}

// optional int32 change_attr = 3;
inline bool seq_attr::has_change_attr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_attr::set_has_change_attr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_attr::clear_has_change_attr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_attr::clear_change_attr() {
  change_attr_ = 0;
  clear_has_change_attr();
}
inline ::google::protobuf::int32 seq_attr::change_attr() const {
  return change_attr_;
}
inline void seq_attr::set_change_attr(::google::protobuf::int32 value) {
  set_has_change_attr();
  change_attr_ = value;
}

// optional int32 val = 4;
inline bool seq_attr::has_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void seq_attr::set_has_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void seq_attr::clear_has_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void seq_attr::clear_val() {
  val_ = 0;
  clear_has_val();
}
inline ::google::protobuf::int32 seq_attr::val() const {
  return val_;
}
inline void seq_attr::set_val(::google::protobuf::int32 value) {
  set_has_val();
  val_ = value;
}

// -------------------------------------------------------------------

// seq_extra_action

// optional uint64 cast_id = 1;
inline bool seq_extra_action::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_extra_action::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_extra_action::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_extra_action::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_extra_action::cast_id() const {
  return cast_id_;
}
inline void seq_extra_action::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint64 target_id = 2;
inline bool seq_extra_action::has_target_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_extra_action::set_has_target_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_extra_action::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_extra_action::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 seq_extra_action::target_id() const {
  return target_id_;
}
inline void seq_extra_action::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 skill_id = 3;
inline bool seq_extra_action::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_extra_action::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_extra_action::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_extra_action::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 seq_extra_action::skill_id() const {
  return skill_id_;
}
inline void seq_extra_action::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// -------------------------------------------------------------------

// seq_sp

// optional uint64 cast_id = 1;
inline bool seq_sp::has_cast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void seq_sp::set_has_cast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void seq_sp::clear_has_cast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void seq_sp::clear_cast_id() {
  cast_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cast_id();
}
inline ::google::protobuf::uint64 seq_sp::cast_id() const {
  return cast_id_;
}
inline void seq_sp::set_cast_id(::google::protobuf::uint64 value) {
  set_has_cast_id();
  cast_id_ = value;
}

// optional uint32 change_sp = 2;
inline bool seq_sp::has_change_sp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void seq_sp::set_has_change_sp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void seq_sp::clear_has_change_sp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void seq_sp::clear_change_sp() {
  change_sp_ = 0u;
  clear_has_change_sp();
}
inline ::google::protobuf::uint32 seq_sp::change_sp() const {
  return change_sp_;
}
inline void seq_sp::set_change_sp(::google::protobuf::uint32 value) {
  set_has_change_sp();
  change_sp_ = value;
}

// optional uint32 sp = 3;
inline bool seq_sp::has_sp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void seq_sp::set_has_sp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void seq_sp::clear_has_sp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void seq_sp::clear_sp() {
  sp_ = 0u;
  clear_has_sp();
}
inline ::google::protobuf::uint32 seq_sp::sp() const {
  return sp_;
}
inline void seq_sp::set_sp(::google::protobuf::uint32 value) {
  set_has_sp();
  sp_ = value;
}

// optional uint32 max_sp = 4;
inline bool seq_sp::has_max_sp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void seq_sp::set_has_max_sp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void seq_sp::clear_has_max_sp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void seq_sp::clear_max_sp() {
  max_sp_ = 0u;
  clear_has_max_sp();
}
inline ::google::protobuf::uint32 seq_sp::max_sp() const {
  return max_sp_;
}
inline void seq_sp::set_max_sp(::google::protobuf::uint32 value) {
  set_has_max_sp();
  max_sp_ = value;
}

// -------------------------------------------------------------------

// opt_seq

// optional .SProtoSpace.ESeqOptType opt_type = 1;
inline bool opt_seq::has_opt_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void opt_seq::set_has_opt_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void opt_seq::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void opt_seq::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::SProtoSpace::ESeqOptType opt_seq::opt_type() const {
  return static_cast< ::SProtoSpace::ESeqOptType >(opt_type_);
}
inline void opt_seq::set_opt_type(::SProtoSpace::ESeqOptType value) {
  assert(::SProtoSpace::ESeqOptType_IsValid(value));
  set_has_opt_type();
  opt_type_ = value;
}

// optional .SProtoSpace.seq_buff buff = 2;
inline bool opt_seq::has_buff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void opt_seq::set_has_buff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void opt_seq::clear_has_buff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void opt_seq::clear_buff() {
  if (buff_ != NULL) buff_->::SProtoSpace::seq_buff::Clear();
  clear_has_buff();
}
inline const ::SProtoSpace::seq_buff& opt_seq::buff() const {
  return buff_ != NULL ? *buff_ : *default_instance_->buff_;
}
inline ::SProtoSpace::seq_buff* opt_seq::mutable_buff() {
  set_has_buff();
  if (buff_ == NULL) buff_ = new ::SProtoSpace::seq_buff;
  return buff_;
}
inline ::SProtoSpace::seq_buff* opt_seq::release_buff() {
  clear_has_buff();
  ::SProtoSpace::seq_buff* temp = buff_;
  buff_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_buff(::SProtoSpace::seq_buff* buff) {
  delete buff_;
  buff_ = buff;
  if (buff) {
    set_has_buff();
  } else {
    clear_has_buff();
  }
}

// optional .SProtoSpace.seq_state state = 3;
inline bool opt_seq::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void opt_seq::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void opt_seq::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void opt_seq::clear_state() {
  if (state_ != NULL) state_->::SProtoSpace::seq_state::Clear();
  clear_has_state();
}
inline const ::SProtoSpace::seq_state& opt_seq::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::SProtoSpace::seq_state* opt_seq::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::SProtoSpace::seq_state;
  return state_;
}
inline ::SProtoSpace::seq_state* opt_seq::release_state() {
  clear_has_state();
  ::SProtoSpace::seq_state* temp = state_;
  state_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_state(::SProtoSpace::seq_state* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .SProtoSpace.seq_damage damage = 4;
inline bool opt_seq::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void opt_seq::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void opt_seq::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void opt_seq::clear_damage() {
  if (damage_ != NULL) damage_->::SProtoSpace::seq_damage::Clear();
  clear_has_damage();
}
inline const ::SProtoSpace::seq_damage& opt_seq::damage() const {
  return damage_ != NULL ? *damage_ : *default_instance_->damage_;
}
inline ::SProtoSpace::seq_damage* opt_seq::mutable_damage() {
  set_has_damage();
  if (damage_ == NULL) damage_ = new ::SProtoSpace::seq_damage;
  return damage_;
}
inline ::SProtoSpace::seq_damage* opt_seq::release_damage() {
  clear_has_damage();
  ::SProtoSpace::seq_damage* temp = damage_;
  damage_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_damage(::SProtoSpace::seq_damage* damage) {
  delete damage_;
  damage_ = damage;
  if (damage) {
    set_has_damage();
  } else {
    clear_has_damage();
  }
}

// optional .SProtoSpace.seq_relive relive = 5;
inline bool opt_seq::has_relive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void opt_seq::set_has_relive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void opt_seq::clear_has_relive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void opt_seq::clear_relive() {
  if (relive_ != NULL) relive_->::SProtoSpace::seq_relive::Clear();
  clear_has_relive();
}
inline const ::SProtoSpace::seq_relive& opt_seq::relive() const {
  return relive_ != NULL ? *relive_ : *default_instance_->relive_;
}
inline ::SProtoSpace::seq_relive* opt_seq::mutable_relive() {
  set_has_relive();
  if (relive_ == NULL) relive_ = new ::SProtoSpace::seq_relive;
  return relive_;
}
inline ::SProtoSpace::seq_relive* opt_seq::release_relive() {
  clear_has_relive();
  ::SProtoSpace::seq_relive* temp = relive_;
  relive_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_relive(::SProtoSpace::seq_relive* relive) {
  delete relive_;
  relive_ = relive;
  if (relive) {
    set_has_relive();
  } else {
    clear_has_relive();
  }
}

// optional .SProtoSpace.seq_attr attr = 6;
inline bool opt_seq::has_attr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void opt_seq::set_has_attr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void opt_seq::clear_has_attr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void opt_seq::clear_attr() {
  if (attr_ != NULL) attr_->::SProtoSpace::seq_attr::Clear();
  clear_has_attr();
}
inline const ::SProtoSpace::seq_attr& opt_seq::attr() const {
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
}
inline ::SProtoSpace::seq_attr* opt_seq::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::SProtoSpace::seq_attr;
  return attr_;
}
inline ::SProtoSpace::seq_attr* opt_seq::release_attr() {
  clear_has_attr();
  ::SProtoSpace::seq_attr* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_attr(::SProtoSpace::seq_attr* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
}

// optional .SProtoSpace.seq_extra_action extra_action = 7;
inline bool opt_seq::has_extra_action() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void opt_seq::set_has_extra_action() {
  _has_bits_[0] |= 0x00000040u;
}
inline void opt_seq::clear_has_extra_action() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void opt_seq::clear_extra_action() {
  if (extra_action_ != NULL) extra_action_->::SProtoSpace::seq_extra_action::Clear();
  clear_has_extra_action();
}
inline const ::SProtoSpace::seq_extra_action& opt_seq::extra_action() const {
  return extra_action_ != NULL ? *extra_action_ : *default_instance_->extra_action_;
}
inline ::SProtoSpace::seq_extra_action* opt_seq::mutable_extra_action() {
  set_has_extra_action();
  if (extra_action_ == NULL) extra_action_ = new ::SProtoSpace::seq_extra_action;
  return extra_action_;
}
inline ::SProtoSpace::seq_extra_action* opt_seq::release_extra_action() {
  clear_has_extra_action();
  ::SProtoSpace::seq_extra_action* temp = extra_action_;
  extra_action_ = NULL;
  return temp;
}
inline void opt_seq::set_allocated_extra_action(::SProtoSpace::seq_extra_action* extra_action) {
  delete extra_action_;
  extra_action_ = extra_action;
  if (extra_action) {
    set_has_extra_action();
  } else {
    clear_has_extra_action();
  }
}

// -------------------------------------------------------------------

// hit_seq

// optional .SProtoSpace.EOptSeqTimeLine time_type = 1;
inline bool hit_seq::has_time_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hit_seq::set_has_time_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hit_seq::clear_has_time_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hit_seq::clear_time_type() {
  time_type_ = 1;
  clear_has_time_type();
}
inline ::SProtoSpace::EOptSeqTimeLine hit_seq::time_type() const {
  return static_cast< ::SProtoSpace::EOptSeqTimeLine >(time_type_);
}
inline void hit_seq::set_time_type(::SProtoSpace::EOptSeqTimeLine value) {
  assert(::SProtoSpace::EOptSeqTimeLine_IsValid(value));
  set_has_time_type();
  time_type_ = value;
}

// optional uint32 hit_index = 2;
inline bool hit_seq::has_hit_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hit_seq::set_has_hit_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hit_seq::clear_has_hit_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hit_seq::clear_hit_index() {
  hit_index_ = 0u;
  clear_has_hit_index();
}
inline ::google::protobuf::uint32 hit_seq::hit_index() const {
  return hit_index_;
}
inline void hit_seq::set_hit_index(::google::protobuf::uint32 value) {
  set_has_hit_index();
  hit_index_ = value;
}

// repeated .SProtoSpace.opt_seq seqs = 3;
inline int hit_seq::seqs_size() const {
  return seqs_.size();
}
inline void hit_seq::clear_seqs() {
  seqs_.Clear();
}
inline const ::SProtoSpace::opt_seq& hit_seq::seqs(int index) const {
  return seqs_.Get(index);
}
inline ::SProtoSpace::opt_seq* hit_seq::mutable_seqs(int index) {
  return seqs_.Mutable(index);
}
inline ::SProtoSpace::opt_seq* hit_seq::add_seqs() {
  return seqs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::opt_seq >&
hit_seq::seqs() const {
  return seqs_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::opt_seq >*
hit_seq::mutable_seqs() {
  return &seqs_;
}

// -------------------------------------------------------------------

// opt_seqs

// optional .SProtoSpace.round_op_param opt = 1;
inline bool opt_seqs::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void opt_seqs::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void opt_seqs::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void opt_seqs::clear_opt() {
  if (opt_ != NULL) opt_->::SProtoSpace::round_op_param::Clear();
  clear_has_opt();
}
inline const ::SProtoSpace::round_op_param& opt_seqs::opt() const {
  return opt_ != NULL ? *opt_ : *default_instance_->opt_;
}
inline ::SProtoSpace::round_op_param* opt_seqs::mutable_opt() {
  set_has_opt();
  if (opt_ == NULL) opt_ = new ::SProtoSpace::round_op_param;
  return opt_;
}
inline ::SProtoSpace::round_op_param* opt_seqs::release_opt() {
  clear_has_opt();
  ::SProtoSpace::round_op_param* temp = opt_;
  opt_ = NULL;
  return temp;
}
inline void opt_seqs::set_allocated_opt(::SProtoSpace::round_op_param* opt) {
  delete opt_;
  opt_ = opt;
  if (opt) {
    set_has_opt();
  } else {
    clear_has_opt();
  }
}

// repeated .SProtoSpace.hit_seq seqs = 2;
inline int opt_seqs::seqs_size() const {
  return seqs_.size();
}
inline void opt_seqs::clear_seqs() {
  seqs_.Clear();
}
inline const ::SProtoSpace::hit_seq& opt_seqs::seqs(int index) const {
  return seqs_.Get(index);
}
inline ::SProtoSpace::hit_seq* opt_seqs::mutable_seqs(int index) {
  return seqs_.Mutable(index);
}
inline ::SProtoSpace::hit_seq* opt_seqs::add_seqs() {
  return seqs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hit_seq >&
opt_seqs::seqs() const {
  return seqs_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hit_seq >*
opt_seqs::mutable_seqs() {
  return &seqs_;
}

// -------------------------------------------------------------------

// battle_hero_info

// optional .SProtoSpace.hero_base_info base = 1;
inline bool battle_hero_info::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_hero_info::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_hero_info::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_hero_info::clear_base() {
  if (base_ != NULL) base_->::SProtoSpace::hero_base_info::Clear();
  clear_has_base();
}
inline const ::SProtoSpace::hero_base_info& battle_hero_info::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::SProtoSpace::hero_base_info* battle_hero_info::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::SProtoSpace::hero_base_info;
  return base_;
}
inline ::SProtoSpace::hero_base_info* battle_hero_info::release_base() {
  clear_has_base();
  ::SProtoSpace::hero_base_info* temp = base_;
  base_ = NULL;
  return temp;
}
inline void battle_hero_info::set_allocated_base(::SProtoSpace::hero_base_info* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .SProtoSpace.hero_attr_value base_attr = 2;
inline int battle_hero_info::base_attr_size() const {
  return base_attr_.size();
}
inline void battle_hero_info::clear_base_attr() {
  base_attr_.Clear();
}
inline const ::SProtoSpace::hero_attr_value& battle_hero_info::base_attr(int index) const {
  return base_attr_.Get(index);
}
inline ::SProtoSpace::hero_attr_value* battle_hero_info::mutable_base_attr(int index) {
  return base_attr_.Mutable(index);
}
inline ::SProtoSpace::hero_attr_value* battle_hero_info::add_base_attr() {
  return base_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
battle_hero_info::base_attr() const {
  return base_attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
battle_hero_info::mutable_base_attr() {
  return &base_attr_;
}

// repeated .SProtoSpace.client_skill_data skill_data = 3;
inline int battle_hero_info::skill_data_size() const {
  return skill_data_.size();
}
inline void battle_hero_info::clear_skill_data() {
  skill_data_.Clear();
}
inline const ::SProtoSpace::client_skill_data& battle_hero_info::skill_data(int index) const {
  return skill_data_.Get(index);
}
inline ::SProtoSpace::client_skill_data* battle_hero_info::mutable_skill_data(int index) {
  return skill_data_.Mutable(index);
}
inline ::SProtoSpace::client_skill_data* battle_hero_info::add_skill_data() {
  return skill_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >&
battle_hero_info::skill_data() const {
  return skill_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >*
battle_hero_info::mutable_skill_data() {
  return &skill_data_;
}

// optional .SProtoSpace.round_data rd_data = 4;
inline bool battle_hero_info::has_rd_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void battle_hero_info::set_has_rd_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void battle_hero_info::clear_has_rd_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void battle_hero_info::clear_rd_data() {
  if (rd_data_ != NULL) rd_data_->::SProtoSpace::round_data::Clear();
  clear_has_rd_data();
}
inline const ::SProtoSpace::round_data& battle_hero_info::rd_data() const {
  return rd_data_ != NULL ? *rd_data_ : *default_instance_->rd_data_;
}
inline ::SProtoSpace::round_data* battle_hero_info::mutable_rd_data() {
  set_has_rd_data();
  if (rd_data_ == NULL) rd_data_ = new ::SProtoSpace::round_data;
  return rd_data_;
}
inline ::SProtoSpace::round_data* battle_hero_info::release_rd_data() {
  clear_has_rd_data();
  ::SProtoSpace::round_data* temp = rd_data_;
  rd_data_ = NULL;
  return temp;
}
inline void battle_hero_info::set_allocated_rd_data(::SProtoSpace::round_data* rd_data) {
  delete rd_data_;
  rd_data_ = rd_data;
  if (rd_data) {
    set_has_rd_data();
  } else {
    clear_has_rd_data();
  }
}

// repeated .SProtoSpace.hero_attr_value total_attr = 5;
inline int battle_hero_info::total_attr_size() const {
  return total_attr_.size();
}
inline void battle_hero_info::clear_total_attr() {
  total_attr_.Clear();
}
inline const ::SProtoSpace::hero_attr_value& battle_hero_info::total_attr(int index) const {
  return total_attr_.Get(index);
}
inline ::SProtoSpace::hero_attr_value* battle_hero_info::mutable_total_attr(int index) {
  return total_attr_.Mutable(index);
}
inline ::SProtoSpace::hero_attr_value* battle_hero_info::add_total_attr() {
  return total_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
battle_hero_info::total_attr() const {
  return total_attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
battle_hero_info::mutable_total_attr() {
  return &total_attr_;
}

// optional int32 formation_index = 6;
inline bool battle_hero_info::has_formation_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void battle_hero_info::set_has_formation_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void battle_hero_info::clear_has_formation_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void battle_hero_info::clear_formation_index() {
  formation_index_ = 0;
  clear_has_formation_index();
}
inline ::google::protobuf::int32 battle_hero_info::formation_index() const {
  return formation_index_;
}
inline void battle_hero_info::set_formation_index(::google::protobuf::int32 value) {
  set_has_formation_index();
  formation_index_ = value;
}

// optional int32 create_type = 7;
inline bool battle_hero_info::has_create_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void battle_hero_info::set_has_create_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void battle_hero_info::clear_has_create_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void battle_hero_info::clear_create_type() {
  create_type_ = 0;
  clear_has_create_type();
}
inline ::google::protobuf::int32 battle_hero_info::create_type() const {
  return create_type_;
}
inline void battle_hero_info::set_create_type(::google::protobuf::int32 value) {
  set_has_create_type();
  create_type_ = value;
}

// -------------------------------------------------------------------

// battle_player_base_info

// optional uint64 id = 1;
inline bool battle_player_base_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_player_base_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_player_base_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_player_base_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 battle_player_base_info::id() const {
  return id_;
}
inline void battle_player_base_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 template_id = 2;
inline bool battle_player_base_info::has_template_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_player_base_info::set_has_template_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_player_base_info::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_player_base_info::clear_template_id() {
  template_id_ = 0u;
  clear_has_template_id();
}
inline ::google::protobuf::uint32 battle_player_base_info::template_id() const {
  return template_id_;
}
inline void battle_player_base_info::set_template_id(::google::protobuf::uint32 value) {
  set_has_template_id();
  template_id_ = value;
}

// optional int32 level = 3;
inline bool battle_player_base_info::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_player_base_info::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_player_base_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_player_base_info::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 battle_player_base_info::level() const {
  return level_;
}
inline void battle_player_base_info::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// battle_player_info

// optional .SProtoSpace.battle_player_base_info base = 1;
inline bool battle_player_info::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_player_info::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_player_info::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_player_info::clear_base() {
  if (base_ != NULL) base_->::SProtoSpace::battle_player_base_info::Clear();
  clear_has_base();
}
inline const ::SProtoSpace::battle_player_base_info& battle_player_info::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::SProtoSpace::battle_player_base_info* battle_player_info::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::SProtoSpace::battle_player_base_info;
  return base_;
}
inline ::SProtoSpace::battle_player_base_info* battle_player_info::release_base() {
  clear_has_base();
  ::SProtoSpace::battle_player_base_info* temp = base_;
  base_ = NULL;
  return temp;
}
inline void battle_player_info::set_allocated_base(::SProtoSpace::battle_player_base_info* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// repeated .SProtoSpace.hero_attr_value base_attr = 2;
inline int battle_player_info::base_attr_size() const {
  return base_attr_.size();
}
inline void battle_player_info::clear_base_attr() {
  base_attr_.Clear();
}
inline const ::SProtoSpace::hero_attr_value& battle_player_info::base_attr(int index) const {
  return base_attr_.Get(index);
}
inline ::SProtoSpace::hero_attr_value* battle_player_info::mutable_base_attr(int index) {
  return base_attr_.Mutable(index);
}
inline ::SProtoSpace::hero_attr_value* battle_player_info::add_base_attr() {
  return base_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
battle_player_info::base_attr() const {
  return base_attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
battle_player_info::mutable_base_attr() {
  return &base_attr_;
}

// repeated .SProtoSpace.client_skill_data skill_data = 3;
inline int battle_player_info::skill_data_size() const {
  return skill_data_.size();
}
inline void battle_player_info::clear_skill_data() {
  skill_data_.Clear();
}
inline const ::SProtoSpace::client_skill_data& battle_player_info::skill_data(int index) const {
  return skill_data_.Get(index);
}
inline ::SProtoSpace::client_skill_data* battle_player_info::mutable_skill_data(int index) {
  return skill_data_.Mutable(index);
}
inline ::SProtoSpace::client_skill_data* battle_player_info::add_skill_data() {
  return skill_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >&
battle_player_info::skill_data() const {
  return skill_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_skill_data >*
battle_player_info::mutable_skill_data() {
  return &skill_data_;
}

// optional .SProtoSpace.round_data rd_data = 4;
inline bool battle_player_info::has_rd_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void battle_player_info::set_has_rd_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void battle_player_info::clear_has_rd_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void battle_player_info::clear_rd_data() {
  if (rd_data_ != NULL) rd_data_->::SProtoSpace::round_data::Clear();
  clear_has_rd_data();
}
inline const ::SProtoSpace::round_data& battle_player_info::rd_data() const {
  return rd_data_ != NULL ? *rd_data_ : *default_instance_->rd_data_;
}
inline ::SProtoSpace::round_data* battle_player_info::mutable_rd_data() {
  set_has_rd_data();
  if (rd_data_ == NULL) rd_data_ = new ::SProtoSpace::round_data;
  return rd_data_;
}
inline ::SProtoSpace::round_data* battle_player_info::release_rd_data() {
  clear_has_rd_data();
  ::SProtoSpace::round_data* temp = rd_data_;
  rd_data_ = NULL;
  return temp;
}
inline void battle_player_info::set_allocated_rd_data(::SProtoSpace::round_data* rd_data) {
  delete rd_data_;
  rd_data_ = rd_data;
  if (rd_data) {
    set_has_rd_data();
  } else {
    clear_has_rd_data();
  }
}

// optional int32 formation_index = 5;
inline bool battle_player_info::has_formation_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void battle_player_info::set_has_formation_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void battle_player_info::clear_has_formation_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void battle_player_info::clear_formation_index() {
  formation_index_ = 0;
  clear_has_formation_index();
}
inline ::google::protobuf::int32 battle_player_info::formation_index() const {
  return formation_index_;
}
inline void battle_player_info::set_formation_index(::google::protobuf::int32 value) {
  set_has_formation_index();
  formation_index_ = value;
}

// repeated .SProtoSpace.hero_attr_value total_attr = 6;
inline int battle_player_info::total_attr_size() const {
  return total_attr_.size();
}
inline void battle_player_info::clear_total_attr() {
  total_attr_.Clear();
}
inline const ::SProtoSpace::hero_attr_value& battle_player_info::total_attr(int index) const {
  return total_attr_.Get(index);
}
inline ::SProtoSpace::hero_attr_value* battle_player_info::mutable_total_attr(int index) {
  return total_attr_.Mutable(index);
}
inline ::SProtoSpace::hero_attr_value* battle_player_info::add_total_attr() {
  return total_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >&
battle_player_info::total_attr() const {
  return total_attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::hero_attr_value >*
battle_player_info::mutable_total_attr() {
  return &total_attr_;
}

// -------------------------------------------------------------------

// battle_role_info

// optional .SProtoSpace.EPlayerType type = 7;
inline bool battle_role_info::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_role_info::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_role_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_role_info::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SProtoSpace::EPlayerType battle_role_info::type() const {
  return static_cast< ::SProtoSpace::EPlayerType >(type_);
}
inline void battle_role_info::set_type(::SProtoSpace::EPlayerType value) {
  assert(::SProtoSpace::EPlayerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 id = 1;
inline bool battle_role_info::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_role_info::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_role_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_role_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 battle_role_info::id() const {
  return id_;
}
inline void battle_role_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool battle_role_info::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_role_info::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_role_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_role_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& battle_role_info::name() const {
  return *name_;
}
inline void battle_role_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void battle_role_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void battle_role_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* battle_role_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* battle_role_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void battle_role_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 3;
inline bool battle_role_info::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void battle_role_info::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void battle_role_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void battle_role_info::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 battle_role_info::level() const {
  return level_;
}
inline void battle_role_info::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// repeated .SProtoSpace.battle_hero_info heroes = 4;
inline int battle_role_info::heroes_size() const {
  return heroes_.size();
}
inline void battle_role_info::clear_heroes() {
  heroes_.Clear();
}
inline const ::SProtoSpace::battle_hero_info& battle_role_info::heroes(int index) const {
  return heroes_.Get(index);
}
inline ::SProtoSpace::battle_hero_info* battle_role_info::mutable_heroes(int index) {
  return heroes_.Mutable(index);
}
inline ::SProtoSpace::battle_hero_info* battle_role_info::add_heroes() {
  return heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_hero_info >&
battle_role_info::heroes() const {
  return heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_hero_info >*
battle_role_info::mutable_heroes() {
  return &heroes_;
}

// optional uint64 gsid = 5;
inline bool battle_role_info::has_gsid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void battle_role_info::set_has_gsid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void battle_role_info::clear_has_gsid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void battle_role_info::clear_gsid() {
  gsid_ = GOOGLE_ULONGLONG(0);
  clear_has_gsid();
}
inline ::google::protobuf::uint64 battle_role_info::gsid() const {
  return gsid_;
}
inline void battle_role_info::set_gsid(::google::protobuf::uint64 value) {
  set_has_gsid();
  gsid_ = value;
}

// optional .SProtoSpace.battle_player_info player = 6;
inline bool battle_role_info::has_player() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void battle_role_info::set_has_player() {
  _has_bits_[0] |= 0x00000040u;
}
inline void battle_role_info::clear_has_player() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void battle_role_info::clear_player() {
  if (player_ != NULL) player_->::SProtoSpace::battle_player_info::Clear();
  clear_has_player();
}
inline const ::SProtoSpace::battle_player_info& battle_role_info::player() const {
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::SProtoSpace::battle_player_info* battle_role_info::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::SProtoSpace::battle_player_info;
  return player_;
}
inline ::SProtoSpace::battle_player_info* battle_role_info::release_player() {
  clear_has_player();
  ::SProtoSpace::battle_player_info* temp = player_;
  player_ = NULL;
  return temp;
}
inline void battle_role_info::set_allocated_player(::SProtoSpace::battle_player_info* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
}

// optional uint64 gtid = 8;
inline bool battle_role_info::has_gtid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void battle_role_info::set_has_gtid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void battle_role_info::clear_has_gtid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void battle_role_info::clear_gtid() {
  gtid_ = GOOGLE_ULONGLONG(0);
  clear_has_gtid();
}
inline ::google::protobuf::uint64 battle_role_info::gtid() const {
  return gtid_;
}
inline void battle_role_info::set_gtid(::google::protobuf::uint64 value) {
  set_has_gtid();
  gtid_ = value;
}

// -------------------------------------------------------------------

// battle_camp_info

// repeated .SProtoSpace.battle_role_info roles = 1;
inline int battle_camp_info::roles_size() const {
  return roles_.size();
}
inline void battle_camp_info::clear_roles() {
  roles_.Clear();
}
inline const ::SProtoSpace::battle_role_info& battle_camp_info::roles(int index) const {
  return roles_.Get(index);
}
inline ::SProtoSpace::battle_role_info* battle_camp_info::mutable_roles(int index) {
  return roles_.Mutable(index);
}
inline ::SProtoSpace::battle_role_info* battle_camp_info::add_roles() {
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_role_info >&
battle_camp_info::roles() const {
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_role_info >*
battle_camp_info::mutable_roles() {
  return &roles_;
}

// optional int32 init_power = 2;
inline bool battle_camp_info::has_init_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_camp_info::set_has_init_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_camp_info::clear_has_init_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_camp_info::clear_init_power() {
  init_power_ = 0;
  clear_has_init_power();
}
inline ::google::protobuf::int32 battle_camp_info::init_power() const {
  return init_power_;
}
inline void battle_camp_info::set_init_power(::google::protobuf::int32 value) {
  set_has_init_power();
  init_power_ = value;
}

// optional int32 camp = 3;
inline bool battle_camp_info::has_camp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_camp_info::set_has_camp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_camp_info::clear_has_camp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_camp_info::clear_camp() {
  camp_ = 0;
  clear_has_camp();
}
inline ::google::protobuf::int32 battle_camp_info::camp() const {
  return camp_;
}
inline void battle_camp_info::set_camp(::google::protobuf::int32 value) {
  set_has_camp();
  camp_ = value;
}

// -------------------------------------------------------------------

// pvp_battle_init_data

// repeated .SProtoSpace.battle_camp_info camps = 1;
inline int pvp_battle_init_data::camps_size() const {
  return camps_.size();
}
inline void pvp_battle_init_data::clear_camps() {
  camps_.Clear();
}
inline const ::SProtoSpace::battle_camp_info& pvp_battle_init_data::camps(int index) const {
  return camps_.Get(index);
}
inline ::SProtoSpace::battle_camp_info* pvp_battle_init_data::mutable_camps(int index) {
  return camps_.Mutable(index);
}
inline ::SProtoSpace::battle_camp_info* pvp_battle_init_data::add_camps() {
  return camps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >&
pvp_battle_init_data::camps() const {
  return camps_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >*
pvp_battle_init_data::mutable_camps() {
  return &camps_;
}

// -------------------------------------------------------------------

// battle_end_data

// optional int32 type = 1;
inline bool battle_end_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_end_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_end_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_end_data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 battle_end_data::type() const {
  return type_;
}
inline void battle_end_data::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 battle_id = 2;
inline bool battle_end_data::has_battle_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_end_data::set_has_battle_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_end_data::clear_has_battle_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_end_data::clear_battle_id() {
  battle_id_ = 0;
  clear_has_battle_id();
}
inline ::google::protobuf::int32 battle_end_data::battle_id() const {
  return battle_id_;
}
inline void battle_end_data::set_battle_id(::google::protobuf::int32 value) {
  set_has_battle_id();
  battle_id_ = value;
}

// optional bool is_win = 3;
inline bool battle_end_data::has_is_win() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_end_data::set_has_is_win() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_end_data::clear_has_is_win() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_end_data::clear_is_win() {
  is_win_ = false;
  clear_has_is_win();
}
inline bool battle_end_data::is_win() const {
  return is_win_;
}
inline void battle_end_data::set_is_win(bool value) {
  set_has_is_win();
  is_win_ = value;
}

// repeated .SProtoSpace.battle_check_opt_data opts = 4;
inline int battle_end_data::opts_size() const {
  return opts_.size();
}
inline void battle_end_data::clear_opts() {
  opts_.Clear();
}
inline const ::SProtoSpace::battle_check_opt_data& battle_end_data::opts(int index) const {
  return opts_.Get(index);
}
inline ::SProtoSpace::battle_check_opt_data* battle_end_data::mutable_opts(int index) {
  return opts_.Mutable(index);
}
inline ::SProtoSpace::battle_check_opt_data* battle_end_data::add_opts() {
  return opts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >&
battle_end_data::opts() const {
  return opts_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >*
battle_end_data::mutable_opts() {
  return &opts_;
}

// optional int32 module_id = 5;
inline bool battle_end_data::has_module_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void battle_end_data::set_has_module_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void battle_end_data::clear_has_module_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void battle_end_data::clear_module_id() {
  module_id_ = 0;
  clear_has_module_id();
}
inline ::google::protobuf::int32 battle_end_data::module_id() const {
  return module_id_;
}
inline void battle_end_data::set_module_id(::google::protobuf::int32 value) {
  set_has_module_id();
  module_id_ = value;
}

// optional .SProtoSpace.EHeroFormationType formation_type = 6;
inline bool battle_end_data::has_formation_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void battle_end_data::set_has_formation_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void battle_end_data::clear_has_formation_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void battle_end_data::clear_formation_type() {
  formation_type_ = 1;
  clear_has_formation_type();
}
inline ::SProtoSpace::EHeroFormationType battle_end_data::formation_type() const {
  return static_cast< ::SProtoSpace::EHeroFormationType >(formation_type_);
}
inline void battle_end_data::set_formation_type(::SProtoSpace::EHeroFormationType value) {
  assert(::SProtoSpace::EHeroFormationType_IsValid(value));
  set_has_formation_type();
  formation_type_ = value;
}

// -------------------------------------------------------------------

// pve_check_battle_init_data

// optional uint64 role_id = 1;
inline bool pve_check_battle_init_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pve_check_battle_init_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pve_check_battle_init_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pve_check_battle_init_data::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 pve_check_battle_init_data::role_id() const {
  return role_id_;
}
inline void pve_check_battle_init_data::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint64 gs_id = 2;
inline bool pve_check_battle_init_data::has_gs_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pve_check_battle_init_data::set_has_gs_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pve_check_battle_init_data::clear_has_gs_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pve_check_battle_init_data::clear_gs_id() {
  gs_id_ = GOOGLE_ULONGLONG(0);
  clear_has_gs_id();
}
inline ::google::protobuf::uint64 pve_check_battle_init_data::gs_id() const {
  return gs_id_;
}
inline void pve_check_battle_init_data::set_gs_id(::google::protobuf::uint64 value) {
  set_has_gs_id();
  gs_id_ = value;
}

// optional .SProtoSpace.battle_end_data battle_end_info = 3;
inline bool pve_check_battle_init_data::has_battle_end_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pve_check_battle_init_data::set_has_battle_end_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pve_check_battle_init_data::clear_has_battle_end_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pve_check_battle_init_data::clear_battle_end_info() {
  if (battle_end_info_ != NULL) battle_end_info_->::SProtoSpace::battle_end_data::Clear();
  clear_has_battle_end_info();
}
inline const ::SProtoSpace::battle_end_data& pve_check_battle_init_data::battle_end_info() const {
  return battle_end_info_ != NULL ? *battle_end_info_ : *default_instance_->battle_end_info_;
}
inline ::SProtoSpace::battle_end_data* pve_check_battle_init_data::mutable_battle_end_info() {
  set_has_battle_end_info();
  if (battle_end_info_ == NULL) battle_end_info_ = new ::SProtoSpace::battle_end_data;
  return battle_end_info_;
}
inline ::SProtoSpace::battle_end_data* pve_check_battle_init_data::release_battle_end_info() {
  clear_has_battle_end_info();
  ::SProtoSpace::battle_end_data* temp = battle_end_info_;
  battle_end_info_ = NULL;
  return temp;
}
inline void pve_check_battle_init_data::set_allocated_battle_end_info(::SProtoSpace::battle_end_data* battle_end_info) {
  delete battle_end_info_;
  battle_end_info_ = battle_end_info;
  if (battle_end_info) {
    set_has_battle_end_info();
  } else {
    clear_has_battle_end_info();
  }
}

// -------------------------------------------------------------------

// create_battle_data

// optional .SProtoSpace.EBattleType type = 1;
inline bool create_battle_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void create_battle_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void create_battle_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void create_battle_data::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::EBattleType create_battle_data::type() const {
  return static_cast< ::SProtoSpace::EBattleType >(type_);
}
inline void create_battle_data::set_type(::SProtoSpace::EBattleType value) {
  assert(::SProtoSpace::EBattleType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 combat_id = 2;
inline bool create_battle_data::has_combat_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void create_battle_data::set_has_combat_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void create_battle_data::clear_has_combat_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void create_battle_data::clear_combat_id() {
  combat_id_ = 0u;
  clear_has_combat_id();
}
inline ::google::protobuf::uint32 create_battle_data::combat_id() const {
  return combat_id_;
}
inline void create_battle_data::set_combat_id(::google::protobuf::uint32 value) {
  set_has_combat_id();
  combat_id_ = value;
}

// optional uint32 seed = 3;
inline bool create_battle_data::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void create_battle_data::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void create_battle_data::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void create_battle_data::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 create_battle_data::seed() const {
  return seed_;
}
inline void create_battle_data::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
}

// optional .SProtoSpace.pvp_battle_init_data pvp_data = 4;
inline bool create_battle_data::has_pvp_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void create_battle_data::set_has_pvp_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void create_battle_data::clear_has_pvp_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void create_battle_data::clear_pvp_data() {
  if (pvp_data_ != NULL) pvp_data_->::SProtoSpace::pvp_battle_init_data::Clear();
  clear_has_pvp_data();
}
inline const ::SProtoSpace::pvp_battle_init_data& create_battle_data::pvp_data() const {
  return pvp_data_ != NULL ? *pvp_data_ : *default_instance_->pvp_data_;
}
inline ::SProtoSpace::pvp_battle_init_data* create_battle_data::mutable_pvp_data() {
  set_has_pvp_data();
  if (pvp_data_ == NULL) pvp_data_ = new ::SProtoSpace::pvp_battle_init_data;
  return pvp_data_;
}
inline ::SProtoSpace::pvp_battle_init_data* create_battle_data::release_pvp_data() {
  clear_has_pvp_data();
  ::SProtoSpace::pvp_battle_init_data* temp = pvp_data_;
  pvp_data_ = NULL;
  return temp;
}
inline void create_battle_data::set_allocated_pvp_data(::SProtoSpace::pvp_battle_init_data* pvp_data) {
  delete pvp_data_;
  pvp_data_ = pvp_data;
  if (pvp_data) {
    set_has_pvp_data();
  } else {
    clear_has_pvp_data();
  }
}

// optional .SProtoSpace.pve_check_battle_init_data pve_check_data = 5;
inline bool create_battle_data::has_pve_check_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void create_battle_data::set_has_pve_check_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void create_battle_data::clear_has_pve_check_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void create_battle_data::clear_pve_check_data() {
  if (pve_check_data_ != NULL) pve_check_data_->::SProtoSpace::pve_check_battle_init_data::Clear();
  clear_has_pve_check_data();
}
inline const ::SProtoSpace::pve_check_battle_init_data& create_battle_data::pve_check_data() const {
  return pve_check_data_ != NULL ? *pve_check_data_ : *default_instance_->pve_check_data_;
}
inline ::SProtoSpace::pve_check_battle_init_data* create_battle_data::mutable_pve_check_data() {
  set_has_pve_check_data();
  if (pve_check_data_ == NULL) pve_check_data_ = new ::SProtoSpace::pve_check_battle_init_data;
  return pve_check_data_;
}
inline ::SProtoSpace::pve_check_battle_init_data* create_battle_data::release_pve_check_data() {
  clear_has_pve_check_data();
  ::SProtoSpace::pve_check_battle_init_data* temp = pve_check_data_;
  pve_check_data_ = NULL;
  return temp;
}
inline void create_battle_data::set_allocated_pve_check_data(::SProtoSpace::pve_check_battle_init_data* pve_check_data) {
  delete pve_check_data_;
  pve_check_data_ = pve_check_data;
  if (pve_check_data) {
    set_has_pve_check_data();
  } else {
    clear_has_pve_check_data();
  }
}

// -------------------------------------------------------------------

// running_entity

// optional uint64 objid = 1;
inline bool running_entity::has_objid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void running_entity::set_has_objid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void running_entity::clear_has_objid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void running_entity::clear_objid() {
  objid_ = GOOGLE_ULONGLONG(0);
  clear_has_objid();
}
inline ::google::protobuf::uint64 running_entity::objid() const {
  return objid_;
}
inline void running_entity::set_objid(::google::protobuf::uint64 value) {
  set_has_objid();
  objid_ = value;
}

// optional int32 position = 2;
inline bool running_entity::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void running_entity::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void running_entity::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void running_entity::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 running_entity::position() const {
  return position_;
}
inline void running_entity::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// -------------------------------------------------------------------

// running_queue

// optional int32 lenth = 1;
inline bool running_queue::has_lenth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void running_queue::set_has_lenth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void running_queue::clear_has_lenth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void running_queue::clear_lenth() {
  lenth_ = 0;
  clear_has_lenth();
}
inline ::google::protobuf::int32 running_queue::lenth() const {
  return lenth_;
}
inline void running_queue::set_lenth(::google::protobuf::int32 value) {
  set_has_lenth();
  lenth_ = value;
}

// repeated .SProtoSpace.running_entity enities = 2;
inline int running_queue::enities_size() const {
  return enities_.size();
}
inline void running_queue::clear_enities() {
  enities_.Clear();
}
inline const ::SProtoSpace::running_entity& running_queue::enities(int index) const {
  return enities_.Get(index);
}
inline ::SProtoSpace::running_entity* running_queue::mutable_enities(int index) {
  return enities_.Mutable(index);
}
inline ::SProtoSpace::running_entity* running_queue::add_enities() {
  return enities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >&
running_queue::enities() const {
  return enities_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >*
running_queue::mutable_enities() {
  return &enities_;
}

// repeated .SProtoSpace.running_entity wait_enities = 3;
inline int running_queue::wait_enities_size() const {
  return wait_enities_.size();
}
inline void running_queue::clear_wait_enities() {
  wait_enities_.Clear();
}
inline const ::SProtoSpace::running_entity& running_queue::wait_enities(int index) const {
  return wait_enities_.Get(index);
}
inline ::SProtoSpace::running_entity* running_queue::mutable_wait_enities(int index) {
  return wait_enities_.Mutable(index);
}
inline ::SProtoSpace::running_entity* running_queue::add_wait_enities() {
  return wait_enities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >&
running_queue::wait_enities() const {
  return wait_enities_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::running_entity >*
running_queue::mutable_wait_enities() {
  return &wait_enities_;
}

// -------------------------------------------------------------------

// client_hero_info

// required uint64 uuid = 1;
inline bool client_hero_info::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_hero_info::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_hero_info::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_hero_info::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 client_hero_info::uuid() const {
  return uuid_;
}
inline void client_hero_info::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required uint32 objid = 2;
inline bool client_hero_info::has_objid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_hero_info::set_has_objid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_hero_info::clear_has_objid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_hero_info::clear_objid() {
  objid_ = 0u;
  clear_has_objid();
}
inline ::google::protobuf::uint32 client_hero_info::objid() const {
  return objid_;
}
inline void client_hero_info::set_objid(::google::protobuf::uint32 value) {
  set_has_objid();
  objid_ = value;
}

// required uint32 template_id = 3;
inline bool client_hero_info::has_template_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_hero_info::set_has_template_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_hero_info::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_hero_info::clear_template_id() {
  template_id_ = 0u;
  clear_has_template_id();
}
inline ::google::protobuf::uint32 client_hero_info::template_id() const {
  return template_id_;
}
inline void client_hero_info::set_template_id(::google::protobuf::uint32 value) {
  set_has_template_id();
  template_id_ = value;
}

// required int32 level = 4;
inline bool client_hero_info::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_hero_info::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_hero_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_hero_info::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 client_hero_info::level() const {
  return level_;
}
inline void client_hero_info::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 star = 5;
inline bool client_hero_info::has_star() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_hero_info::set_has_star() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_hero_info::clear_has_star() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_hero_info::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 client_hero_info::star() const {
  return star_;
}
inline void client_hero_info::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// optional int32 quality = 6;
inline bool client_hero_info::has_quality() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void client_hero_info::set_has_quality() {
  _has_bits_[0] |= 0x00000020u;
}
inline void client_hero_info::clear_has_quality() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void client_hero_info::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 client_hero_info::quality() const {
  return quality_;
}
inline void client_hero_info::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional string name = 7;
inline bool client_hero_info::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void client_hero_info::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void client_hero_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void client_hero_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& client_hero_info::name() const {
  return *name_;
}
inline void client_hero_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void client_hero_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void client_hero_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* client_hero_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* client_hero_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void client_hero_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// client_battle_player_info

// required uint64 id = 1;
inline bool client_battle_player_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_battle_player_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_battle_player_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_battle_player_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 client_battle_player_info::id() const {
  return id_;
}
inline void client_battle_player_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool client_battle_player_info::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_battle_player_info::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_battle_player_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_battle_player_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& client_battle_player_info::name() const {
  return *name_;
}
inline void client_battle_player_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void client_battle_player_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void client_battle_player_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* client_battle_player_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* client_battle_player_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void client_battle_player_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool client_battle_player_info::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_battle_player_info::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_battle_player_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_battle_player_info::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 client_battle_player_info::level() const {
  return level_;
}
inline void client_battle_player_info::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 camp = 4;
inline bool client_battle_player_info::has_camp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_battle_player_info::set_has_camp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_battle_player_info::clear_has_camp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_battle_player_info::clear_camp() {
  camp_ = 0;
  clear_has_camp();
}
inline ::google::protobuf::int32 client_battle_player_info::camp() const {
  return camp_;
}
inline void client_battle_player_info::set_camp(::google::protobuf::int32 value) {
  set_has_camp();
  camp_ = value;
}

// required .SProtoSpace.EPlayerType type = 5;
inline bool client_battle_player_info::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_battle_player_info::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_battle_player_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_battle_player_info::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SProtoSpace::EPlayerType client_battle_player_info::type() const {
  return static_cast< ::SProtoSpace::EPlayerType >(type_);
}
inline void client_battle_player_info::set_type(::SProtoSpace::EPlayerType value) {
  assert(::SProtoSpace::EPlayerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .SProtoSpace.client_hero_info heroes = 6;
inline int client_battle_player_info::heroes_size() const {
  return heroes_.size();
}
inline void client_battle_player_info::clear_heroes() {
  heroes_.Clear();
}
inline const ::SProtoSpace::client_hero_info& client_battle_player_info::heroes(int index) const {
  return heroes_.Get(index);
}
inline ::SProtoSpace::client_hero_info* client_battle_player_info::mutable_heroes(int index) {
  return heroes_.Mutable(index);
}
inline ::SProtoSpace::client_hero_info* client_battle_player_info::add_heroes() {
  return heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_hero_info >&
client_battle_player_info::heroes() const {
  return heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_hero_info >*
client_battle_player_info::mutable_heroes() {
  return &heroes_;
}

// -------------------------------------------------------------------

// client_pvp_battle_camp_data

// repeated .SProtoSpace.client_battle_player_info players = 1;
inline int client_pvp_battle_camp_data::players_size() const {
  return players_.size();
}
inline void client_pvp_battle_camp_data::clear_players() {
  players_.Clear();
}
inline const ::SProtoSpace::client_battle_player_info& client_pvp_battle_camp_data::players(int index) const {
  return players_.Get(index);
}
inline ::SProtoSpace::client_battle_player_info* client_pvp_battle_camp_data::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::SProtoSpace::client_battle_player_info* client_pvp_battle_camp_data::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_battle_player_info >&
client_pvp_battle_camp_data::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::client_battle_player_info >*
client_pvp_battle_camp_data::mutable_players() {
  return &players_;
}

// required int32 init_power = 2;
inline bool client_pvp_battle_camp_data::has_init_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_pvp_battle_camp_data::set_has_init_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_pvp_battle_camp_data::clear_has_init_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_pvp_battle_camp_data::clear_init_power() {
  init_power_ = 0;
  clear_has_init_power();
}
inline ::google::protobuf::int32 client_pvp_battle_camp_data::init_power() const {
  return init_power_;
}
inline void client_pvp_battle_camp_data::set_init_power(::google::protobuf::int32 value) {
  set_has_init_power();
  init_power_ = value;
}

// -------------------------------------------------------------------

// client_pvp_battle_data

// repeated .SProtoSpace.battle_camp_info camps = 1;
inline int client_pvp_battle_data::camps_size() const {
  return camps_.size();
}
inline void client_pvp_battle_data::clear_camps() {
  camps_.Clear();
}
inline const ::SProtoSpace::battle_camp_info& client_pvp_battle_data::camps(int index) const {
  return camps_.Get(index);
}
inline ::SProtoSpace::battle_camp_info* client_pvp_battle_data::mutable_camps(int index) {
  return camps_.Mutable(index);
}
inline ::SProtoSpace::battle_camp_info* client_pvp_battle_data::add_camps() {
  return camps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >&
client_pvp_battle_data::camps() const {
  return camps_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_camp_info >*
client_pvp_battle_data::mutable_camps() {
  return &camps_;
}

// optional .SProtoSpace.running_queue running_data = 2;
inline bool client_pvp_battle_data::has_running_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_pvp_battle_data::set_has_running_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_pvp_battle_data::clear_has_running_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_pvp_battle_data::clear_running_data() {
  if (running_data_ != NULL) running_data_->::SProtoSpace::running_queue::Clear();
  clear_has_running_data();
}
inline const ::SProtoSpace::running_queue& client_pvp_battle_data::running_data() const {
  return running_data_ != NULL ? *running_data_ : *default_instance_->running_data_;
}
inline ::SProtoSpace::running_queue* client_pvp_battle_data::mutable_running_data() {
  set_has_running_data();
  if (running_data_ == NULL) running_data_ = new ::SProtoSpace::running_queue;
  return running_data_;
}
inline ::SProtoSpace::running_queue* client_pvp_battle_data::release_running_data() {
  clear_has_running_data();
  ::SProtoSpace::running_queue* temp = running_data_;
  running_data_ = NULL;
  return temp;
}
inline void client_pvp_battle_data::set_allocated_running_data(::SProtoSpace::running_queue* running_data) {
  delete running_data_;
  running_data_ = running_data;
  if (running_data) {
    set_has_running_data();
  } else {
    clear_has_running_data();
  }
}

// optional int32 round_index = 3;
inline bool client_pvp_battle_data::has_round_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_pvp_battle_data::set_has_round_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_pvp_battle_data::clear_has_round_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_pvp_battle_data::clear_round_index() {
  round_index_ = 0;
  clear_has_round_index();
}
inline ::google::protobuf::int32 client_pvp_battle_data::round_index() const {
  return round_index_;
}
inline void client_pvp_battle_data::set_round_index(::google::protobuf::int32 value) {
  set_has_round_index();
  round_index_ = value;
}

// optional .SProtoSpace.round_op_param opt = 4;
inline bool client_pvp_battle_data::has_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_pvp_battle_data::set_has_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_pvp_battle_data::clear_has_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_pvp_battle_data::clear_opt() {
  if (opt_ != NULL) opt_->::SProtoSpace::round_op_param::Clear();
  clear_has_opt();
}
inline const ::SProtoSpace::round_op_param& client_pvp_battle_data::opt() const {
  return opt_ != NULL ? *opt_ : *default_instance_->opt_;
}
inline ::SProtoSpace::round_op_param* client_pvp_battle_data::mutable_opt() {
  set_has_opt();
  if (opt_ == NULL) opt_ = new ::SProtoSpace::round_op_param;
  return opt_;
}
inline ::SProtoSpace::round_op_param* client_pvp_battle_data::release_opt() {
  clear_has_opt();
  ::SProtoSpace::round_op_param* temp = opt_;
  opt_ = NULL;
  return temp;
}
inline void client_pvp_battle_data::set_allocated_opt(::SProtoSpace::round_op_param* opt) {
  delete opt_;
  opt_ = opt;
  if (opt) {
    set_has_opt();
  } else {
    clear_has_opt();
  }
}

// optional uint32 seed = 5;
inline bool client_pvp_battle_data::has_seed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_pvp_battle_data::set_has_seed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_pvp_battle_data::clear_has_seed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_pvp_battle_data::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 client_pvp_battle_data::seed() const {
  return seed_;
}
inline void client_pvp_battle_data::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
}

// optional uint32 seed_count = 6;
inline bool client_pvp_battle_data::has_seed_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void client_pvp_battle_data::set_has_seed_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void client_pvp_battle_data::clear_has_seed_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void client_pvp_battle_data::clear_seed_count() {
  seed_count_ = 0u;
  clear_has_seed_count();
}
inline ::google::protobuf::uint32 client_pvp_battle_data::seed_count() const {
  return seed_count_;
}
inline void client_pvp_battle_data::set_seed_count(::google::protobuf::uint32 value) {
  set_has_seed_count();
  seed_count_ = value;
}

// -------------------------------------------------------------------

// client_battle_data

// required .SProtoSpace.EBattleType type = 1;
inline bool client_battle_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_battle_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_battle_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_battle_data::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::EBattleType client_battle_data::type() const {
  return static_cast< ::SProtoSpace::EBattleType >(type_);
}
inline void client_battle_data::set_type(::SProtoSpace::EBattleType value) {
  assert(::SProtoSpace::EBattleType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .SProtoSpace.client_pvp_battle_data pvp_data = 2;
inline bool client_battle_data::has_pvp_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_battle_data::set_has_pvp_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_battle_data::clear_has_pvp_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_battle_data::clear_pvp_data() {
  if (pvp_data_ != NULL) pvp_data_->::SProtoSpace::client_pvp_battle_data::Clear();
  clear_has_pvp_data();
}
inline const ::SProtoSpace::client_pvp_battle_data& client_battle_data::pvp_data() const {
  return pvp_data_ != NULL ? *pvp_data_ : *default_instance_->pvp_data_;
}
inline ::SProtoSpace::client_pvp_battle_data* client_battle_data::mutable_pvp_data() {
  set_has_pvp_data();
  if (pvp_data_ == NULL) pvp_data_ = new ::SProtoSpace::client_pvp_battle_data;
  return pvp_data_;
}
inline ::SProtoSpace::client_pvp_battle_data* client_battle_data::release_pvp_data() {
  clear_has_pvp_data();
  ::SProtoSpace::client_pvp_battle_data* temp = pvp_data_;
  pvp_data_ = NULL;
  return temp;
}
inline void client_battle_data::set_allocated_pvp_data(::SProtoSpace::client_pvp_battle_data* pvp_data) {
  delete pvp_data_;
  pvp_data_ = pvp_data;
  if (pvp_data) {
    set_has_pvp_data();
  } else {
    clear_has_pvp_data();
  }
}

// -------------------------------------------------------------------

// battle_check_opt_data

// optional int32 round_index = 1;
inline bool battle_check_opt_data::has_round_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_check_opt_data::set_has_round_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_check_opt_data::clear_has_round_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_check_opt_data::clear_round_index() {
  round_index_ = 0;
  clear_has_round_index();
}
inline ::google::protobuf::int32 battle_check_opt_data::round_index() const {
  return round_index_;
}
inline void battle_check_opt_data::set_round_index(::google::protobuf::int32 value) {
  set_has_round_index();
  round_index_ = value;
}

// optional .SProtoSpace.round_op_param opt = 2;
inline bool battle_check_opt_data::has_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_check_opt_data::set_has_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_check_opt_data::clear_has_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_check_opt_data::clear_opt() {
  if (opt_ != NULL) opt_->::SProtoSpace::round_op_param::Clear();
  clear_has_opt();
}
inline const ::SProtoSpace::round_op_param& battle_check_opt_data::opt() const {
  return opt_ != NULL ? *opt_ : *default_instance_->opt_;
}
inline ::SProtoSpace::round_op_param* battle_check_opt_data::mutable_opt() {
  set_has_opt();
  if (opt_ == NULL) opt_ = new ::SProtoSpace::round_op_param;
  return opt_;
}
inline ::SProtoSpace::round_op_param* battle_check_opt_data::release_opt() {
  clear_has_opt();
  ::SProtoSpace::round_op_param* temp = opt_;
  opt_ = NULL;
  return temp;
}
inline void battle_check_opt_data::set_allocated_opt(::SProtoSpace::round_op_param* opt) {
  delete opt_;
  opt_ = opt;
  if (opt) {
    set_has_opt();
  } else {
    clear_has_opt();
  }
}

// repeated .SProtoSpace.round_data data = 3;
inline int battle_check_opt_data::data_size() const {
  return data_.size();
}
inline void battle_check_opt_data::clear_data() {
  data_.Clear();
}
inline const ::SProtoSpace::round_data& battle_check_opt_data::data(int index) const {
  return data_.Get(index);
}
inline ::SProtoSpace::round_data* battle_check_opt_data::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::SProtoSpace::round_data* battle_check_opt_data::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >&
battle_check_opt_data::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >*
battle_check_opt_data::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// office_end_info

// optional int32 round_index = 1;
inline bool office_end_info::has_round_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void office_end_info::set_has_round_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void office_end_info::clear_has_round_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void office_end_info::clear_round_index() {
  round_index_ = 0;
  clear_has_round_index();
}
inline ::google::protobuf::int32 office_end_info::round_index() const {
  return round_index_;
}
inline void office_end_info::set_round_index(::google::protobuf::int32 value) {
  set_has_round_index();
  round_index_ = value;
}

// optional .SProtoSpace.round_op_param opt = 2;
inline bool office_end_info::has_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void office_end_info::set_has_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void office_end_info::clear_has_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void office_end_info::clear_opt() {
  if (opt_ != NULL) opt_->::SProtoSpace::round_op_param::Clear();
  clear_has_opt();
}
inline const ::SProtoSpace::round_op_param& office_end_info::opt() const {
  return opt_ != NULL ? *opt_ : *default_instance_->opt_;
}
inline ::SProtoSpace::round_op_param* office_end_info::mutable_opt() {
  set_has_opt();
  if (opt_ == NULL) opt_ = new ::SProtoSpace::round_op_param;
  return opt_;
}
inline ::SProtoSpace::round_op_param* office_end_info::release_opt() {
  clear_has_opt();
  ::SProtoSpace::round_op_param* temp = opt_;
  opt_ = NULL;
  return temp;
}
inline void office_end_info::set_allocated_opt(::SProtoSpace::round_op_param* opt) {
  delete opt_;
  opt_ = opt;
  if (opt) {
    set_has_opt();
  } else {
    clear_has_opt();
  }
}

// repeated .SProtoSpace.round_data data = 3;
inline int office_end_info::data_size() const {
  return data_.size();
}
inline void office_end_info::clear_data() {
  data_.Clear();
}
inline const ::SProtoSpace::round_data& office_end_info::data(int index) const {
  return data_.Get(index);
}
inline ::SProtoSpace::round_data* office_end_info::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::SProtoSpace::round_data* office_end_info::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >&
office_end_info::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::round_data >*
office_end_info::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// battle_replay_round_info

// optional int32 round_index = 1;
inline bool battle_replay_round_info::has_round_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_replay_round_info::set_has_round_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_replay_round_info::clear_has_round_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_replay_round_info::clear_round_index() {
  round_index_ = 0;
  clear_has_round_index();
}
inline ::google::protobuf::int32 battle_replay_round_info::round_index() const {
  return round_index_;
}
inline void battle_replay_round_info::set_round_index(::google::protobuf::int32 value) {
  set_has_round_index();
  round_index_ = value;
}

// repeated .SProtoSpace.battle_check_opt_data opts = 2;
inline int battle_replay_round_info::opts_size() const {
  return opts_.size();
}
inline void battle_replay_round_info::clear_opts() {
  opts_.Clear();
}
inline const ::SProtoSpace::battle_check_opt_data& battle_replay_round_info::opts(int index) const {
  return opts_.Get(index);
}
inline ::SProtoSpace::battle_check_opt_data* battle_replay_round_info::mutable_opts(int index) {
  return opts_.Mutable(index);
}
inline ::SProtoSpace::battle_check_opt_data* battle_replay_round_info::add_opts() {
  return opts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >&
battle_replay_round_info::opts() const {
  return opts_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_check_opt_data >*
battle_replay_round_info::mutable_opts() {
  return &opts_;
}

// -------------------------------------------------------------------

// battle_replay_turn_info

// optional int32 turn_index = 1;
inline bool battle_replay_turn_info::has_turn_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_replay_turn_info::set_has_turn_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_replay_turn_info::clear_has_turn_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_replay_turn_info::clear_turn_index() {
  turn_index_ = 0;
  clear_has_turn_index();
}
inline ::google::protobuf::int32 battle_replay_turn_info::turn_index() const {
  return turn_index_;
}
inline void battle_replay_turn_info::set_turn_index(::google::protobuf::int32 value) {
  set_has_turn_index();
  turn_index_ = value;
}

// optional .SProtoSpace.pvp_battle_init_data init_data = 2;
inline bool battle_replay_turn_info::has_init_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_replay_turn_info::set_has_init_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_replay_turn_info::clear_has_init_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_replay_turn_info::clear_init_data() {
  if (init_data_ != NULL) init_data_->::SProtoSpace::pvp_battle_init_data::Clear();
  clear_has_init_data();
}
inline const ::SProtoSpace::pvp_battle_init_data& battle_replay_turn_info::init_data() const {
  return init_data_ != NULL ? *init_data_ : *default_instance_->init_data_;
}
inline ::SProtoSpace::pvp_battle_init_data* battle_replay_turn_info::mutable_init_data() {
  set_has_init_data();
  if (init_data_ == NULL) init_data_ = new ::SProtoSpace::pvp_battle_init_data;
  return init_data_;
}
inline ::SProtoSpace::pvp_battle_init_data* battle_replay_turn_info::release_init_data() {
  clear_has_init_data();
  ::SProtoSpace::pvp_battle_init_data* temp = init_data_;
  init_data_ = NULL;
  return temp;
}
inline void battle_replay_turn_info::set_allocated_init_data(::SProtoSpace::pvp_battle_init_data* init_data) {
  delete init_data_;
  init_data_ = init_data;
  if (init_data) {
    set_has_init_data();
  } else {
    clear_has_init_data();
  }
}

// repeated .SProtoSpace.battle_replay_round_info opts = 3;
inline int battle_replay_turn_info::opts_size() const {
  return opts_.size();
}
inline void battle_replay_turn_info::clear_opts() {
  opts_.Clear();
}
inline const ::SProtoSpace::battle_replay_round_info& battle_replay_turn_info::opts(int index) const {
  return opts_.Get(index);
}
inline ::SProtoSpace::battle_replay_round_info* battle_replay_turn_info::mutable_opts(int index) {
  return opts_.Mutable(index);
}
inline ::SProtoSpace::battle_replay_round_info* battle_replay_turn_info::add_opts() {
  return opts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_round_info >&
battle_replay_turn_info::opts() const {
  return opts_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_round_info >*
battle_replay_turn_info::mutable_opts() {
  return &opts_;
}

// -------------------------------------------------------------------

// battle_replay_info

// optional .SProtoSpace.EBattleType type = 1;
inline bool battle_replay_info::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void battle_replay_info::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void battle_replay_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void battle_replay_info::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::EBattleType battle_replay_info::type() const {
  return static_cast< ::SProtoSpace::EBattleType >(type_);
}
inline void battle_replay_info::set_type(::SProtoSpace::EBattleType value) {
  assert(::SProtoSpace::EBattleType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 combat_id = 2;
inline bool battle_replay_info::has_combat_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void battle_replay_info::set_has_combat_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void battle_replay_info::clear_has_combat_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void battle_replay_info::clear_combat_id() {
  combat_id_ = 0u;
  clear_has_combat_id();
}
inline ::google::protobuf::uint32 battle_replay_info::combat_id() const {
  return combat_id_;
}
inline void battle_replay_info::set_combat_id(::google::protobuf::uint32 value) {
  set_has_combat_id();
  combat_id_ = value;
}

// optional uint32 seed = 3;
inline bool battle_replay_info::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void battle_replay_info::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void battle_replay_info::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void battle_replay_info::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 battle_replay_info::seed() const {
  return seed_;
}
inline void battle_replay_info::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
}

// optional int32 winner_camp = 4;
inline bool battle_replay_info::has_winner_camp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void battle_replay_info::set_has_winner_camp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void battle_replay_info::clear_has_winner_camp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void battle_replay_info::clear_winner_camp() {
  winner_camp_ = 0;
  clear_has_winner_camp();
}
inline ::google::protobuf::int32 battle_replay_info::winner_camp() const {
  return winner_camp_;
}
inline void battle_replay_info::set_winner_camp(::google::protobuf::int32 value) {
  set_has_winner_camp();
  winner_camp_ = value;
}

// repeated .SProtoSpace.battle_replay_turn_info opts = 5;
inline int battle_replay_info::opts_size() const {
  return opts_.size();
}
inline void battle_replay_info::clear_opts() {
  opts_.Clear();
}
inline const ::SProtoSpace::battle_replay_turn_info& battle_replay_info::opts(int index) const {
  return opts_.Get(index);
}
inline ::SProtoSpace::battle_replay_turn_info* battle_replay_info::mutable_opts(int index) {
  return opts_.Mutable(index);
}
inline ::SProtoSpace::battle_replay_turn_info* battle_replay_info::add_opts() {
  return opts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_turn_info >&
battle_replay_info::opts() const {
  return opts_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::battle_replay_turn_info >*
battle_replay_info::mutable_opts() {
  return &opts_;
}

// -------------------------------------------------------------------

// lsg_position_info

// optional float x = 1;
inline bool lsg_position_info::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lsg_position_info::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lsg_position_info::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lsg_position_info::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float lsg_position_info::x() const {
  return x_;
}
inline void lsg_position_info::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool lsg_position_info::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lsg_position_info::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lsg_position_info::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lsg_position_info::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float lsg_position_info::y() const {
  return y_;
}
inline void lsg_position_info::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional string position_name = 3;
inline bool lsg_position_info::has_position_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lsg_position_info::set_has_position_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lsg_position_info::clear_has_position_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lsg_position_info::clear_position_name() {
  if (position_name_ != &::google::protobuf::internal::kEmptyString) {
    position_name_->clear();
  }
  clear_has_position_name();
}
inline const ::std::string& lsg_position_info::position_name() const {
  return *position_name_;
}
inline void lsg_position_info::set_position_name(const ::std::string& value) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::kEmptyString) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(value);
}
inline void lsg_position_info::set_position_name(const char* value) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::kEmptyString) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(value);
}
inline void lsg_position_info::set_position_name(const char* value, size_t size) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::kEmptyString) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lsg_position_info::mutable_position_name() {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::kEmptyString) {
    position_name_ = new ::std::string;
  }
  return position_name_;
}
inline ::std::string* lsg_position_info::release_position_name() {
  clear_has_position_name();
  if (position_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_name_;
    position_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void lsg_position_info::set_allocated_position_name(::std::string* position_name) {
  if (position_name_ != &::google::protobuf::internal::kEmptyString) {
    delete position_name_;
  }
  if (position_name) {
    set_has_position_name();
    position_name_ = position_name;
  } else {
    clear_has_position_name();
    position_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// comment_info

// optional uint64 comment_id = 1;
inline bool comment_info::has_comment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void comment_info::set_has_comment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void comment_info::clear_has_comment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void comment_info::clear_comment_id() {
  comment_id_ = GOOGLE_ULONGLONG(0);
  clear_has_comment_id();
}
inline ::google::protobuf::uint64 comment_info::comment_id() const {
  return comment_id_;
}
inline void comment_info::set_comment_id(::google::protobuf::uint64 value) {
  set_has_comment_id();
  comment_id_ = value;
}

// optional uint64 role_id = 2;
inline bool comment_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comment_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comment_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comment_info::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 comment_info::role_id() const {
  return role_id_;
}
inline void comment_info::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 3;
inline bool comment_info::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void comment_info::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void comment_info::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void comment_info::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& comment_info::role_name() const {
  return *role_name_;
}
inline void comment_info::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void comment_info::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void comment_info::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* comment_info::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* comment_info::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void comment_info::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role_sex = 4;
inline bool comment_info::has_role_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void comment_info::set_has_role_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void comment_info::clear_has_role_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void comment_info::clear_role_sex() {
  role_sex_ = 0;
  clear_has_role_sex();
}
inline ::google::protobuf::int32 comment_info::role_sex() const {
  return role_sex_;
}
inline void comment_info::set_role_sex(::google::protobuf::int32 value) {
  set_has_role_sex();
  role_sex_ = value;
}

// optional int32 role_border = 5;
inline bool comment_info::has_role_border() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void comment_info::set_has_role_border() {
  _has_bits_[0] |= 0x00000010u;
}
inline void comment_info::clear_has_role_border() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void comment_info::clear_role_border() {
  role_border_ = 0;
  clear_has_role_border();
}
inline ::google::protobuf::int32 comment_info::role_border() const {
  return role_border_;
}
inline void comment_info::set_role_border(::google::protobuf::int32 value) {
  set_has_role_border();
  role_border_ = value;
}

// optional int32 role_lv = 6;
inline bool comment_info::has_role_lv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void comment_info::set_has_role_lv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void comment_info::clear_has_role_lv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void comment_info::clear_role_lv() {
  role_lv_ = 0;
  clear_has_role_lv();
}
inline ::google::protobuf::int32 comment_info::role_lv() const {
  return role_lv_;
}
inline void comment_info::set_role_lv(::google::protobuf::int32 value) {
  set_has_role_lv();
  role_lv_ = value;
}

// optional uint64 to_role_id = 7;
inline bool comment_info::has_to_role_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void comment_info::set_has_to_role_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void comment_info::clear_has_to_role_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void comment_info::clear_to_role_id() {
  to_role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_to_role_id();
}
inline ::google::protobuf::uint64 comment_info::to_role_id() const {
  return to_role_id_;
}
inline void comment_info::set_to_role_id(::google::protobuf::uint64 value) {
  set_has_to_role_id();
  to_role_id_ = value;
}

// optional string to_role_name = 8;
inline bool comment_info::has_to_role_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void comment_info::set_has_to_role_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void comment_info::clear_has_to_role_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void comment_info::clear_to_role_name() {
  if (to_role_name_ != &::google::protobuf::internal::kEmptyString) {
    to_role_name_->clear();
  }
  clear_has_to_role_name();
}
inline const ::std::string& comment_info::to_role_name() const {
  return *to_role_name_;
}
inline void comment_info::set_to_role_name(const ::std::string& value) {
  set_has_to_role_name();
  if (to_role_name_ == &::google::protobuf::internal::kEmptyString) {
    to_role_name_ = new ::std::string;
  }
  to_role_name_->assign(value);
}
inline void comment_info::set_to_role_name(const char* value) {
  set_has_to_role_name();
  if (to_role_name_ == &::google::protobuf::internal::kEmptyString) {
    to_role_name_ = new ::std::string;
  }
  to_role_name_->assign(value);
}
inline void comment_info::set_to_role_name(const char* value, size_t size) {
  set_has_to_role_name();
  if (to_role_name_ == &::google::protobuf::internal::kEmptyString) {
    to_role_name_ = new ::std::string;
  }
  to_role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* comment_info::mutable_to_role_name() {
  set_has_to_role_name();
  if (to_role_name_ == &::google::protobuf::internal::kEmptyString) {
    to_role_name_ = new ::std::string;
  }
  return to_role_name_;
}
inline ::std::string* comment_info::release_to_role_name() {
  clear_has_to_role_name();
  if (to_role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_role_name_;
    to_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void comment_info::set_allocated_to_role_name(::std::string* to_role_name) {
  if (to_role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_role_name_;
  }
  if (to_role_name) {
    set_has_to_role_name();
    to_role_name_ = to_role_name;
  } else {
    clear_has_to_role_name();
    to_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string comment = 9;
inline bool comment_info::has_comment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void comment_info::set_has_comment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void comment_info::clear_has_comment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void comment_info::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& comment_info::comment() const {
  return *comment_;
}
inline void comment_info::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void comment_info::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void comment_info::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* comment_info::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* comment_info::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void comment_info::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 time = 10;
inline bool comment_info::has_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void comment_info::set_has_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void comment_info::clear_has_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void comment_info::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 comment_info::time() const {
  return time_;
}
inline void comment_info::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// comment_all

// repeated .SProtoSpace.comment_info comment_list = 1;
inline int comment_all::comment_list_size() const {
  return comment_list_.size();
}
inline void comment_all::clear_comment_list() {
  comment_list_.Clear();
}
inline const ::SProtoSpace::comment_info& comment_all::comment_list(int index) const {
  return comment_list_.Get(index);
}
inline ::SProtoSpace::comment_info* comment_all::mutable_comment_list(int index) {
  return comment_list_.Mutable(index);
}
inline ::SProtoSpace::comment_info* comment_all::add_comment_list() {
  return comment_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::comment_info >&
comment_all::comment_list() const {
  return comment_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::comment_info >*
comment_all::mutable_comment_list() {
  return &comment_list_;
}

// optional int32 index = 2;
inline bool comment_all::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void comment_all::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void comment_all::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void comment_all::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 comment_all::index() const {
  return index_;
}
inline void comment_all::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// date_info

// optional uint32 year = 1 [default = 2000];
inline bool date_info::has_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void date_info::set_has_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void date_info::clear_has_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void date_info::clear_year() {
  year_ = 2000u;
  clear_has_year();
}
inline ::google::protobuf::uint32 date_info::year() const {
  return year_;
}
inline void date_info::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
}

// optional uint32 month = 2 [default = 1];
inline bool date_info::has_month() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void date_info::set_has_month() {
  _has_bits_[0] |= 0x00000002u;
}
inline void date_info::clear_has_month() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void date_info::clear_month() {
  month_ = 1u;
  clear_has_month();
}
inline ::google::protobuf::uint32 date_info::month() const {
  return month_;
}
inline void date_info::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// optional uint32 day = 3 [default = 1];
inline bool date_info::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void date_info::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void date_info::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void date_info::clear_day() {
  day_ = 1u;
  clear_has_day();
}
inline ::google::protobuf::uint32 date_info::day() const {
  return day_;
}
inline void date_info::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// -------------------------------------------------------------------

// show_player_base

// optional uint64 uuid = 2;
inline bool show_player_base::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void show_player_base::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void show_player_base::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void show_player_base::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 show_player_base::uuid() const {
  return uuid_;
}
inline void show_player_base::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional uint32 lv = 3;
inline bool show_player_base::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void show_player_base::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void show_player_base::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void show_player_base::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 show_player_base::lv() const {
  return lv_;
}
inline void show_player_base::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional string name = 4;
inline bool show_player_base::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void show_player_base::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void show_player_base::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void show_player_base::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& show_player_base::name() const {
  return *name_;
}
inline void show_player_base::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void show_player_base::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void show_player_base::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* show_player_base::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* show_player_base::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void show_player_base::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 5;
inline bool show_player_base::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void show_player_base::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void show_player_base::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void show_player_base::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 show_player_base::sex() const {
  return sex_;
}
inline void show_player_base::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 like = 6;
inline bool show_player_base::has_like() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void show_player_base::set_has_like() {
  _has_bits_[0] |= 0x00000010u;
}
inline void show_player_base::clear_has_like() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void show_player_base::clear_like() {
  like_ = 0u;
  clear_has_like();
}
inline ::google::protobuf::uint32 show_player_base::like() const {
  return like_;
}
inline void show_player_base::set_like(::google::protobuf::uint32 value) {
  set_has_like();
  like_ = value;
}

// optional uint32 title = 7;
inline bool show_player_base::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void show_player_base::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void show_player_base::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void show_player_base::clear_title() {
  title_ = 0u;
  clear_has_title();
}
inline ::google::protobuf::uint32 show_player_base::title() const {
  return title_;
}
inline void show_player_base::set_title(::google::protobuf::uint32 value) {
  set_has_title();
  title_ = value;
}

// optional uint64 partner_id = 8;
inline bool show_player_base::has_partner_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void show_player_base::set_has_partner_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void show_player_base::clear_has_partner_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void show_player_base::clear_partner_id() {
  partner_id_ = GOOGLE_ULONGLONG(0);
  clear_has_partner_id();
}
inline ::google::protobuf::uint64 show_player_base::partner_id() const {
  return partner_id_;
}
inline void show_player_base::set_partner_id(::google::protobuf::uint64 value) {
  set_has_partner_id();
  partner_id_ = value;
}

// optional string partner_name = 9;
inline bool show_player_base::has_partner_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void show_player_base::set_has_partner_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void show_player_base::clear_has_partner_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void show_player_base::clear_partner_name() {
  if (partner_name_ != &::google::protobuf::internal::kEmptyString) {
    partner_name_->clear();
  }
  clear_has_partner_name();
}
inline const ::std::string& show_player_base::partner_name() const {
  return *partner_name_;
}
inline void show_player_base::set_partner_name(const ::std::string& value) {
  set_has_partner_name();
  if (partner_name_ == &::google::protobuf::internal::kEmptyString) {
    partner_name_ = new ::std::string;
  }
  partner_name_->assign(value);
}
inline void show_player_base::set_partner_name(const char* value) {
  set_has_partner_name();
  if (partner_name_ == &::google::protobuf::internal::kEmptyString) {
    partner_name_ = new ::std::string;
  }
  partner_name_->assign(value);
}
inline void show_player_base::set_partner_name(const char* value, size_t size) {
  set_has_partner_name();
  if (partner_name_ == &::google::protobuf::internal::kEmptyString) {
    partner_name_ = new ::std::string;
  }
  partner_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* show_player_base::mutable_partner_name() {
  set_has_partner_name();
  if (partner_name_ == &::google::protobuf::internal::kEmptyString) {
    partner_name_ = new ::std::string;
  }
  return partner_name_;
}
inline ::std::string* show_player_base::release_partner_name() {
  clear_has_partner_name();
  if (partner_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partner_name_;
    partner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void show_player_base::set_allocated_partner_name(::std::string* partner_name) {
  if (partner_name_ != &::google::protobuf::internal::kEmptyString) {
    delete partner_name_;
  }
  if (partner_name) {
    set_has_partner_name();
    partner_name_ = partner_name;
  } else {
    clear_has_partner_name();
    partner_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 office = 10;
inline bool show_player_base::has_office() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void show_player_base::set_has_office() {
  _has_bits_[0] |= 0x00000100u;
}
inline void show_player_base::clear_has_office() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void show_player_base::clear_office() {
  office_ = 0u;
  clear_has_office();
}
inline ::google::protobuf::uint32 show_player_base::office() const {
  return office_;
}
inline void show_player_base::set_office(::google::protobuf::uint32 value) {
  set_has_office();
  office_ = value;
}

// optional uint64 fimily_id = 11;
inline bool show_player_base::has_fimily_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void show_player_base::set_has_fimily_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void show_player_base::clear_has_fimily_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void show_player_base::clear_fimily_id() {
  fimily_id_ = GOOGLE_ULONGLONG(0);
  clear_has_fimily_id();
}
inline ::google::protobuf::uint64 show_player_base::fimily_id() const {
  return fimily_id_;
}
inline void show_player_base::set_fimily_id(::google::protobuf::uint64 value) {
  set_has_fimily_id();
  fimily_id_ = value;
}

// optional string fimily_name = 12;
inline bool show_player_base::has_fimily_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void show_player_base::set_has_fimily_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void show_player_base::clear_has_fimily_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void show_player_base::clear_fimily_name() {
  if (fimily_name_ != &::google::protobuf::internal::kEmptyString) {
    fimily_name_->clear();
  }
  clear_has_fimily_name();
}
inline const ::std::string& show_player_base::fimily_name() const {
  return *fimily_name_;
}
inline void show_player_base::set_fimily_name(const ::std::string& value) {
  set_has_fimily_name();
  if (fimily_name_ == &::google::protobuf::internal::kEmptyString) {
    fimily_name_ = new ::std::string;
  }
  fimily_name_->assign(value);
}
inline void show_player_base::set_fimily_name(const char* value) {
  set_has_fimily_name();
  if (fimily_name_ == &::google::protobuf::internal::kEmptyString) {
    fimily_name_ = new ::std::string;
  }
  fimily_name_->assign(value);
}
inline void show_player_base::set_fimily_name(const char* value, size_t size) {
  set_has_fimily_name();
  if (fimily_name_ == &::google::protobuf::internal::kEmptyString) {
    fimily_name_ = new ::std::string;
  }
  fimily_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* show_player_base::mutable_fimily_name() {
  set_has_fimily_name();
  if (fimily_name_ == &::google::protobuf::internal::kEmptyString) {
    fimily_name_ = new ::std::string;
  }
  return fimily_name_;
}
inline ::std::string* show_player_base::release_fimily_name() {
  clear_has_fimily_name();
  if (fimily_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fimily_name_;
    fimily_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void show_player_base::set_allocated_fimily_name(::std::string* fimily_name) {
  if (fimily_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fimily_name_;
  }
  if (fimily_name) {
    set_has_fimily_name();
    fimily_name_ = fimily_name;
  } else {
    clear_has_fimily_name();
    fimily_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signature = 13;
inline bool show_player_base::has_signature() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void show_player_base::set_has_signature() {
  _has_bits_[0] |= 0x00000800u;
}
inline void show_player_base::clear_has_signature() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void show_player_base::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& show_player_base::signature() const {
  return *signature_;
}
inline void show_player_base::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void show_player_base::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void show_player_base::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* show_player_base::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* show_player_base::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void show_player_base::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.lsg_position_info position = 14;
inline bool show_player_base::has_position() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void show_player_base::set_has_position() {
  _has_bits_[0] |= 0x00001000u;
}
inline void show_player_base::clear_has_position() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void show_player_base::clear_position() {
  if (position_ != NULL) position_->::SProtoSpace::lsg_position_info::Clear();
  clear_has_position();
}
inline const ::SProtoSpace::lsg_position_info& show_player_base::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::SProtoSpace::lsg_position_info* show_player_base::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::SProtoSpace::lsg_position_info;
  return position_;
}
inline ::SProtoSpace::lsg_position_info* show_player_base::release_position() {
  clear_has_position();
  ::SProtoSpace::lsg_position_info* temp = position_;
  position_ = NULL;
  return temp;
}
inline void show_player_base::set_allocated_position(::SProtoSpace::lsg_position_info* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// repeated uint64 liked_list = 16;
inline int show_player_base::liked_list_size() const {
  return liked_list_.size();
}
inline void show_player_base::clear_liked_list() {
  liked_list_.Clear();
}
inline ::google::protobuf::uint64 show_player_base::liked_list(int index) const {
  return liked_list_.Get(index);
}
inline void show_player_base::set_liked_list(int index, ::google::protobuf::uint64 value) {
  liked_list_.Set(index, value);
}
inline void show_player_base::add_liked_list(::google::protobuf::uint64 value) {
  liked_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
show_player_base::liked_list() const {
  return liked_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
show_player_base::mutable_liked_list() {
  return &liked_list_;
}

// optional uint32 border = 18;
inline bool show_player_base::has_border() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void show_player_base::set_has_border() {
  _has_bits_[0] |= 0x00004000u;
}
inline void show_player_base::clear_has_border() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void show_player_base::clear_border() {
  border_ = 0u;
  clear_has_border();
}
inline ::google::protobuf::uint32 show_player_base::border() const {
  return border_;
}
inline void show_player_base::set_border(::google::protobuf::uint32 value) {
  set_has_border();
  border_ = value;
}

// optional .SProtoSpace.date_info birthday = 19;
inline bool show_player_base::has_birthday() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void show_player_base::set_has_birthday() {
  _has_bits_[0] |= 0x00008000u;
}
inline void show_player_base::clear_has_birthday() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void show_player_base::clear_birthday() {
  if (birthday_ != NULL) birthday_->::SProtoSpace::date_info::Clear();
  clear_has_birthday();
}
inline const ::SProtoSpace::date_info& show_player_base::birthday() const {
  return birthday_ != NULL ? *birthday_ : *default_instance_->birthday_;
}
inline ::SProtoSpace::date_info* show_player_base::mutable_birthday() {
  set_has_birthday();
  if (birthday_ == NULL) birthday_ = new ::SProtoSpace::date_info;
  return birthday_;
}
inline ::SProtoSpace::date_info* show_player_base::release_birthday() {
  clear_has_birthday();
  ::SProtoSpace::date_info* temp = birthday_;
  birthday_ = NULL;
  return temp;
}
inline void show_player_base::set_allocated_birthday(::SProtoSpace::date_info* birthday) {
  delete birthday_;
  birthday_ = birthday;
  if (birthday) {
    set_has_birthday();
  } else {
    clear_has_birthday();
  }
}

// optional uint32 star_sign = 20 [default = 1];
inline bool show_player_base::has_star_sign() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void show_player_base::set_has_star_sign() {
  _has_bits_[0] |= 0x00010000u;
}
inline void show_player_base::clear_has_star_sign() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void show_player_base::clear_star_sign() {
  star_sign_ = 1u;
  clear_has_star_sign();
}
inline ::google::protobuf::uint32 show_player_base::star_sign() const {
  return star_sign_;
}
inline void show_player_base::set_star_sign(::google::protobuf::uint32 value) {
  set_has_star_sign();
  star_sign_ = value;
}

// optional uint32 popularity = 21 [default = 0];
inline bool show_player_base::has_popularity() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void show_player_base::set_has_popularity() {
  _has_bits_[0] |= 0x00020000u;
}
inline void show_player_base::clear_has_popularity() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void show_player_base::clear_popularity() {
  popularity_ = 0u;
  clear_has_popularity();
}
inline ::google::protobuf::uint32 show_player_base::popularity() const {
  return popularity_;
}
inline void show_player_base::set_popularity(::google::protobuf::uint32 value) {
  set_has_popularity();
  popularity_ = value;
}

// optional uint32 charm = 22 [default = 0];
inline bool show_player_base::has_charm() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void show_player_base::set_has_charm() {
  _has_bits_[0] |= 0x00040000u;
}
inline void show_player_base::clear_has_charm() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void show_player_base::clear_charm() {
  charm_ = 0u;
  clear_has_charm();
}
inline ::google::protobuf::uint32 show_player_base::charm() const {
  return charm_;
}
inline void show_player_base::set_charm(::google::protobuf::uint32 value) {
  set_has_charm();
  charm_ = value;
}

// repeated uint32 labels = 23;
inline int show_player_base::labels_size() const {
  return labels_.size();
}
inline void show_player_base::clear_labels() {
  labels_.Clear();
}
inline ::google::protobuf::uint32 show_player_base::labels(int index) const {
  return labels_.Get(index);
}
inline void show_player_base::set_labels(int index, ::google::protobuf::uint32 value) {
  labels_.Set(index, value);
}
inline void show_player_base::add_labels(::google::protobuf::uint32 value) {
  labels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
show_player_base::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
show_player_base::mutable_labels() {
  return &labels_;
}

// optional int32 fight_value = 24;
inline bool show_player_base::has_fight_value() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void show_player_base::set_has_fight_value() {
  _has_bits_[0] |= 0x00100000u;
}
inline void show_player_base::clear_has_fight_value() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void show_player_base::clear_fight_value() {
  fight_value_ = 0;
  clear_has_fight_value();
}
inline ::google::protobuf::int32 show_player_base::fight_value() const {
  return fight_value_;
}
inline void show_player_base::set_fight_value(::google::protobuf::int32 value) {
  set_has_fight_value();
  fight_value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SProtoSpace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ECrossServerType>() {
  return ::SProtoSpace::ECrossServerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBattleType>() {
  return ::SProtoSpace::EBattleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EHeroFormationType>() {
  return ::SProtoSpace::EHeroFormationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EObjType>() {
  return ::SProtoSpace::EObjType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ECampType>() {
  return ::SProtoSpace::ECampType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EPlayerType>() {
  return ::SProtoSpace::EPlayerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ERoundOP>() {
  return ::SProtoSpace::ERoundOP_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ERoundDataType>() {
  return ::SProtoSpace::ERoundDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffDataType>() {
  return ::SProtoSpace::EBuffDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EStateDataType>() {
  return ::SProtoSpace::EStateDataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBattleTargetType>() {
  return ::SProtoSpace::EBattleTargetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EDamageType>() {
  return ::SProtoSpace::EDamageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffType>() {
  return ::SProtoSpace::EBuffType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffTriggerType>() {
  return ::SProtoSpace::EBuffTriggerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffReasonType>() {
  return ::SProtoSpace::EBuffReasonType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffEndType>() {
  return ::SProtoSpace::EBuffEndType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EStateType>() {
  return ::SProtoSpace::EStateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EGetValueType>() {
  return ::SProtoSpace::EGetValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EDispelBuffType>() {
  return ::SProtoSpace::EDispelBuffType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EMarkEffectType>() {
  return ::SProtoSpace::EMarkEffectType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ESeqOptType>() {
  return ::SProtoSpace::ESeqOptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EOptSeqTimeLine>() {
  return ::SProtoSpace::EOptSeqTimeLine_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ETriggerConditionClass>() {
  return ::SProtoSpace::ETriggerConditionClass_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ETriggerConditionAttrType>() {
  return ::SProtoSpace::ETriggerConditionAttrType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBuffEffectType>() {
  return ::SProtoSpace::EBuffEffectType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cm_5fbattletype_2eproto__INCLUDED
