// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cm_socialtype.proto

#ifndef PROTOBUF_cm_5fsocialtype_2eproto__INCLUDED
#define PROTOBUF_cm_5fsocialtype_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cm_battletype.pb.h"
#include "cm_roletype.pb.h"
// @@protoc_insertion_point(includes)

namespace SProtoSpace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

class friend_base_info;
class friend_apply_info;
class give_item_info;
class tribute_info;
class harem_compete_event;
class event_qingan_info;
class event_slap_info;
class event_tribute_info;
class slap_emoji_info;
class team_hero_slot;
class team_member_data;
class team_data;
class team_member_brief;
class team_brief;
class arena_item_data;
class emotion_base_info;
class emotion_like_info;
class emotion_comment_info;
class emotion_opt_info;
class emotion_info;
class show_emotion_all_info;
class label_info;
class barrage_role_info;
class barrage_single;
class barrage_pack;

enum EFriend_RETCODE {
  Friend_RET_SUCC = 0,
  FriendTP_RET_EXCEED_MAX_LIMIT = 1,
  FriendTP_RET_IN_BLACKLIST = 2,
  FriendTP_RET_IN_FRIENDLIST = 3,
  FriendTP_RET_TYPE_ERROR = 4,
  FriendTP_RET_UNKNOW = 5,
  FriendTP_RET_PATIAL = 6,
  FriendTP_RET_NOT_EXIST = 7,
  FriendTP_RET_HAS_APPLYED = 8,
  FriendTP_RET_OPT_SELF = 9,
  FriendTP_RET_BEEN_APPLYED = 10,
  FriendTP_RET_IN_OTHER_BLACKLIST = 11,
  FriendTP_RET_IN_APPLYING = 12,
  FriendTP_RET_APPLY_MAX_LIMIT = 13,
  FriendTP_RET_HAS_BEEN_GIVED = 14,
  GIVE_ERRCODE_INTER_FRIEND = 15,
  GIVE_ERRCODE_MAX_LIMIT = 16,
  GIVE_ERRCODE_HAS_GIVED = 17,
  FriendTP_RET_HIGH_FREQUENCY = 18
};
bool EFriend_RETCODE_IsValid(int value);
const EFriend_RETCODE EFriend_RETCODE_MIN = Friend_RET_SUCC;
const EFriend_RETCODE EFriend_RETCODE_MAX = FriendTP_RET_HIGH_FREQUENCY;
const int EFriend_RETCODE_ARRAYSIZE = EFriend_RETCODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFriend_RETCODE_descriptor();
inline const ::std::string& EFriend_RETCODE_Name(EFriend_RETCODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFriend_RETCODE_descriptor(), value);
}
inline bool EFriend_RETCODE_Parse(
    const ::std::string& name, EFriend_RETCODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFriend_RETCODE>(
    EFriend_RETCODE_descriptor(), name, value);
}
enum EFRIEND_OPT_TYPE {
  Friend_OPT_TP_AGREE = 1,
  Friend_OPT_TP_REFUSE = 2,
  FRIEND_OPT_TP_REMOVE_FRIEND = 3,
  FRIEND_OPT_TP_REMOVE_BLACK = 4,
  FRIEND_OPT_TP_GET_FRIEND = 5,
  FRIEND_OPT_TP_GET_BLACKLIST = 6,
  Friend_OPT_TP_APPLY = 7
};
bool EFRIEND_OPT_TYPE_IsValid(int value);
const EFRIEND_OPT_TYPE EFRIEND_OPT_TYPE_MIN = Friend_OPT_TP_AGREE;
const EFRIEND_OPT_TYPE EFRIEND_OPT_TYPE_MAX = Friend_OPT_TP_APPLY;
const int EFRIEND_OPT_TYPE_ARRAYSIZE = EFRIEND_OPT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFRIEND_OPT_TYPE_descriptor();
inline const ::std::string& EFRIEND_OPT_TYPE_Name(EFRIEND_OPT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFRIEND_OPT_TYPE_descriptor(), value);
}
inline bool EFRIEND_OPT_TYPE_Parse(
    const ::std::string& name, EFRIEND_OPT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFRIEND_OPT_TYPE>(
    EFRIEND_OPT_TYPE_descriptor(), name, value);
}
enum EFRINED_PROCESS_STATUS {
  FRINED_PROCESS_APPLYING = 0,
  FRINED_PROCESS_AGREE = 1,
  FRINED_PROCESS_REFUSE = 2,
  FRINED_PROCESS_END = 3
};
bool EFRINED_PROCESS_STATUS_IsValid(int value);
const EFRINED_PROCESS_STATUS EFRINED_PROCESS_STATUS_MIN = FRINED_PROCESS_APPLYING;
const EFRINED_PROCESS_STATUS EFRINED_PROCESS_STATUS_MAX = FRINED_PROCESS_END;
const int EFRINED_PROCESS_STATUS_ARRAYSIZE = EFRINED_PROCESS_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFRINED_PROCESS_STATUS_descriptor();
inline const ::std::string& EFRINED_PROCESS_STATUS_Name(EFRINED_PROCESS_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFRINED_PROCESS_STATUS_descriptor(), value);
}
inline bool EFRINED_PROCESS_STATUS_Parse(
    const ::std::string& name, EFRINED_PROCESS_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFRINED_PROCESS_STATUS>(
    EFRINED_PROCESS_STATUS_descriptor(), name, value);
}
enum ESEARCHTYPE {
  SEARCH_TYPE_UID = 0,
  SEARCH_TYPE_NAME = 1
};
bool ESEARCHTYPE_IsValid(int value);
const ESEARCHTYPE ESEARCHTYPE_MIN = SEARCH_TYPE_UID;
const ESEARCHTYPE ESEARCHTYPE_MAX = SEARCH_TYPE_NAME;
const int ESEARCHTYPE_ARRAYSIZE = ESEARCHTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESEARCHTYPE_descriptor();
inline const ::std::string& ESEARCHTYPE_Name(ESEARCHTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESEARCHTYPE_descriptor(), value);
}
inline bool ESEARCHTYPE_Parse(
    const ::std::string& name, ESEARCHTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESEARCHTYPE>(
    ESEARCHTYPE_descriptor(), name, value);
}
enum EGET_FRINED_DO_TYPE {
  Friend_Refresh = 0,
  Friend_Greeting = 1,
  Friend_Tribute = 2
};
bool EGET_FRINED_DO_TYPE_IsValid(int value);
const EGET_FRINED_DO_TYPE EGET_FRINED_DO_TYPE_MIN = Friend_Refresh;
const EGET_FRINED_DO_TYPE EGET_FRINED_DO_TYPE_MAX = Friend_Tribute;
const int EGET_FRINED_DO_TYPE_ARRAYSIZE = EGET_FRINED_DO_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGET_FRINED_DO_TYPE_descriptor();
inline const ::std::string& EGET_FRINED_DO_TYPE_Name(EGET_FRINED_DO_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGET_FRINED_DO_TYPE_descriptor(), value);
}
inline bool EGET_FRINED_DO_TYPE_Parse(
    const ::std::string& name, EGET_FRINED_DO_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGET_FRINED_DO_TYPE>(
    EGET_FRINED_DO_TYPE_descriptor(), name, value);
}
enum ESLAPPROGRESS {
  SLAP_NONE = 1,
  SLAP_FACE_SWOLLEN = 2,
  SLAP_STAMMER = 3,
  SLAP_PROHIBIT_TALK10 = 4
};
bool ESLAPPROGRESS_IsValid(int value);
const ESLAPPROGRESS ESLAPPROGRESS_MIN = SLAP_NONE;
const ESLAPPROGRESS ESLAPPROGRESS_MAX = SLAP_PROHIBIT_TALK10;
const int ESLAPPROGRESS_ARRAYSIZE = ESLAPPROGRESS_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESLAPPROGRESS_descriptor();
inline const ::std::string& ESLAPPROGRESS_Name(ESLAPPROGRESS value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESLAPPROGRESS_descriptor(), value);
}
inline bool ESLAPPROGRESS_Parse(
    const ::std::string& name, ESLAPPROGRESS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESLAPPROGRESS>(
    ESLAPPROGRESS_descriptor(), name, value);
}
enum EHAREMTYPE {
  HAREM_TP_SLAP = 1,
  HAREM_TP_GREETING = 2,
  HAREM_TP_TRIBUTE = 3
};
bool EHAREMTYPE_IsValid(int value);
const EHAREMTYPE EHAREMTYPE_MIN = HAREM_TP_SLAP;
const EHAREMTYPE EHAREMTYPE_MAX = HAREM_TP_TRIBUTE;
const int EHAREMTYPE_ARRAYSIZE = EHAREMTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHAREMTYPE_descriptor();
inline const ::std::string& EHAREMTYPE_Name(EHAREMTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHAREMTYPE_descriptor(), value);
}
inline bool EHAREMTYPE_Parse(
    const ::std::string& name, EHAREMTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHAREMTYPE>(
    EHAREMTYPE_descriptor(), name, value);
}
enum EHAREMSHARETYPE {
  HAREM_SHARE_TP_CHAT = 0,
  HAREM_SHARE_TP_WECHAT = 1,
  HAREM_SHARE_TP_OTHER = 2
};
bool EHAREMSHARETYPE_IsValid(int value);
const EHAREMSHARETYPE EHAREMSHARETYPE_MIN = HAREM_SHARE_TP_CHAT;
const EHAREMSHARETYPE EHAREMSHARETYPE_MAX = HAREM_SHARE_TP_OTHER;
const int EHAREMSHARETYPE_ARRAYSIZE = EHAREMSHARETYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EHAREMSHARETYPE_descriptor();
inline const ::std::string& EHAREMSHARETYPE_Name(EHAREMSHARETYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EHAREMSHARETYPE_descriptor(), value);
}
inline bool EHAREMSHARETYPE_Parse(
    const ::std::string& name, EHAREMSHARETYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHAREMSHARETYPE>(
    EHAREMSHARETYPE_descriptor(), name, value);
}
enum eWorldChatType {
  WORLD_CHAT_COMMON = 0,
  WORLD_CHAT_HAREM = 1,
  WORLD_CHAT_OFFICER = 2
};
bool eWorldChatType_IsValid(int value);
const eWorldChatType eWorldChatType_MIN = WORLD_CHAT_COMMON;
const eWorldChatType eWorldChatType_MAX = WORLD_CHAT_OFFICER;
const int eWorldChatType_ARRAYSIZE = eWorldChatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* eWorldChatType_descriptor();
inline const ::std::string& eWorldChatType_Name(eWorldChatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    eWorldChatType_descriptor(), value);
}
inline bool eWorldChatType_Parse(
    const ::std::string& name, eWorldChatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eWorldChatType>(
    eWorldChatType_descriptor(), name, value);
}
enum EmotionType {
  Emotion_TP_Person = 0,
  Emotion_TP_System = 1
};
bool EmotionType_IsValid(int value);
const EmotionType EmotionType_MIN = Emotion_TP_Person;
const EmotionType EmotionType_MAX = Emotion_TP_System;
const int EmotionType_ARRAYSIZE = EmotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmotionType_descriptor();
inline const ::std::string& EmotionType_Name(EmotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmotionType_descriptor(), value);
}
inline bool EmotionType_Parse(
    const ::std::string& name, EmotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmotionType>(
    EmotionType_descriptor(), name, value);
}
enum EBarrageDefine {
  EBARRAGE_SEGMENT_SIZE = 5,
  EBARRAGE_REQ_MAX_DESITY = 500,
  EBARRAGE_STRORAGE_ID_MAX_STACK = 5,
  EBARRAGE_LOCATION_ID_MAX_STACK = 3
};
bool EBarrageDefine_IsValid(int value);
const EBarrageDefine EBarrageDefine_MIN = EBARRAGE_LOCATION_ID_MAX_STACK;
const EBarrageDefine EBarrageDefine_MAX = EBARRAGE_REQ_MAX_DESITY;
const int EBarrageDefine_ARRAYSIZE = EBarrageDefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBarrageDefine_descriptor();
inline const ::std::string& EBarrageDefine_Name(EBarrageDefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBarrageDefine_descriptor(), value);
}
inline bool EBarrageDefine_Parse(
    const ::std::string& name, EBarrageDefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBarrageDefine>(
    EBarrageDefine_descriptor(), name, value);
}
// ===================================================================

class friend_base_info : public ::google::protobuf::Message {
 public:
  friend_base_info();
  virtual ~friend_base_info();

  friend_base_info(const friend_base_info& from);

  inline friend_base_info& operator=(const friend_base_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const friend_base_info& default_instance();

  void Swap(friend_base_info* other);

  // implements Message ----------------------------------------------

  friend_base_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const friend_base_info& from);
  void MergeFrom(const friend_base_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional uint64 login_time = 4;
  inline bool has_login_time() const;
  inline void clear_login_time();
  static const int kLoginTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 login_time() const;
  inline void set_login_time(::google::protobuf::uint64 value);

  // optional string position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional string avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional uint32 sex = 7;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 7;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 grade = 8;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 8;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // optional uint32 intimacy_value = 9;
  inline bool has_intimacy_value() const;
  inline void clear_intimacy_value();
  static const int kIntimacyValueFieldNumber = 9;
  inline ::google::protobuf::uint32 intimacy_value() const;
  inline void set_intimacy_value(::google::protobuf::uint32 value);

  // optional uint64 fight_power = 10;
  inline bool has_fight_power() const;
  inline void clear_fight_power();
  static const int kFightPowerFieldNumber = 10;
  inline ::google::protobuf::uint64 fight_power() const;
  inline void set_fight_power(::google::protobuf::uint64 value);

  // optional uint64 paixi_id = 11;
  inline bool has_paixi_id() const;
  inline void clear_paixi_id();
  static const int kPaixiIdFieldNumber = 11;
  inline ::google::protobuf::uint64 paixi_id() const;
  inline void set_paixi_id(::google::protobuf::uint64 value);

  // optional uint64 logout_time = 12;
  inline bool has_logout_time() const;
  inline void clear_logout_time();
  static const int kLogoutTimeFieldNumber = 12;
  inline ::google::protobuf::uint64 logout_time() const;
  inline void set_logout_time(::google::protobuf::uint64 value);

  // optional bool online = 13;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 13;
  inline bool online() const;
  inline void set_online(bool value);

  // optional int32 border = 14;
  inline bool has_border() const;
  inline void clear_border();
  static const int kBorderFieldNumber = 14;
  inline ::google::protobuf::int32 border() const;
  inline void set_border(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.friend_base_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_login_time();
  inline void clear_has_login_time();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_intimacy_value();
  inline void clear_has_intimacy_value();
  inline void set_has_fight_power();
  inline void clear_has_fight_power();
  inline void set_has_paixi_id();
  inline void clear_has_paixi_id();
  inline void set_has_logout_time();
  inline void clear_has_logout_time();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_border();
  inline void clear_has_border();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::google::protobuf::uint64 login_time_;
  ::std::string* position_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 sex_;
  ::std::string* avatar_;
  ::google::protobuf::uint32 grade_;
  ::google::protobuf::uint32 intimacy_value_;
  ::google::protobuf::uint64 fight_power_;
  ::google::protobuf::uint64 paixi_id_;
  ::google::protobuf::uint64 logout_time_;
  bool online_;
  ::google::protobuf::int32 border_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static friend_base_info* default_instance_;
};
// -------------------------------------------------------------------

class friend_apply_info : public ::google::protobuf::Message {
 public:
  friend_apply_info();
  virtual ~friend_apply_info();

  friend_apply_info(const friend_apply_info& from);

  inline friend_apply_info& operator=(const friend_apply_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const friend_apply_info& default_instance();

  void Swap(friend_apply_info* other);

  // implements Message ----------------------------------------------

  friend_apply_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const friend_apply_info& from);
  void MergeFrom(const friend_apply_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 apply_time = 1;
  inline bool has_apply_time() const;
  inline void clear_apply_time();
  static const int kApplyTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 apply_time() const;
  inline void set_apply_time(::google::protobuf::uint64 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional .SProtoSpace.friend_base_info infos = 3;
  inline bool has_infos() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::SProtoSpace::friend_base_info& infos() const;
  inline ::SProtoSpace::friend_base_info* mutable_infos();
  inline ::SProtoSpace::friend_base_info* release_infos();
  inline void set_allocated_infos(::SProtoSpace::friend_base_info* infos);

  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:SProtoSpace.friend_apply_info)
 private:
  inline void set_has_apply_time();
  inline void clear_has_apply_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_infos();
  inline void clear_has_infos();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 apply_time_;
  ::SProtoSpace::friend_base_info* infos_;
  ::std::string* content_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static friend_apply_info* default_instance_;
};
// -------------------------------------------------------------------

class give_item_info : public ::google::protobuf::Message {
 public:
  give_item_info();
  virtual ~give_item_info();

  give_item_info(const give_item_info& from);

  inline give_item_info& operator=(const give_item_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const give_item_info& default_instance();

  void Swap(give_item_info* other);

  // implements Message ----------------------------------------------

  give_item_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const give_item_info& from);
  void MergeFrom(const give_item_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint64 giver_id = 2;
  inline bool has_giver_id() const;
  inline void clear_giver_id();
  static const int kGiverIdFieldNumber = 2;
  inline ::google::protobuf::uint64 giver_id() const;
  inline void set_giver_id(::google::protobuf::uint64 value);

  // optional uint64 target_id = 3;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 3;
  inline ::google::protobuf::uint64 target_id() const;
  inline void set_target_id(::google::protobuf::uint64 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 item_id = 5;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 5;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.give_item_info)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_giver_id();
  inline void clear_has_giver_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 giver_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::uint32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static give_item_info* default_instance_;
};
// -------------------------------------------------------------------

class tribute_info : public ::google::protobuf::Message {
 public:
  tribute_info();
  virtual ~tribute_info();

  tribute_info(const tribute_info& from);

  inline tribute_info& operator=(const tribute_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tribute_info& default_instance();

  void Swap(tribute_info* other);

  // implements Message ----------------------------------------------

  tribute_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tribute_info& from);
  void MergeFrom(const tribute_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tribute_id = 1;
  inline bool has_tribute_id() const;
  inline void clear_tribute_id();
  static const int kTributeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 tribute_id() const;
  inline void set_tribute_id(::google::protobuf::uint32 value);

  // optional uint32 tribute_num = 2;
  inline bool has_tribute_num() const;
  inline void clear_tribute_num();
  static const int kTributeNumFieldNumber = 2;
  inline ::google::protobuf::uint32 tribute_num() const;
  inline void set_tribute_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.tribute_info)
 private:
  inline void set_has_tribute_id();
  inline void clear_has_tribute_id();
  inline void set_has_tribute_num();
  inline void clear_has_tribute_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tribute_id_;
  ::google::protobuf::uint32 tribute_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static tribute_info* default_instance_;
};
// -------------------------------------------------------------------

class harem_compete_event : public ::google::protobuf::Message {
 public:
  harem_compete_event();
  virtual ~harem_compete_event();

  harem_compete_event(const harem_compete_event& from);

  inline harem_compete_event& operator=(const harem_compete_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const harem_compete_event& default_instance();

  void Swap(harem_compete_event* other);

  // implements Message ----------------------------------------------

  harem_compete_event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const harem_compete_event& from);
  void MergeFrom(const harem_compete_event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 role_type = 3;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 role_type() const;
  inline void set_role_type(::google::protobuf::uint32 value);

  // optional .SProtoSpace.EHAREMTYPE type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::SProtoSpace::EHAREMTYPE type() const;
  inline void set_type(::SProtoSpace::EHAREMTYPE value);

  // optional uint64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // optional string avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional uint64 take_time = 7;
  inline bool has_take_time() const;
  inline void clear_take_time();
  static const int kTakeTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 take_time() const;
  inline void set_take_time(::google::protobuf::uint64 value);

  // optional uint32 slap_count = 8;
  inline bool has_slap_count() const;
  inline void clear_slap_count();
  static const int kSlapCountFieldNumber = 8;
  inline ::google::protobuf::uint32 slap_count() const;
  inline void set_slap_count(::google::protobuf::uint32 value);

  // optional .SProtoSpace.ESLAPPROGRESS progress = 9;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 9;
  inline ::SProtoSpace::ESLAPPROGRESS progress() const;
  inline void set_progress(::SProtoSpace::ESLAPPROGRESS value);

  // optional uint64 self_uuid = 10;
  inline bool has_self_uuid() const;
  inline void clear_self_uuid();
  static const int kSelfUuidFieldNumber = 10;
  inline ::google::protobuf::uint64 self_uuid() const;
  inline void set_self_uuid(::google::protobuf::uint64 value);

  // optional string self_name = 11;
  inline bool has_self_name() const;
  inline void clear_self_name();
  static const int kSelfNameFieldNumber = 11;
  inline const ::std::string& self_name() const;
  inline void set_self_name(const ::std::string& value);
  inline void set_self_name(const char* value);
  inline void set_self_name(const char* value, size_t size);
  inline ::std::string* mutable_self_name();
  inline ::std::string* release_self_name();
  inline void set_allocated_self_name(::std::string* self_name);

  // repeated .SProtoSpace.slap_emoji_info info = 12;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 12;
  inline const ::SProtoSpace::slap_emoji_info& info(int index) const;
  inline ::SProtoSpace::slap_emoji_info* mutable_info(int index);
  inline ::SProtoSpace::slap_emoji_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >*
      mutable_info();

  // optional .SProtoSpace.give_item_info tribute = 13;
  inline bool has_tribute() const;
  inline void clear_tribute();
  static const int kTributeFieldNumber = 13;
  inline const ::SProtoSpace::give_item_info& tribute() const;
  inline ::SProtoSpace::give_item_info* mutable_tribute();
  inline ::SProtoSpace::give_item_info* release_tribute();
  inline void set_allocated_tribute(::SProtoSpace::give_item_info* tribute);

  // optional uint64 event_uuid = 14;
  inline bool has_event_uuid() const;
  inline void clear_event_uuid();
  static const int kEventUuidFieldNumber = 14;
  inline ::google::protobuf::uint64 event_uuid() const;
  inline void set_event_uuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.harem_compete_event)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_type();
  inline void clear_has_role_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_take_time();
  inline void clear_has_take_time();
  inline void set_has_slap_count();
  inline void clear_has_slap_count();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_self_uuid();
  inline void clear_has_self_uuid();
  inline void set_has_self_name();
  inline void clear_has_self_name();
  inline void set_has_tribute();
  inline void clear_has_tribute();
  inline void set_has_event_uuid();
  inline void clear_has_event_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uuid_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 role_type_;
  int type_;
  ::google::protobuf::uint64 time_;
  ::std::string* avatar_;
  ::google::protobuf::uint64 take_time_;
  ::google::protobuf::uint32 slap_count_;
  int progress_;
  ::google::protobuf::uint64 self_uuid_;
  ::std::string* self_name_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info > info_;
  ::SProtoSpace::give_item_info* tribute_;
  ::google::protobuf::uint64 event_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static harem_compete_event* default_instance_;
};
// -------------------------------------------------------------------

class event_qingan_info : public ::google::protobuf::Message {
 public:
  event_qingan_info();
  virtual ~event_qingan_info();

  event_qingan_info(const event_qingan_info& from);

  inline event_qingan_info& operator=(const event_qingan_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const event_qingan_info& default_instance();

  void Swap(event_qingan_info* other);

  // implements Message ----------------------------------------------

  event_qingan_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const event_qingan_info& from);
  void MergeFrom(const event_qingan_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 role_type = 6;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 role_type() const;
  inline void set_role_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.event_qingan_info)
 private:
  inline void set_has_role_type();
  inline void clear_has_role_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static event_qingan_info* default_instance_;
};
// -------------------------------------------------------------------

class event_slap_info : public ::google::protobuf::Message {
 public:
  event_slap_info();
  virtual ~event_slap_info();

  event_slap_info(const event_slap_info& from);

  inline event_slap_info& operator=(const event_slap_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const event_slap_info& default_instance();

  void Swap(event_slap_info* other);

  // implements Message ----------------------------------------------

  event_slap_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const event_slap_info& from);
  void MergeFrom(const event_slap_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 role_type = 6;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 role_type() const;
  inline void set_role_type(::google::protobuf::uint32 value);

  // optional uint64 take_time = 8;
  inline bool has_take_time() const;
  inline void clear_take_time();
  static const int kTakeTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 take_time() const;
  inline void set_take_time(::google::protobuf::uint64 value);

  // optional uint32 slap_count = 9;
  inline bool has_slap_count() const;
  inline void clear_slap_count();
  static const int kSlapCountFieldNumber = 9;
  inline ::google::protobuf::uint32 slap_count() const;
  inline void set_slap_count(::google::protobuf::uint32 value);

  // optional .SProtoSpace.ESLAPPROGRESS progress = 10;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 10;
  inline ::SProtoSpace::ESLAPPROGRESS progress() const;
  inline void set_progress(::SProtoSpace::ESLAPPROGRESS value);

  // repeated .SProtoSpace.slap_emoji_info info = 11;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 11;
  inline const ::SProtoSpace::slap_emoji_info& info(int index) const;
  inline ::SProtoSpace::slap_emoji_info* mutable_info(int index);
  inline ::SProtoSpace::slap_emoji_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:SProtoSpace.event_slap_info)
 private:
  inline void set_has_role_type();
  inline void clear_has_role_type();
  inline void set_has_take_time();
  inline void clear_has_take_time();
  inline void set_has_slap_count();
  inline void clear_has_slap_count();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 take_time_;
  ::google::protobuf::uint32 role_type_;
  ::google::protobuf::uint32 slap_count_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info > info_;
  int progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static event_slap_info* default_instance_;
};
// -------------------------------------------------------------------

class event_tribute_info : public ::google::protobuf::Message {
 public:
  event_tribute_info();
  virtual ~event_tribute_info();

  event_tribute_info(const event_tribute_info& from);

  inline event_tribute_info& operator=(const event_tribute_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const event_tribute_info& default_instance();

  void Swap(event_tribute_info* other);

  // implements Message ----------------------------------------------

  event_tribute_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const event_tribute_info& from);
  void MergeFrom(const event_tribute_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 role_type = 6;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 role_type() const;
  inline void set_role_type(::google::protobuf::uint32 value);

  // optional uint32 item_id = 8;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 8;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 count = 9;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 9;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional string content = 10;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 10;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:SProtoSpace.event_tribute_info)
 private:
  inline void set_has_role_type();
  inline void clear_has_role_type();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 role_type_;
  ::google::protobuf::uint32 item_id_;
  ::std::string* content_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static event_tribute_info* default_instance_;
};
// -------------------------------------------------------------------

class slap_emoji_info : public ::google::protobuf::Message {
 public:
  slap_emoji_info();
  virtual ~slap_emoji_info();

  slap_emoji_info(const slap_emoji_info& from);

  inline slap_emoji_info& operator=(const slap_emoji_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const slap_emoji_info& default_instance();

  void Swap(slap_emoji_info* other);

  // implements Message ----------------------------------------------

  slap_emoji_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const slap_emoji_info& from);
  void MergeFrom(const slap_emoji_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 slot_index = 1;
  inline bool has_slot_index() const;
  inline void clear_slot_index();
  static const int kSlotIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 slot_index() const;
  inline void set_slot_index(::google::protobuf::uint32 value);

  // optional uint32 emoji_id = 2;
  inline bool has_emoji_id() const;
  inline void clear_emoji_id();
  static const int kEmojiIdFieldNumber = 2;
  inline ::google::protobuf::uint32 emoji_id() const;
  inline void set_emoji_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.slap_emoji_info)
 private:
  inline void set_has_slot_index();
  inline void clear_has_slot_index();
  inline void set_has_emoji_id();
  inline void clear_has_emoji_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 slot_index_;
  ::google::protobuf::uint32 emoji_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static slap_emoji_info* default_instance_;
};
// -------------------------------------------------------------------

class team_hero_slot : public ::google::protobuf::Message {
 public:
  team_hero_slot();
  virtual ~team_hero_slot();

  team_hero_slot(const team_hero_slot& from);

  inline team_hero_slot& operator=(const team_hero_slot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const team_hero_slot& default_instance();

  void Swap(team_hero_slot* other);

  // implements Message ----------------------------------------------

  team_hero_slot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const team_hero_slot& from);
  void MergeFrom(const team_hero_slot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 slot = 1;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 1;
  inline ::google::protobuf::uint32 slot() const;
  inline void set_slot(::google::protobuf::uint32 value);

  // optional .SProtoSpace.battle_hero_info hero = 2;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 2;
  inline const ::SProtoSpace::battle_hero_info& hero() const;
  inline ::SProtoSpace::battle_hero_info* mutable_hero();
  inline ::SProtoSpace::battle_hero_info* release_hero();
  inline void set_allocated_hero(::SProtoSpace::battle_hero_info* hero);

  // @@protoc_insertion_point(class_scope:SProtoSpace.team_hero_slot)
 private:
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_hero();
  inline void clear_has_hero();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::battle_hero_info* hero_;
  ::google::protobuf::uint32 slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static team_hero_slot* default_instance_;
};
// -------------------------------------------------------------------

class team_member_data : public ::google::protobuf::Message {
 public:
  team_member_data();
  virtual ~team_member_data();

  team_member_data(const team_member_data& from);

  inline team_member_data& operator=(const team_member_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const team_member_data& default_instance();

  void Swap(team_member_data* other);

  // implements Message ----------------------------------------------

  team_member_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const team_member_data& from);
  void MergeFrom(const team_member_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional bool leader = 2;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 2;
  inline bool leader() const;
  inline void set_leader(bool value);

  // optional uint64 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // repeated .SProtoSpace.team_hero_slot heros = 6;
  inline int heros_size() const;
  inline void clear_heros();
  static const int kHerosFieldNumber = 6;
  inline const ::SProtoSpace::team_hero_slot& heros(int index) const;
  inline ::SProtoSpace::team_hero_slot* mutable_heros(int index);
  inline ::SProtoSpace::team_hero_slot* add_heros();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_hero_slot >&
      heros() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_hero_slot >*
      mutable_heros();

  // @@protoc_insertion_point(class_scope:SProtoSpace.team_member_data)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  bool leader_;
  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_hero_slot > heros_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static team_member_data* default_instance_;
};
// -------------------------------------------------------------------

class team_data : public ::google::protobuf::Message {
 public:
  team_data();
  virtual ~team_data();

  team_data(const team_data& from);

  inline team_data& operator=(const team_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const team_data& default_instance();

  void Swap(team_data* other);

  // implements Message ----------------------------------------------

  team_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const team_data& from);
  void MergeFrom(const team_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 team_id() const;
  inline void set_team_id(::google::protobuf::uint64 value);

  // optional .SProtoSpace.eTeamType team_type = 2;
  inline bool has_team_type() const;
  inline void clear_team_type();
  static const int kTeamTypeFieldNumber = 2;
  inline ::SProtoSpace::eTeamType team_type() const;
  inline void set_team_type(::SProtoSpace::eTeamType value);

  // optional .SProtoSpace.eTeamSize team_size = 3;
  inline bool has_team_size() const;
  inline void clear_team_size();
  static const int kTeamSizeFieldNumber = 3;
  inline ::SProtoSpace::eTeamSize team_size() const;
  inline void set_team_size(::SProtoSpace::eTeamSize value);

  // optional .SProtoSpace.eTeamPermission team_perm = 4;
  inline bool has_team_perm() const;
  inline void clear_team_perm();
  static const int kTeamPermFieldNumber = 4;
  inline ::SProtoSpace::eTeamPermission team_perm() const;
  inline void set_team_perm(::SProtoSpace::eTeamPermission value);

  // optional int32 create_time = 5;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional string team_name = 6;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 6;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // repeated .SProtoSpace.team_member_data members = 7;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 7;
  inline const ::SProtoSpace::team_member_data& members(int index) const;
  inline ::SProtoSpace::team_member_data* mutable_members(int index);
  inline ::SProtoSpace::team_member_data* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_data >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_data >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:SProtoSpace.team_data)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_team_type();
  inline void clear_has_team_type();
  inline void set_has_team_size();
  inline void clear_has_team_size();
  inline void set_has_team_perm();
  inline void clear_has_team_perm();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_team_name();
  inline void clear_has_team_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 team_id_;
  int team_type_;
  int team_size_;
  int team_perm_;
  ::google::protobuf::int32 create_time_;
  ::std::string* team_name_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_data > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static team_data* default_instance_;
};
// -------------------------------------------------------------------

class team_member_brief : public ::google::protobuf::Message {
 public:
  team_member_brief();
  virtual ~team_member_brief();

  team_member_brief(const team_member_brief& from);

  inline team_member_brief& operator=(const team_member_brief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const team_member_brief& default_instance();

  void Swap(team_member_brief* other);

  // implements Message ----------------------------------------------

  team_member_brief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const team_member_brief& from);
  void MergeFrom(const team_member_brief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 slot = 1;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 1;
  inline ::google::protobuf::uint32 slot() const;
  inline void set_slot(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 head_id = 3;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 3;
  inline ::google::protobuf::uint32 head_id() const;
  inline void set_head_id(::google::protobuf::uint32 value);

  // optional uint32 lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.team_member_brief)
 private:
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head_id();
  inline void clear_has_head_id();
  inline void set_has_lv();
  inline void clear_has_lv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 slot_;
  ::google::protobuf::uint32 head_id_;
  ::google::protobuf::uint32 lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static team_member_brief* default_instance_;
};
// -------------------------------------------------------------------

class team_brief : public ::google::protobuf::Message {
 public:
  team_brief();
  virtual ~team_brief();

  team_brief(const team_brief& from);

  inline team_brief& operator=(const team_brief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const team_brief& default_instance();

  void Swap(team_brief* other);

  // implements Message ----------------------------------------------

  team_brief* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const team_brief& from);
  void MergeFrom(const team_brief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline ::google::protobuf::uint64 team_id() const;
  inline void set_team_id(::google::protobuf::uint64 value);

  // optional .SProtoSpace.eTeamType team_type = 2;
  inline bool has_team_type() const;
  inline void clear_team_type();
  static const int kTeamTypeFieldNumber = 2;
  inline ::SProtoSpace::eTeamType team_type() const;
  inline void set_team_type(::SProtoSpace::eTeamType value);

  // optional .SProtoSpace.eTeamSize team_size = 3;
  inline bool has_team_size() const;
  inline void clear_team_size();
  static const int kTeamSizeFieldNumber = 3;
  inline ::SProtoSpace::eTeamSize team_size() const;
  inline void set_team_size(::SProtoSpace::eTeamSize value);

  // optional .SProtoSpace.eTeamPermission team_perm = 4;
  inline bool has_team_perm() const;
  inline void clear_team_perm();
  static const int kTeamPermFieldNumber = 4;
  inline ::SProtoSpace::eTeamPermission team_perm() const;
  inline void set_team_perm(::SProtoSpace::eTeamPermission value);

  // repeated .SProtoSpace.team_member_brief tm_brief = 5;
  inline int tm_brief_size() const;
  inline void clear_tm_brief();
  static const int kTmBriefFieldNumber = 5;
  inline const ::SProtoSpace::team_member_brief& tm_brief(int index) const;
  inline ::SProtoSpace::team_member_brief* mutable_tm_brief(int index);
  inline ::SProtoSpace::team_member_brief* add_tm_brief();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_brief >&
      tm_brief() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_brief >*
      mutable_tm_brief();

  // @@protoc_insertion_point(class_scope:SProtoSpace.team_brief)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_team_type();
  inline void clear_has_team_type();
  inline void set_has_team_size();
  inline void clear_has_team_size();
  inline void set_has_team_perm();
  inline void clear_has_team_perm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 team_id_;
  int team_type_;
  int team_size_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_brief > tm_brief_;
  int team_perm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static team_brief* default_instance_;
};
// -------------------------------------------------------------------

class arena_item_data : public ::google::protobuf::Message {
 public:
  arena_item_data();
  virtual ~arena_item_data();

  arena_item_data(const arena_item_data& from);

  inline arena_item_data& operator=(const arena_item_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_item_data& default_instance();

  void Swap(arena_item_data* other);

  // implements Message ----------------------------------------------

  arena_item_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_item_data& from);
  void MergeFrom(const arena_item_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional int32 max_grade = 2;
  inline bool has_max_grade() const;
  inline void clear_max_grade();
  static const int kMaxGradeFieldNumber = 2;
  inline ::google::protobuf::int32 max_grade() const;
  inline void set_max_grade(::google::protobuf::int32 value);

  // optional .SProtoSpace.battle_role_info battle_data = 3;
  inline bool has_battle_data() const;
  inline void clear_battle_data();
  static const int kBattleDataFieldNumber = 3;
  inline const ::SProtoSpace::battle_role_info& battle_data() const;
  inline ::SProtoSpace::battle_role_info* mutable_battle_data();
  inline ::SProtoSpace::battle_role_info* release_battle_data();
  inline void set_allocated_battle_data(::SProtoSpace::battle_role_info* battle_data);

  // @@protoc_insertion_point(class_scope:SProtoSpace.arena_item_data)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_max_grade();
  inline void clear_has_max_grade();
  inline void set_has_battle_data();
  inline void clear_has_battle_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  ::SProtoSpace::battle_role_info* battle_data_;
  ::google::protobuf::int32 max_grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static arena_item_data* default_instance_;
};
// -------------------------------------------------------------------

class emotion_base_info : public ::google::protobuf::Message {
 public:
  emotion_base_info();
  virtual ~emotion_base_info();

  emotion_base_info(const emotion_base_info& from);

  inline emotion_base_info& operator=(const emotion_base_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emotion_base_info& default_instance();

  void Swap(emotion_base_info* other);

  // implements Message ----------------------------------------------

  emotion_base_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emotion_base_info& from);
  void MergeFrom(const emotion_base_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 create_time = 2;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 show_role_id = 4;
  inline bool has_show_role_id() const;
  inline void clear_show_role_id();
  static const int kShowRoleIdFieldNumber = 4;
  inline ::google::protobuf::uint64 show_role_id() const;
  inline void set_show_role_id(::google::protobuf::uint64 value);

  // optional string msg_content = 5;
  inline bool has_msg_content() const;
  inline void clear_msg_content();
  static const int kMsgContentFieldNumber = 5;
  inline const ::std::string& msg_content() const;
  inline void set_msg_content(const ::std::string& value);
  inline void set_msg_content(const char* value);
  inline void set_msg_content(const char* value, size_t size);
  inline ::std::string* mutable_msg_content();
  inline ::std::string* release_msg_content();
  inline void set_allocated_msg_content(::std::string* msg_content);

  // repeated string img_urls = 6;
  inline int img_urls_size() const;
  inline void clear_img_urls();
  static const int kImgUrlsFieldNumber = 6;
  inline const ::std::string& img_urls(int index) const;
  inline ::std::string* mutable_img_urls(int index);
  inline void set_img_urls(int index, const ::std::string& value);
  inline void set_img_urls(int index, const char* value);
  inline void set_img_urls(int index, const char* value, size_t size);
  inline ::std::string* add_img_urls();
  inline void add_img_urls(const ::std::string& value);
  inline void add_img_urls(const char* value);
  inline void add_img_urls(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& img_urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_img_urls();

  // optional .SProtoSpace.EmotionType type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::SProtoSpace::EmotionType type() const;
  inline void set_type(::SProtoSpace::EmotionType value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.emotion_base_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_show_role_id();
  inline void clear_has_show_role_id();
  inline void set_has_msg_content();
  inline void clear_has_msg_content();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 create_time_;
  ::google::protobuf::uint64 show_role_id_;
  ::std::string* msg_content_;
  ::google::protobuf::uint32 status_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> img_urls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static emotion_base_info* default_instance_;
};
// -------------------------------------------------------------------

class emotion_like_info : public ::google::protobuf::Message {
 public:
  emotion_like_info();
  virtual ~emotion_like_info();

  emotion_like_info(const emotion_like_info& from);

  inline emotion_like_info& operator=(const emotion_like_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emotion_like_info& default_instance();

  void Swap(emotion_like_info* other);

  // implements Message ----------------------------------------------

  emotion_like_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emotion_like_info& from);
  void MergeFrom(const emotion_like_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint64 like_time = 3;
  inline bool has_like_time() const;
  inline void clear_like_time();
  static const int kLikeTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 like_time() const;
  inline void set_like_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.emotion_like_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_like_time();
  inline void clear_has_like_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  ::std::string* role_name_;
  ::google::protobuf::uint64 like_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static emotion_like_info* default_instance_;
};
// -------------------------------------------------------------------

class emotion_comment_info : public ::google::protobuf::Message {
 public:
  emotion_comment_info();
  virtual ~emotion_comment_info();

  emotion_comment_info(const emotion_comment_info& from);

  inline emotion_comment_info& operator=(const emotion_comment_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emotion_comment_info& default_instance();

  void Swap(emotion_comment_info* other);

  // implements Message ----------------------------------------------

  emotion_comment_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emotion_comment_info& from);
  void MergeFrom(const emotion_comment_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 create_time = 2;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 from_id = 4;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 4;
  inline ::google::protobuf::uint64 from_id() const;
  inline void set_from_id(::google::protobuf::uint64 value);

  // optional string from_name = 5;
  inline bool has_from_name() const;
  inline void clear_from_name();
  static const int kFromNameFieldNumber = 5;
  inline const ::std::string& from_name() const;
  inline void set_from_name(const ::std::string& value);
  inline void set_from_name(const char* value);
  inline void set_from_name(const char* value, size_t size);
  inline ::std::string* mutable_from_name();
  inline ::std::string* release_from_name();
  inline void set_allocated_from_name(::std::string* from_name);

  // optional uint64 to_id = 6;
  inline bool has_to_id() const;
  inline void clear_to_id();
  static const int kToIdFieldNumber = 6;
  inline ::google::protobuf::uint64 to_id() const;
  inline void set_to_id(::google::protobuf::uint64 value);

  // optional string to_name = 7;
  inline bool has_to_name() const;
  inline void clear_to_name();
  static const int kToNameFieldNumber = 7;
  inline const ::std::string& to_name() const;
  inline void set_to_name(const ::std::string& value);
  inline void set_to_name(const char* value);
  inline void set_to_name(const char* value, size_t size);
  inline ::std::string* mutable_to_name();
  inline ::std::string* release_to_name();
  inline void set_allocated_to_name(::std::string* to_name);

  // optional string msg_content = 8;
  inline bool has_msg_content() const;
  inline void clear_msg_content();
  static const int kMsgContentFieldNumber = 8;
  inline const ::std::string& msg_content() const;
  inline void set_msg_content(const ::std::string& value);
  inline void set_msg_content(const char* value);
  inline void set_msg_content(const char* value, size_t size);
  inline ::std::string* mutable_msg_content();
  inline ::std::string* release_msg_content();
  inline void set_allocated_msg_content(::std::string* msg_content);

  // @@protoc_insertion_point(class_scope:SProtoSpace.emotion_comment_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_from_name();
  inline void clear_has_from_name();
  inline void set_has_to_id();
  inline void clear_has_to_id();
  inline void set_has_to_name();
  inline void clear_has_to_name();
  inline void set_has_msg_content();
  inline void clear_has_msg_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 create_time_;
  ::google::protobuf::uint64 from_id_;
  ::std::string* from_name_;
  ::google::protobuf::uint64 to_id_;
  ::std::string* to_name_;
  ::std::string* msg_content_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static emotion_comment_info* default_instance_;
};
// -------------------------------------------------------------------

class emotion_opt_info : public ::google::protobuf::Message {
 public:
  emotion_opt_info();
  virtual ~emotion_opt_info();

  emotion_opt_info(const emotion_opt_info& from);

  inline emotion_opt_info& operator=(const emotion_opt_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emotion_opt_info& default_instance();

  void Swap(emotion_opt_info* other);

  // implements Message ----------------------------------------------

  emotion_opt_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emotion_opt_info& from);
  void MergeFrom(const emotion_opt_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 like_num = 1 [default = 0];
  inline bool has_like_num() const;
  inline void clear_like_num();
  static const int kLikeNumFieldNumber = 1;
  inline ::google::protobuf::int32 like_num() const;
  inline void set_like_num(::google::protobuf::int32 value);

  // optional int32 comment_num = 2 [default = 0];
  inline bool has_comment_num() const;
  inline void clear_comment_num();
  static const int kCommentNumFieldNumber = 2;
  inline ::google::protobuf::int32 comment_num() const;
  inline void set_comment_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.emotion_opt_info)
 private:
  inline void set_has_like_num();
  inline void clear_has_like_num();
  inline void set_has_comment_num();
  inline void clear_has_comment_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 like_num_;
  ::google::protobuf::int32 comment_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static emotion_opt_info* default_instance_;
};
// -------------------------------------------------------------------

class emotion_info : public ::google::protobuf::Message {
 public:
  emotion_info();
  virtual ~emotion_info();

  emotion_info(const emotion_info& from);

  inline emotion_info& operator=(const emotion_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emotion_info& default_instance();

  void Swap(emotion_info* other);

  // implements Message ----------------------------------------------

  emotion_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emotion_info& from);
  void MergeFrom(const emotion_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.emotion_base_info base_info = 1;
  inline bool has_base_info() const;
  inline void clear_base_info();
  static const int kBaseInfoFieldNumber = 1;
  inline const ::SProtoSpace::emotion_base_info& base_info() const;
  inline ::SProtoSpace::emotion_base_info* mutable_base_info();
  inline ::SProtoSpace::emotion_base_info* release_base_info();
  inline void set_allocated_base_info(::SProtoSpace::emotion_base_info* base_info);

  // repeated .SProtoSpace.emotion_like_info like_info = 2;
  inline int like_info_size() const;
  inline void clear_like_info();
  static const int kLikeInfoFieldNumber = 2;
  inline const ::SProtoSpace::emotion_like_info& like_info(int index) const;
  inline ::SProtoSpace::emotion_like_info* mutable_like_info(int index);
  inline ::SProtoSpace::emotion_like_info* add_like_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_like_info >&
      like_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_like_info >*
      mutable_like_info();

  // repeated .SProtoSpace.emotion_comment_info comment = 3;
  inline int comment_size() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::SProtoSpace::emotion_comment_info& comment(int index) const;
  inline ::SProtoSpace::emotion_comment_info* mutable_comment(int index);
  inline ::SProtoSpace::emotion_comment_info* add_comment();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_comment_info >&
      comment() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_comment_info >*
      mutable_comment();

  // optional .SProtoSpace.emotion_opt_info opt_info = 4;
  inline bool has_opt_info() const;
  inline void clear_opt_info();
  static const int kOptInfoFieldNumber = 4;
  inline const ::SProtoSpace::emotion_opt_info& opt_info() const;
  inline ::SProtoSpace::emotion_opt_info* mutable_opt_info();
  inline ::SProtoSpace::emotion_opt_info* release_opt_info();
  inline void set_allocated_opt_info(::SProtoSpace::emotion_opt_info* opt_info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.emotion_info)
 private:
  inline void set_has_base_info();
  inline void clear_has_base_info();
  inline void set_has_opt_info();
  inline void clear_has_opt_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::emotion_base_info* base_info_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_like_info > like_info_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_comment_info > comment_;
  ::SProtoSpace::emotion_opt_info* opt_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static emotion_info* default_instance_;
};
// -------------------------------------------------------------------

class show_emotion_all_info : public ::google::protobuf::Message {
 public:
  show_emotion_all_info();
  virtual ~show_emotion_all_info();

  show_emotion_all_info(const show_emotion_all_info& from);

  inline show_emotion_all_info& operator=(const show_emotion_all_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const show_emotion_all_info& default_instance();

  void Swap(show_emotion_all_info* other);

  // implements Message ----------------------------------------------

  show_emotion_all_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const show_emotion_all_info& from);
  void MergeFrom(const show_emotion_all_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.emotion_info eminfo = 1;
  inline int eminfo_size() const;
  inline void clear_eminfo();
  static const int kEminfoFieldNumber = 1;
  inline const ::SProtoSpace::emotion_info& eminfo(int index) const;
  inline ::SProtoSpace::emotion_info* mutable_eminfo(int index);
  inline ::SProtoSpace::emotion_info* add_eminfo();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_info >&
      eminfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_info >*
      mutable_eminfo();

  // @@protoc_insertion_point(class_scope:SProtoSpace.show_emotion_all_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_info > eminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static show_emotion_all_info* default_instance_;
};
// -------------------------------------------------------------------

class label_info : public ::google::protobuf::Message {
 public:
  label_info();
  virtual ~label_info();

  label_info(const label_info& from);

  inline label_info& operator=(const label_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const label_info& default_instance();

  void Swap(label_info* other);

  // implements Message ----------------------------------------------

  label_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const label_info& from);
  void MergeFrom(const label_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 label_class = 1;
  inline bool has_label_class() const;
  inline void clear_label_class();
  static const int kLabelClassFieldNumber = 1;
  inline ::google::protobuf::uint32 label_class() const;
  inline void set_label_class(::google::protobuf::uint32 value);

  // optional uint32 label_config_id = 2;
  inline bool has_label_config_id() const;
  inline void clear_label_config_id();
  static const int kLabelConfigIdFieldNumber = 2;
  inline ::google::protobuf::uint32 label_config_id() const;
  inline void set_label_config_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.label_info)
 private:
  inline void set_has_label_class();
  inline void clear_has_label_class();
  inline void set_has_label_config_id();
  inline void clear_has_label_config_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 label_class_;
  ::google::protobuf::uint32 label_config_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static label_info* default_instance_;
};
// -------------------------------------------------------------------

class barrage_role_info : public ::google::protobuf::Message {
 public:
  barrage_role_info();
  virtual ~barrage_role_info();

  barrage_role_info(const barrage_role_info& from);

  inline barrage_role_info& operator=(const barrage_role_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const barrage_role_info& default_instance();

  void Swap(barrage_role_info* other);

  // implements Message ----------------------------------------------

  barrage_role_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const barrage_role_info& from);
  void MergeFrom(const barrage_role_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint64 role_id() const;
  inline void set_role_id(::google::protobuf::uint64 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional int32 role_lv = 3;
  inline bool has_role_lv() const;
  inline void clear_role_lv();
  static const int kRoleLvFieldNumber = 3;
  inline ::google::protobuf::int32 role_lv() const;
  inline void set_role_lv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.barrage_role_info)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_lv();
  inline void clear_has_role_lv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 role_id_;
  ::std::string* role_name_;
  ::google::protobuf::int32 role_lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static barrage_role_info* default_instance_;
};
// -------------------------------------------------------------------

class barrage_single : public ::google::protobuf::Message {
 public:
  barrage_single();
  virtual ~barrage_single();

  barrage_single(const barrage_single& from);

  inline barrage_single& operator=(const barrage_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const barrage_single& default_instance();

  void Swap(barrage_single* other);

  // implements Message ----------------------------------------------

  barrage_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const barrage_single& from);
  void MergeFrom(const barrage_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint32 color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // repeated int32 location = 4;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline ::google::protobuf::int32 location(int index) const;
  inline void set_location(int index, ::google::protobuf::int32 value);
  inline void add_location(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      location() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_location();

  // optional .SProtoSpace.barrage_role_info role_info = 10;
  inline bool has_role_info() const;
  inline void clear_role_info();
  static const int kRoleInfoFieldNumber = 10;
  inline const ::SProtoSpace::barrage_role_info& role_info() const;
  inline ::SProtoSpace::barrage_role_info* mutable_role_info();
  inline ::SProtoSpace::barrage_role_info* release_role_info();
  inline void set_allocated_role_info(::SProtoSpace::barrage_role_info* role_info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.barrage_single)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_role_info();
  inline void clear_has_role_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  float time_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > location_;
  ::SProtoSpace::barrage_role_info* role_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static barrage_single* default_instance_;
};
// -------------------------------------------------------------------

class barrage_pack : public ::google::protobuf::Message {
 public:
  barrage_pack();
  virtual ~barrage_pack();

  barrage_pack(const barrage_pack& from);

  inline barrage_pack& operator=(const barrage_pack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const barrage_pack& default_instance();

  void Swap(barrage_pack* other);

  // implements Message ----------------------------------------------

  barrage_pack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const barrage_pack& from);
  void MergeFrom(const barrage_pack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SProtoSpace.barrage_single barrage = 1;
  inline int barrage_size() const;
  inline void clear_barrage();
  static const int kBarrageFieldNumber = 1;
  inline const ::SProtoSpace::barrage_single& barrage(int index) const;
  inline ::SProtoSpace::barrage_single* mutable_barrage(int index);
  inline ::SProtoSpace::barrage_single* add_barrage();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::barrage_single >&
      barrage() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::barrage_single >*
      mutable_barrage();

  // repeated int32 storage_id = 2;
  inline int storage_id_size() const;
  inline void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  inline ::google::protobuf::int32 storage_id(int index) const;
  inline void set_storage_id(int index, ::google::protobuf::int32 value);
  inline void add_storage_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      storage_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_storage_id();

  // optional int32 desinty = 3;
  inline bool has_desinty() const;
  inline void clear_desinty();
  static const int kDesintyFieldNumber = 3;
  inline ::google::protobuf::int32 desinty() const;
  inline void set_desinty(::google::protobuf::int32 value);

  // optional int32 start = 5;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 5;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 6;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 6;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.barrage_pack)
 private:
  inline void set_has_desinty();
  inline void clear_has_desinty();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::barrage_single > barrage_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > storage_id_;
  ::google::protobuf::int32 desinty_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_AssignDesc_cm_5fsocialtype_2eproto();
  friend void protobuf_ShutdownFile_cm_5fsocialtype_2eproto();

  void InitAsDefaultInstance();
  static barrage_pack* default_instance_;
};
// ===================================================================


// ===================================================================

// friend_base_info

// optional uint64 id = 1;
inline bool friend_base_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void friend_base_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void friend_base_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void friend_base_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 friend_base_info::id() const {
  return id_;
}
inline void friend_base_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool friend_base_info::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void friend_base_info::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void friend_base_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void friend_base_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& friend_base_info::name() const {
  return *name_;
}
inline void friend_base_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void friend_base_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void friend_base_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* friend_base_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* friend_base_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void friend_base_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 lv = 3;
inline bool friend_base_info::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void friend_base_info::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void friend_base_info::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void friend_base_info::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 friend_base_info::lv() const {
  return lv_;
}
inline void friend_base_info::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional uint64 login_time = 4;
inline bool friend_base_info::has_login_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void friend_base_info::set_has_login_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void friend_base_info::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void friend_base_info::clear_login_time() {
  login_time_ = GOOGLE_ULONGLONG(0);
  clear_has_login_time();
}
inline ::google::protobuf::uint64 friend_base_info::login_time() const {
  return login_time_;
}
inline void friend_base_info::set_login_time(::google::protobuf::uint64 value) {
  set_has_login_time();
  login_time_ = value;
}

// optional string position = 5;
inline bool friend_base_info::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void friend_base_info::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void friend_base_info::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void friend_base_info::clear_position() {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& friend_base_info::position() const {
  return *position_;
}
inline void friend_base_info::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void friend_base_info::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(value);
}
inline void friend_base_info::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* friend_base_info::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    position_ = new ::std::string;
  }
  return position_;
}
inline ::std::string* friend_base_info::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void friend_base_info::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::kEmptyString) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string avatar = 6;
inline bool friend_base_info::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void friend_base_info::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void friend_base_info::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void friend_base_info::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& friend_base_info::avatar() const {
  return *avatar_;
}
inline void friend_base_info::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void friend_base_info::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void friend_base_info::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* friend_base_info::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* friend_base_info::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void friend_base_info::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sex = 7;
inline bool friend_base_info::has_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void friend_base_info::set_has_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void friend_base_info::clear_has_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void friend_base_info::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 friend_base_info::sex() const {
  return sex_;
}
inline void friend_base_info::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 grade = 8;
inline bool friend_base_info::has_grade() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void friend_base_info::set_has_grade() {
  _has_bits_[0] |= 0x00000080u;
}
inline void friend_base_info::clear_has_grade() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void friend_base_info::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 friend_base_info::grade() const {
  return grade_;
}
inline void friend_base_info::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// optional uint32 intimacy_value = 9;
inline bool friend_base_info::has_intimacy_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void friend_base_info::set_has_intimacy_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void friend_base_info::clear_has_intimacy_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void friend_base_info::clear_intimacy_value() {
  intimacy_value_ = 0u;
  clear_has_intimacy_value();
}
inline ::google::protobuf::uint32 friend_base_info::intimacy_value() const {
  return intimacy_value_;
}
inline void friend_base_info::set_intimacy_value(::google::protobuf::uint32 value) {
  set_has_intimacy_value();
  intimacy_value_ = value;
}

// optional uint64 fight_power = 10;
inline bool friend_base_info::has_fight_power() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void friend_base_info::set_has_fight_power() {
  _has_bits_[0] |= 0x00000200u;
}
inline void friend_base_info::clear_has_fight_power() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void friend_base_info::clear_fight_power() {
  fight_power_ = GOOGLE_ULONGLONG(0);
  clear_has_fight_power();
}
inline ::google::protobuf::uint64 friend_base_info::fight_power() const {
  return fight_power_;
}
inline void friend_base_info::set_fight_power(::google::protobuf::uint64 value) {
  set_has_fight_power();
  fight_power_ = value;
}

// optional uint64 paixi_id = 11;
inline bool friend_base_info::has_paixi_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void friend_base_info::set_has_paixi_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void friend_base_info::clear_has_paixi_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void friend_base_info::clear_paixi_id() {
  paixi_id_ = GOOGLE_ULONGLONG(0);
  clear_has_paixi_id();
}
inline ::google::protobuf::uint64 friend_base_info::paixi_id() const {
  return paixi_id_;
}
inline void friend_base_info::set_paixi_id(::google::protobuf::uint64 value) {
  set_has_paixi_id();
  paixi_id_ = value;
}

// optional uint64 logout_time = 12;
inline bool friend_base_info::has_logout_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void friend_base_info::set_has_logout_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void friend_base_info::clear_has_logout_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void friend_base_info::clear_logout_time() {
  logout_time_ = GOOGLE_ULONGLONG(0);
  clear_has_logout_time();
}
inline ::google::protobuf::uint64 friend_base_info::logout_time() const {
  return logout_time_;
}
inline void friend_base_info::set_logout_time(::google::protobuf::uint64 value) {
  set_has_logout_time();
  logout_time_ = value;
}

// optional bool online = 13;
inline bool friend_base_info::has_online() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void friend_base_info::set_has_online() {
  _has_bits_[0] |= 0x00001000u;
}
inline void friend_base_info::clear_has_online() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void friend_base_info::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool friend_base_info::online() const {
  return online_;
}
inline void friend_base_info::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional int32 border = 14;
inline bool friend_base_info::has_border() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void friend_base_info::set_has_border() {
  _has_bits_[0] |= 0x00002000u;
}
inline void friend_base_info::clear_has_border() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void friend_base_info::clear_border() {
  border_ = 0;
  clear_has_border();
}
inline ::google::protobuf::int32 friend_base_info::border() const {
  return border_;
}
inline void friend_base_info::set_border(::google::protobuf::int32 value) {
  set_has_border();
  border_ = value;
}

// -------------------------------------------------------------------

// friend_apply_info

// optional uint64 apply_time = 1;
inline bool friend_apply_info::has_apply_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void friend_apply_info::set_has_apply_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void friend_apply_info::clear_has_apply_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void friend_apply_info::clear_apply_time() {
  apply_time_ = GOOGLE_ULONGLONG(0);
  clear_has_apply_time();
}
inline ::google::protobuf::uint64 friend_apply_info::apply_time() const {
  return apply_time_;
}
inline void friend_apply_info::set_apply_time(::google::protobuf::uint64 value) {
  set_has_apply_time();
  apply_time_ = value;
}

// optional uint32 status = 2;
inline bool friend_apply_info::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void friend_apply_info::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void friend_apply_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void friend_apply_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 friend_apply_info::status() const {
  return status_;
}
inline void friend_apply_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional .SProtoSpace.friend_base_info infos = 3;
inline bool friend_apply_info::has_infos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void friend_apply_info::set_has_infos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void friend_apply_info::clear_has_infos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void friend_apply_info::clear_infos() {
  if (infos_ != NULL) infos_->::SProtoSpace::friend_base_info::Clear();
  clear_has_infos();
}
inline const ::SProtoSpace::friend_base_info& friend_apply_info::infos() const {
  return infos_ != NULL ? *infos_ : *default_instance_->infos_;
}
inline ::SProtoSpace::friend_base_info* friend_apply_info::mutable_infos() {
  set_has_infos();
  if (infos_ == NULL) infos_ = new ::SProtoSpace::friend_base_info;
  return infos_;
}
inline ::SProtoSpace::friend_base_info* friend_apply_info::release_infos() {
  clear_has_infos();
  ::SProtoSpace::friend_base_info* temp = infos_;
  infos_ = NULL;
  return temp;
}
inline void friend_apply_info::set_allocated_infos(::SProtoSpace::friend_base_info* infos) {
  delete infos_;
  infos_ = infos;
  if (infos) {
    set_has_infos();
  } else {
    clear_has_infos();
  }
}

// optional string content = 4;
inline bool friend_apply_info::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void friend_apply_info::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void friend_apply_info::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void friend_apply_info::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& friend_apply_info::content() const {
  return *content_;
}
inline void friend_apply_info::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void friend_apply_info::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void friend_apply_info::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* friend_apply_info::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* friend_apply_info::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void friend_apply_info::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// give_item_info

// optional uint32 type = 1;
inline bool give_item_info::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void give_item_info::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void give_item_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void give_item_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 give_item_info::type() const {
  return type_;
}
inline void give_item_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 giver_id = 2;
inline bool give_item_info::has_giver_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void give_item_info::set_has_giver_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void give_item_info::clear_has_giver_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void give_item_info::clear_giver_id() {
  giver_id_ = GOOGLE_ULONGLONG(0);
  clear_has_giver_id();
}
inline ::google::protobuf::uint64 give_item_info::giver_id() const {
  return giver_id_;
}
inline void give_item_info::set_giver_id(::google::protobuf::uint64 value) {
  set_has_giver_id();
  giver_id_ = value;
}

// optional uint64 target_id = 3;
inline bool give_item_info::has_target_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void give_item_info::set_has_target_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void give_item_info::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void give_item_info::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 give_item_info::target_id() const {
  return target_id_;
}
inline void give_item_info::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional uint32 count = 4;
inline bool give_item_info::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void give_item_info::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void give_item_info::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void give_item_info::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 give_item_info::count() const {
  return count_;
}
inline void give_item_info::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 item_id = 5;
inline bool give_item_info::has_item_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void give_item_info::set_has_item_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void give_item_info::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void give_item_info::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 give_item_info::item_id() const {
  return item_id_;
}
inline void give_item_info::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// -------------------------------------------------------------------

// tribute_info

// optional uint32 tribute_id = 1;
inline bool tribute_info::has_tribute_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tribute_info::set_has_tribute_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tribute_info::clear_has_tribute_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tribute_info::clear_tribute_id() {
  tribute_id_ = 0u;
  clear_has_tribute_id();
}
inline ::google::protobuf::uint32 tribute_info::tribute_id() const {
  return tribute_id_;
}
inline void tribute_info::set_tribute_id(::google::protobuf::uint32 value) {
  set_has_tribute_id();
  tribute_id_ = value;
}

// optional uint32 tribute_num = 2;
inline bool tribute_info::has_tribute_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tribute_info::set_has_tribute_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tribute_info::clear_has_tribute_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tribute_info::clear_tribute_num() {
  tribute_num_ = 0u;
  clear_has_tribute_num();
}
inline ::google::protobuf::uint32 tribute_info::tribute_num() const {
  return tribute_num_;
}
inline void tribute_info::set_tribute_num(::google::protobuf::uint32 value) {
  set_has_tribute_num();
  tribute_num_ = value;
}

// -------------------------------------------------------------------

// harem_compete_event

// optional uint64 uuid = 1;
inline bool harem_compete_event::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void harem_compete_event::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void harem_compete_event::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void harem_compete_event::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 harem_compete_event::uuid() const {
  return uuid_;
}
inline void harem_compete_event::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string role_name = 2;
inline bool harem_compete_event::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void harem_compete_event::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void harem_compete_event::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void harem_compete_event::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& harem_compete_event::role_name() const {
  return *role_name_;
}
inline void harem_compete_event::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void harem_compete_event::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void harem_compete_event::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* harem_compete_event::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* harem_compete_event::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void harem_compete_event::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 role_type = 3;
inline bool harem_compete_event::has_role_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void harem_compete_event::set_has_role_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void harem_compete_event::clear_has_role_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void harem_compete_event::clear_role_type() {
  role_type_ = 0u;
  clear_has_role_type();
}
inline ::google::protobuf::uint32 harem_compete_event::role_type() const {
  return role_type_;
}
inline void harem_compete_event::set_role_type(::google::protobuf::uint32 value) {
  set_has_role_type();
  role_type_ = value;
}

// optional .SProtoSpace.EHAREMTYPE type = 4;
inline bool harem_compete_event::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void harem_compete_event::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void harem_compete_event::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void harem_compete_event::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SProtoSpace::EHAREMTYPE harem_compete_event::type() const {
  return static_cast< ::SProtoSpace::EHAREMTYPE >(type_);
}
inline void harem_compete_event::set_type(::SProtoSpace::EHAREMTYPE value) {
  assert(::SProtoSpace::EHAREMTYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 time = 5;
inline bool harem_compete_event::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void harem_compete_event::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void harem_compete_event::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void harem_compete_event::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 harem_compete_event::time() const {
  return time_;
}
inline void harem_compete_event::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional string avatar = 6;
inline bool harem_compete_event::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void harem_compete_event::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void harem_compete_event::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void harem_compete_event::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& harem_compete_event::avatar() const {
  return *avatar_;
}
inline void harem_compete_event::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void harem_compete_event::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void harem_compete_event::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* harem_compete_event::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* harem_compete_event::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void harem_compete_event::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 take_time = 7;
inline bool harem_compete_event::has_take_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void harem_compete_event::set_has_take_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void harem_compete_event::clear_has_take_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void harem_compete_event::clear_take_time() {
  take_time_ = GOOGLE_ULONGLONG(0);
  clear_has_take_time();
}
inline ::google::protobuf::uint64 harem_compete_event::take_time() const {
  return take_time_;
}
inline void harem_compete_event::set_take_time(::google::protobuf::uint64 value) {
  set_has_take_time();
  take_time_ = value;
}

// optional uint32 slap_count = 8;
inline bool harem_compete_event::has_slap_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void harem_compete_event::set_has_slap_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void harem_compete_event::clear_has_slap_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void harem_compete_event::clear_slap_count() {
  slap_count_ = 0u;
  clear_has_slap_count();
}
inline ::google::protobuf::uint32 harem_compete_event::slap_count() const {
  return slap_count_;
}
inline void harem_compete_event::set_slap_count(::google::protobuf::uint32 value) {
  set_has_slap_count();
  slap_count_ = value;
}

// optional .SProtoSpace.ESLAPPROGRESS progress = 9;
inline bool harem_compete_event::has_progress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void harem_compete_event::set_has_progress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void harem_compete_event::clear_has_progress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void harem_compete_event::clear_progress() {
  progress_ = 1;
  clear_has_progress();
}
inline ::SProtoSpace::ESLAPPROGRESS harem_compete_event::progress() const {
  return static_cast< ::SProtoSpace::ESLAPPROGRESS >(progress_);
}
inline void harem_compete_event::set_progress(::SProtoSpace::ESLAPPROGRESS value) {
  assert(::SProtoSpace::ESLAPPROGRESS_IsValid(value));
  set_has_progress();
  progress_ = value;
}

// optional uint64 self_uuid = 10;
inline bool harem_compete_event::has_self_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void harem_compete_event::set_has_self_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void harem_compete_event::clear_has_self_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void harem_compete_event::clear_self_uuid() {
  self_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_self_uuid();
}
inline ::google::protobuf::uint64 harem_compete_event::self_uuid() const {
  return self_uuid_;
}
inline void harem_compete_event::set_self_uuid(::google::protobuf::uint64 value) {
  set_has_self_uuid();
  self_uuid_ = value;
}

// optional string self_name = 11;
inline bool harem_compete_event::has_self_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void harem_compete_event::set_has_self_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void harem_compete_event::clear_has_self_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void harem_compete_event::clear_self_name() {
  if (self_name_ != &::google::protobuf::internal::kEmptyString) {
    self_name_->clear();
  }
  clear_has_self_name();
}
inline const ::std::string& harem_compete_event::self_name() const {
  return *self_name_;
}
inline void harem_compete_event::set_self_name(const ::std::string& value) {
  set_has_self_name();
  if (self_name_ == &::google::protobuf::internal::kEmptyString) {
    self_name_ = new ::std::string;
  }
  self_name_->assign(value);
}
inline void harem_compete_event::set_self_name(const char* value) {
  set_has_self_name();
  if (self_name_ == &::google::protobuf::internal::kEmptyString) {
    self_name_ = new ::std::string;
  }
  self_name_->assign(value);
}
inline void harem_compete_event::set_self_name(const char* value, size_t size) {
  set_has_self_name();
  if (self_name_ == &::google::protobuf::internal::kEmptyString) {
    self_name_ = new ::std::string;
  }
  self_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* harem_compete_event::mutable_self_name() {
  set_has_self_name();
  if (self_name_ == &::google::protobuf::internal::kEmptyString) {
    self_name_ = new ::std::string;
  }
  return self_name_;
}
inline ::std::string* harem_compete_event::release_self_name() {
  clear_has_self_name();
  if (self_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = self_name_;
    self_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void harem_compete_event::set_allocated_self_name(::std::string* self_name) {
  if (self_name_ != &::google::protobuf::internal::kEmptyString) {
    delete self_name_;
  }
  if (self_name) {
    set_has_self_name();
    self_name_ = self_name;
  } else {
    clear_has_self_name();
    self_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SProtoSpace.slap_emoji_info info = 12;
inline int harem_compete_event::info_size() const {
  return info_.size();
}
inline void harem_compete_event::clear_info() {
  info_.Clear();
}
inline const ::SProtoSpace::slap_emoji_info& harem_compete_event::info(int index) const {
  return info_.Get(index);
}
inline ::SProtoSpace::slap_emoji_info* harem_compete_event::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::SProtoSpace::slap_emoji_info* harem_compete_event::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >&
harem_compete_event::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >*
harem_compete_event::mutable_info() {
  return &info_;
}

// optional .SProtoSpace.give_item_info tribute = 13;
inline bool harem_compete_event::has_tribute() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void harem_compete_event::set_has_tribute() {
  _has_bits_[0] |= 0x00001000u;
}
inline void harem_compete_event::clear_has_tribute() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void harem_compete_event::clear_tribute() {
  if (tribute_ != NULL) tribute_->::SProtoSpace::give_item_info::Clear();
  clear_has_tribute();
}
inline const ::SProtoSpace::give_item_info& harem_compete_event::tribute() const {
  return tribute_ != NULL ? *tribute_ : *default_instance_->tribute_;
}
inline ::SProtoSpace::give_item_info* harem_compete_event::mutable_tribute() {
  set_has_tribute();
  if (tribute_ == NULL) tribute_ = new ::SProtoSpace::give_item_info;
  return tribute_;
}
inline ::SProtoSpace::give_item_info* harem_compete_event::release_tribute() {
  clear_has_tribute();
  ::SProtoSpace::give_item_info* temp = tribute_;
  tribute_ = NULL;
  return temp;
}
inline void harem_compete_event::set_allocated_tribute(::SProtoSpace::give_item_info* tribute) {
  delete tribute_;
  tribute_ = tribute;
  if (tribute) {
    set_has_tribute();
  } else {
    clear_has_tribute();
  }
}

// optional uint64 event_uuid = 14;
inline bool harem_compete_event::has_event_uuid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void harem_compete_event::set_has_event_uuid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void harem_compete_event::clear_has_event_uuid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void harem_compete_event::clear_event_uuid() {
  event_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_event_uuid();
}
inline ::google::protobuf::uint64 harem_compete_event::event_uuid() const {
  return event_uuid_;
}
inline void harem_compete_event::set_event_uuid(::google::protobuf::uint64 value) {
  set_has_event_uuid();
  event_uuid_ = value;
}

// -------------------------------------------------------------------

// event_qingan_info

// optional uint32 role_type = 6;
inline bool event_qingan_info::has_role_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void event_qingan_info::set_has_role_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void event_qingan_info::clear_has_role_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void event_qingan_info::clear_role_type() {
  role_type_ = 0u;
  clear_has_role_type();
}
inline ::google::protobuf::uint32 event_qingan_info::role_type() const {
  return role_type_;
}
inline void event_qingan_info::set_role_type(::google::protobuf::uint32 value) {
  set_has_role_type();
  role_type_ = value;
}

// -------------------------------------------------------------------

// event_slap_info

// optional uint32 role_type = 6;
inline bool event_slap_info::has_role_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void event_slap_info::set_has_role_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void event_slap_info::clear_has_role_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void event_slap_info::clear_role_type() {
  role_type_ = 0u;
  clear_has_role_type();
}
inline ::google::protobuf::uint32 event_slap_info::role_type() const {
  return role_type_;
}
inline void event_slap_info::set_role_type(::google::protobuf::uint32 value) {
  set_has_role_type();
  role_type_ = value;
}

// optional uint64 take_time = 8;
inline bool event_slap_info::has_take_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void event_slap_info::set_has_take_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void event_slap_info::clear_has_take_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void event_slap_info::clear_take_time() {
  take_time_ = GOOGLE_ULONGLONG(0);
  clear_has_take_time();
}
inline ::google::protobuf::uint64 event_slap_info::take_time() const {
  return take_time_;
}
inline void event_slap_info::set_take_time(::google::protobuf::uint64 value) {
  set_has_take_time();
  take_time_ = value;
}

// optional uint32 slap_count = 9;
inline bool event_slap_info::has_slap_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void event_slap_info::set_has_slap_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void event_slap_info::clear_has_slap_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void event_slap_info::clear_slap_count() {
  slap_count_ = 0u;
  clear_has_slap_count();
}
inline ::google::protobuf::uint32 event_slap_info::slap_count() const {
  return slap_count_;
}
inline void event_slap_info::set_slap_count(::google::protobuf::uint32 value) {
  set_has_slap_count();
  slap_count_ = value;
}

// optional .SProtoSpace.ESLAPPROGRESS progress = 10;
inline bool event_slap_info::has_progress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void event_slap_info::set_has_progress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void event_slap_info::clear_has_progress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void event_slap_info::clear_progress() {
  progress_ = 1;
  clear_has_progress();
}
inline ::SProtoSpace::ESLAPPROGRESS event_slap_info::progress() const {
  return static_cast< ::SProtoSpace::ESLAPPROGRESS >(progress_);
}
inline void event_slap_info::set_progress(::SProtoSpace::ESLAPPROGRESS value) {
  assert(::SProtoSpace::ESLAPPROGRESS_IsValid(value));
  set_has_progress();
  progress_ = value;
}

// repeated .SProtoSpace.slap_emoji_info info = 11;
inline int event_slap_info::info_size() const {
  return info_.size();
}
inline void event_slap_info::clear_info() {
  info_.Clear();
}
inline const ::SProtoSpace::slap_emoji_info& event_slap_info::info(int index) const {
  return info_.Get(index);
}
inline ::SProtoSpace::slap_emoji_info* event_slap_info::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::SProtoSpace::slap_emoji_info* event_slap_info::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >&
event_slap_info::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::slap_emoji_info >*
event_slap_info::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// event_tribute_info

// optional uint32 role_type = 6;
inline bool event_tribute_info::has_role_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void event_tribute_info::set_has_role_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void event_tribute_info::clear_has_role_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void event_tribute_info::clear_role_type() {
  role_type_ = 0u;
  clear_has_role_type();
}
inline ::google::protobuf::uint32 event_tribute_info::role_type() const {
  return role_type_;
}
inline void event_tribute_info::set_role_type(::google::protobuf::uint32 value) {
  set_has_role_type();
  role_type_ = value;
}

// optional uint32 item_id = 8;
inline bool event_tribute_info::has_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void event_tribute_info::set_has_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void event_tribute_info::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void event_tribute_info::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 event_tribute_info::item_id() const {
  return item_id_;
}
inline void event_tribute_info::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 count = 9;
inline bool event_tribute_info::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void event_tribute_info::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void event_tribute_info::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void event_tribute_info::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 event_tribute_info::count() const {
  return count_;
}
inline void event_tribute_info::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional string content = 10;
inline bool event_tribute_info::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void event_tribute_info::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void event_tribute_info::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void event_tribute_info::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& event_tribute_info::content() const {
  return *content_;
}
inline void event_tribute_info::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void event_tribute_info::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void event_tribute_info::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* event_tribute_info::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* event_tribute_info::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void event_tribute_info::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// slap_emoji_info

// optional uint32 slot_index = 1;
inline bool slap_emoji_info::has_slot_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void slap_emoji_info::set_has_slot_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void slap_emoji_info::clear_has_slot_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void slap_emoji_info::clear_slot_index() {
  slot_index_ = 0u;
  clear_has_slot_index();
}
inline ::google::protobuf::uint32 slap_emoji_info::slot_index() const {
  return slot_index_;
}
inline void slap_emoji_info::set_slot_index(::google::protobuf::uint32 value) {
  set_has_slot_index();
  slot_index_ = value;
}

// optional uint32 emoji_id = 2;
inline bool slap_emoji_info::has_emoji_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void slap_emoji_info::set_has_emoji_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void slap_emoji_info::clear_has_emoji_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void slap_emoji_info::clear_emoji_id() {
  emoji_id_ = 0u;
  clear_has_emoji_id();
}
inline ::google::protobuf::uint32 slap_emoji_info::emoji_id() const {
  return emoji_id_;
}
inline void slap_emoji_info::set_emoji_id(::google::protobuf::uint32 value) {
  set_has_emoji_id();
  emoji_id_ = value;
}

// -------------------------------------------------------------------

// team_hero_slot

// optional uint32 slot = 1;
inline bool team_hero_slot::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void team_hero_slot::set_has_slot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void team_hero_slot::clear_has_slot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void team_hero_slot::clear_slot() {
  slot_ = 0u;
  clear_has_slot();
}
inline ::google::protobuf::uint32 team_hero_slot::slot() const {
  return slot_;
}
inline void team_hero_slot::set_slot(::google::protobuf::uint32 value) {
  set_has_slot();
  slot_ = value;
}

// optional .SProtoSpace.battle_hero_info hero = 2;
inline bool team_hero_slot::has_hero() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void team_hero_slot::set_has_hero() {
  _has_bits_[0] |= 0x00000002u;
}
inline void team_hero_slot::clear_has_hero() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void team_hero_slot::clear_hero() {
  if (hero_ != NULL) hero_->::SProtoSpace::battle_hero_info::Clear();
  clear_has_hero();
}
inline const ::SProtoSpace::battle_hero_info& team_hero_slot::hero() const {
  return hero_ != NULL ? *hero_ : *default_instance_->hero_;
}
inline ::SProtoSpace::battle_hero_info* team_hero_slot::mutable_hero() {
  set_has_hero();
  if (hero_ == NULL) hero_ = new ::SProtoSpace::battle_hero_info;
  return hero_;
}
inline ::SProtoSpace::battle_hero_info* team_hero_slot::release_hero() {
  clear_has_hero();
  ::SProtoSpace::battle_hero_info* temp = hero_;
  hero_ = NULL;
  return temp;
}
inline void team_hero_slot::set_allocated_hero(::SProtoSpace::battle_hero_info* hero) {
  delete hero_;
  hero_ = hero;
  if (hero) {
    set_has_hero();
  } else {
    clear_has_hero();
  }
}

// -------------------------------------------------------------------

// team_member_data

// optional uint32 index = 1;
inline bool team_member_data::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void team_member_data::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void team_member_data::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void team_member_data::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 team_member_data::index() const {
  return index_;
}
inline void team_member_data::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional bool leader = 2;
inline bool team_member_data::has_leader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void team_member_data::set_has_leader() {
  _has_bits_[0] |= 0x00000002u;
}
inline void team_member_data::clear_has_leader() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void team_member_data::clear_leader() {
  leader_ = false;
  clear_has_leader();
}
inline bool team_member_data::leader() const {
  return leader_;
}
inline void team_member_data::set_leader(bool value) {
  set_has_leader();
  leader_ = value;
}

// optional uint64 id = 3;
inline bool team_member_data::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void team_member_data::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void team_member_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void team_member_data::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 team_member_data::id() const {
  return id_;
}
inline void team_member_data::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 4;
inline bool team_member_data::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void team_member_data::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void team_member_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void team_member_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& team_member_data::name() const {
  return *name_;
}
inline void team_member_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void team_member_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void team_member_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* team_member_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* team_member_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void team_member_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 5;
inline bool team_member_data::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void team_member_data::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void team_member_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void team_member_data::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 team_member_data::level() const {
  return level_;
}
inline void team_member_data::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// repeated .SProtoSpace.team_hero_slot heros = 6;
inline int team_member_data::heros_size() const {
  return heros_.size();
}
inline void team_member_data::clear_heros() {
  heros_.Clear();
}
inline const ::SProtoSpace::team_hero_slot& team_member_data::heros(int index) const {
  return heros_.Get(index);
}
inline ::SProtoSpace::team_hero_slot* team_member_data::mutable_heros(int index) {
  return heros_.Mutable(index);
}
inline ::SProtoSpace::team_hero_slot* team_member_data::add_heros() {
  return heros_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_hero_slot >&
team_member_data::heros() const {
  return heros_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_hero_slot >*
team_member_data::mutable_heros() {
  return &heros_;
}

// -------------------------------------------------------------------

// team_data

// optional uint64 team_id = 1;
inline bool team_data::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void team_data::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void team_data::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void team_data::clear_team_id() {
  team_id_ = GOOGLE_ULONGLONG(0);
  clear_has_team_id();
}
inline ::google::protobuf::uint64 team_data::team_id() const {
  return team_id_;
}
inline void team_data::set_team_id(::google::protobuf::uint64 value) {
  set_has_team_id();
  team_id_ = value;
}

// optional .SProtoSpace.eTeamType team_type = 2;
inline bool team_data::has_team_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void team_data::set_has_team_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void team_data::clear_has_team_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void team_data::clear_team_type() {
  team_type_ = 1;
  clear_has_team_type();
}
inline ::SProtoSpace::eTeamType team_data::team_type() const {
  return static_cast< ::SProtoSpace::eTeamType >(team_type_);
}
inline void team_data::set_team_type(::SProtoSpace::eTeamType value) {
  assert(::SProtoSpace::eTeamType_IsValid(value));
  set_has_team_type();
  team_type_ = value;
}

// optional .SProtoSpace.eTeamSize team_size = 3;
inline bool team_data::has_team_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void team_data::set_has_team_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void team_data::clear_has_team_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void team_data::clear_team_size() {
  team_size_ = 1;
  clear_has_team_size();
}
inline ::SProtoSpace::eTeamSize team_data::team_size() const {
  return static_cast< ::SProtoSpace::eTeamSize >(team_size_);
}
inline void team_data::set_team_size(::SProtoSpace::eTeamSize value) {
  assert(::SProtoSpace::eTeamSize_IsValid(value));
  set_has_team_size();
  team_size_ = value;
}

// optional .SProtoSpace.eTeamPermission team_perm = 4;
inline bool team_data::has_team_perm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void team_data::set_has_team_perm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void team_data::clear_has_team_perm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void team_data::clear_team_perm() {
  team_perm_ = 1;
  clear_has_team_perm();
}
inline ::SProtoSpace::eTeamPermission team_data::team_perm() const {
  return static_cast< ::SProtoSpace::eTeamPermission >(team_perm_);
}
inline void team_data::set_team_perm(::SProtoSpace::eTeamPermission value) {
  assert(::SProtoSpace::eTeamPermission_IsValid(value));
  set_has_team_perm();
  team_perm_ = value;
}

// optional int32 create_time = 5;
inline bool team_data::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void team_data::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void team_data::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void team_data::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 team_data::create_time() const {
  return create_time_;
}
inline void team_data::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional string team_name = 6;
inline bool team_data::has_team_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void team_data::set_has_team_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void team_data::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void team_data::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::kEmptyString) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& team_data::team_name() const {
  return *team_name_;
}
inline void team_data::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
}
inline void team_data::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
}
inline void team_data::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* team_data::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  return team_name_;
}
inline ::std::string* team_data::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void team_data::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::kEmptyString) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SProtoSpace.team_member_data members = 7;
inline int team_data::members_size() const {
  return members_.size();
}
inline void team_data::clear_members() {
  members_.Clear();
}
inline const ::SProtoSpace::team_member_data& team_data::members(int index) const {
  return members_.Get(index);
}
inline ::SProtoSpace::team_member_data* team_data::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::SProtoSpace::team_member_data* team_data::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_data >&
team_data::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_data >*
team_data::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// team_member_brief

// optional uint32 slot = 1;
inline bool team_member_brief::has_slot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void team_member_brief::set_has_slot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void team_member_brief::clear_has_slot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void team_member_brief::clear_slot() {
  slot_ = 0u;
  clear_has_slot();
}
inline ::google::protobuf::uint32 team_member_brief::slot() const {
  return slot_;
}
inline void team_member_brief::set_slot(::google::protobuf::uint32 value) {
  set_has_slot();
  slot_ = value;
}

// optional string name = 2;
inline bool team_member_brief::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void team_member_brief::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void team_member_brief::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void team_member_brief::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& team_member_brief::name() const {
  return *name_;
}
inline void team_member_brief::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void team_member_brief::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void team_member_brief::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* team_member_brief::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* team_member_brief::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void team_member_brief::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 head_id = 3;
inline bool team_member_brief::has_head_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void team_member_brief::set_has_head_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void team_member_brief::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void team_member_brief::clear_head_id() {
  head_id_ = 0u;
  clear_has_head_id();
}
inline ::google::protobuf::uint32 team_member_brief::head_id() const {
  return head_id_;
}
inline void team_member_brief::set_head_id(::google::protobuf::uint32 value) {
  set_has_head_id();
  head_id_ = value;
}

// optional uint32 lv = 4;
inline bool team_member_brief::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void team_member_brief::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void team_member_brief::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void team_member_brief::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 team_member_brief::lv() const {
  return lv_;
}
inline void team_member_brief::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// -------------------------------------------------------------------

// team_brief

// optional uint64 team_id = 1;
inline bool team_brief::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void team_brief::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void team_brief::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void team_brief::clear_team_id() {
  team_id_ = GOOGLE_ULONGLONG(0);
  clear_has_team_id();
}
inline ::google::protobuf::uint64 team_brief::team_id() const {
  return team_id_;
}
inline void team_brief::set_team_id(::google::protobuf::uint64 value) {
  set_has_team_id();
  team_id_ = value;
}

// optional .SProtoSpace.eTeamType team_type = 2;
inline bool team_brief::has_team_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void team_brief::set_has_team_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void team_brief::clear_has_team_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void team_brief::clear_team_type() {
  team_type_ = 1;
  clear_has_team_type();
}
inline ::SProtoSpace::eTeamType team_brief::team_type() const {
  return static_cast< ::SProtoSpace::eTeamType >(team_type_);
}
inline void team_brief::set_team_type(::SProtoSpace::eTeamType value) {
  assert(::SProtoSpace::eTeamType_IsValid(value));
  set_has_team_type();
  team_type_ = value;
}

// optional .SProtoSpace.eTeamSize team_size = 3;
inline bool team_brief::has_team_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void team_brief::set_has_team_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void team_brief::clear_has_team_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void team_brief::clear_team_size() {
  team_size_ = 1;
  clear_has_team_size();
}
inline ::SProtoSpace::eTeamSize team_brief::team_size() const {
  return static_cast< ::SProtoSpace::eTeamSize >(team_size_);
}
inline void team_brief::set_team_size(::SProtoSpace::eTeamSize value) {
  assert(::SProtoSpace::eTeamSize_IsValid(value));
  set_has_team_size();
  team_size_ = value;
}

// optional .SProtoSpace.eTeamPermission team_perm = 4;
inline bool team_brief::has_team_perm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void team_brief::set_has_team_perm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void team_brief::clear_has_team_perm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void team_brief::clear_team_perm() {
  team_perm_ = 1;
  clear_has_team_perm();
}
inline ::SProtoSpace::eTeamPermission team_brief::team_perm() const {
  return static_cast< ::SProtoSpace::eTeamPermission >(team_perm_);
}
inline void team_brief::set_team_perm(::SProtoSpace::eTeamPermission value) {
  assert(::SProtoSpace::eTeamPermission_IsValid(value));
  set_has_team_perm();
  team_perm_ = value;
}

// repeated .SProtoSpace.team_member_brief tm_brief = 5;
inline int team_brief::tm_brief_size() const {
  return tm_brief_.size();
}
inline void team_brief::clear_tm_brief() {
  tm_brief_.Clear();
}
inline const ::SProtoSpace::team_member_brief& team_brief::tm_brief(int index) const {
  return tm_brief_.Get(index);
}
inline ::SProtoSpace::team_member_brief* team_brief::mutable_tm_brief(int index) {
  return tm_brief_.Mutable(index);
}
inline ::SProtoSpace::team_member_brief* team_brief::add_tm_brief() {
  return tm_brief_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_brief >&
team_brief::tm_brief() const {
  return tm_brief_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::team_member_brief >*
team_brief::mutable_tm_brief() {
  return &tm_brief_;
}

// -------------------------------------------------------------------

// arena_item_data

// optional uint64 role_id = 1;
inline bool arena_item_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_item_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_item_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_item_data::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 arena_item_data::role_id() const {
  return role_id_;
}
inline void arena_item_data::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional int32 max_grade = 2;
inline bool arena_item_data::has_max_grade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_item_data::set_has_max_grade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_item_data::clear_has_max_grade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_item_data::clear_max_grade() {
  max_grade_ = 0;
  clear_has_max_grade();
}
inline ::google::protobuf::int32 arena_item_data::max_grade() const {
  return max_grade_;
}
inline void arena_item_data::set_max_grade(::google::protobuf::int32 value) {
  set_has_max_grade();
  max_grade_ = value;
}

// optional .SProtoSpace.battle_role_info battle_data = 3;
inline bool arena_item_data::has_battle_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_item_data::set_has_battle_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_item_data::clear_has_battle_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_item_data::clear_battle_data() {
  if (battle_data_ != NULL) battle_data_->::SProtoSpace::battle_role_info::Clear();
  clear_has_battle_data();
}
inline const ::SProtoSpace::battle_role_info& arena_item_data::battle_data() const {
  return battle_data_ != NULL ? *battle_data_ : *default_instance_->battle_data_;
}
inline ::SProtoSpace::battle_role_info* arena_item_data::mutable_battle_data() {
  set_has_battle_data();
  if (battle_data_ == NULL) battle_data_ = new ::SProtoSpace::battle_role_info;
  return battle_data_;
}
inline ::SProtoSpace::battle_role_info* arena_item_data::release_battle_data() {
  clear_has_battle_data();
  ::SProtoSpace::battle_role_info* temp = battle_data_;
  battle_data_ = NULL;
  return temp;
}
inline void arena_item_data::set_allocated_battle_data(::SProtoSpace::battle_role_info* battle_data) {
  delete battle_data_;
  battle_data_ = battle_data;
  if (battle_data) {
    set_has_battle_data();
  } else {
    clear_has_battle_data();
  }
}

// -------------------------------------------------------------------

// emotion_base_info

// optional uint64 id = 1;
inline bool emotion_base_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emotion_base_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emotion_base_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emotion_base_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 emotion_base_info::id() const {
  return id_;
}
inline void emotion_base_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 create_time = 2;
inline bool emotion_base_info::has_create_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emotion_base_info::set_has_create_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emotion_base_info::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emotion_base_info::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 emotion_base_info::create_time() const {
  return create_time_;
}
inline void emotion_base_info::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional uint32 status = 3;
inline bool emotion_base_info::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void emotion_base_info::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void emotion_base_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void emotion_base_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 emotion_base_info::status() const {
  return status_;
}
inline void emotion_base_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 show_role_id = 4;
inline bool emotion_base_info::has_show_role_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void emotion_base_info::set_has_show_role_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void emotion_base_info::clear_has_show_role_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void emotion_base_info::clear_show_role_id() {
  show_role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_show_role_id();
}
inline ::google::protobuf::uint64 emotion_base_info::show_role_id() const {
  return show_role_id_;
}
inline void emotion_base_info::set_show_role_id(::google::protobuf::uint64 value) {
  set_has_show_role_id();
  show_role_id_ = value;
}

// optional string msg_content = 5;
inline bool emotion_base_info::has_msg_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void emotion_base_info::set_has_msg_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void emotion_base_info::clear_has_msg_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void emotion_base_info::clear_msg_content() {
  if (msg_content_ != &::google::protobuf::internal::kEmptyString) {
    msg_content_->clear();
  }
  clear_has_msg_content();
}
inline const ::std::string& emotion_base_info::msg_content() const {
  return *msg_content_;
}
inline void emotion_base_info::set_msg_content(const ::std::string& value) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(value);
}
inline void emotion_base_info::set_msg_content(const char* value) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(value);
}
inline void emotion_base_info::set_msg_content(const char* value, size_t size) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_base_info::mutable_msg_content() {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  return msg_content_;
}
inline ::std::string* emotion_base_info::release_msg_content() {
  clear_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_content_;
    msg_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void emotion_base_info::set_allocated_msg_content(::std::string* msg_content) {
  if (msg_content_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_content_;
  }
  if (msg_content) {
    set_has_msg_content();
    msg_content_ = msg_content;
  } else {
    clear_has_msg_content();
    msg_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string img_urls = 6;
inline int emotion_base_info::img_urls_size() const {
  return img_urls_.size();
}
inline void emotion_base_info::clear_img_urls() {
  img_urls_.Clear();
}
inline const ::std::string& emotion_base_info::img_urls(int index) const {
  return img_urls_.Get(index);
}
inline ::std::string* emotion_base_info::mutable_img_urls(int index) {
  return img_urls_.Mutable(index);
}
inline void emotion_base_info::set_img_urls(int index, const ::std::string& value) {
  img_urls_.Mutable(index)->assign(value);
}
inline void emotion_base_info::set_img_urls(int index, const char* value) {
  img_urls_.Mutable(index)->assign(value);
}
inline void emotion_base_info::set_img_urls(int index, const char* value, size_t size) {
  img_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_base_info::add_img_urls() {
  return img_urls_.Add();
}
inline void emotion_base_info::add_img_urls(const ::std::string& value) {
  img_urls_.Add()->assign(value);
}
inline void emotion_base_info::add_img_urls(const char* value) {
  img_urls_.Add()->assign(value);
}
inline void emotion_base_info::add_img_urls(const char* value, size_t size) {
  img_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
emotion_base_info::img_urls() const {
  return img_urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
emotion_base_info::mutable_img_urls() {
  return &img_urls_;
}

// optional .SProtoSpace.EmotionType type = 7;
inline bool emotion_base_info::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void emotion_base_info::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void emotion_base_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void emotion_base_info::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SProtoSpace::EmotionType emotion_base_info::type() const {
  return static_cast< ::SProtoSpace::EmotionType >(type_);
}
inline void emotion_base_info::set_type(::SProtoSpace::EmotionType value) {
  assert(::SProtoSpace::EmotionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// emotion_like_info

// optional uint64 role_id = 1;
inline bool emotion_like_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emotion_like_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emotion_like_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emotion_like_info::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 emotion_like_info::role_id() const {
  return role_id_;
}
inline void emotion_like_info::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 2;
inline bool emotion_like_info::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emotion_like_info::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emotion_like_info::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emotion_like_info::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& emotion_like_info::role_name() const {
  return *role_name_;
}
inline void emotion_like_info::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void emotion_like_info::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void emotion_like_info::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_like_info::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* emotion_like_info::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void emotion_like_info::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 like_time = 3;
inline bool emotion_like_info::has_like_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void emotion_like_info::set_has_like_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void emotion_like_info::clear_has_like_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void emotion_like_info::clear_like_time() {
  like_time_ = GOOGLE_ULONGLONG(0);
  clear_has_like_time();
}
inline ::google::protobuf::uint64 emotion_like_info::like_time() const {
  return like_time_;
}
inline void emotion_like_info::set_like_time(::google::protobuf::uint64 value) {
  set_has_like_time();
  like_time_ = value;
}

// -------------------------------------------------------------------

// emotion_comment_info

// optional uint64 id = 1;
inline bool emotion_comment_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emotion_comment_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emotion_comment_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emotion_comment_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 emotion_comment_info::id() const {
  return id_;
}
inline void emotion_comment_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 create_time = 2;
inline bool emotion_comment_info::has_create_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emotion_comment_info::set_has_create_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emotion_comment_info::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emotion_comment_info::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 emotion_comment_info::create_time() const {
  return create_time_;
}
inline void emotion_comment_info::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional uint32 status = 3;
inline bool emotion_comment_info::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void emotion_comment_info::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void emotion_comment_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void emotion_comment_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 emotion_comment_info::status() const {
  return status_;
}
inline void emotion_comment_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 from_id = 4;
inline bool emotion_comment_info::has_from_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void emotion_comment_info::set_has_from_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void emotion_comment_info::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void emotion_comment_info::clear_from_id() {
  from_id_ = GOOGLE_ULONGLONG(0);
  clear_has_from_id();
}
inline ::google::protobuf::uint64 emotion_comment_info::from_id() const {
  return from_id_;
}
inline void emotion_comment_info::set_from_id(::google::protobuf::uint64 value) {
  set_has_from_id();
  from_id_ = value;
}

// optional string from_name = 5;
inline bool emotion_comment_info::has_from_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void emotion_comment_info::set_has_from_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void emotion_comment_info::clear_has_from_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void emotion_comment_info::clear_from_name() {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    from_name_->clear();
  }
  clear_has_from_name();
}
inline const ::std::string& emotion_comment_info::from_name() const {
  return *from_name_;
}
inline void emotion_comment_info::set_from_name(const ::std::string& value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void emotion_comment_info::set_from_name(const char* value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void emotion_comment_info::set_from_name(const char* value, size_t size) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_comment_info::mutable_from_name() {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  return from_name_;
}
inline ::std::string* emotion_comment_info::release_from_name() {
  clear_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_name_;
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void emotion_comment_info::set_allocated_from_name(::std::string* from_name) {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_name_;
  }
  if (from_name) {
    set_has_from_name();
    from_name_ = from_name;
  } else {
    clear_has_from_name();
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 to_id = 6;
inline bool emotion_comment_info::has_to_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void emotion_comment_info::set_has_to_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void emotion_comment_info::clear_has_to_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void emotion_comment_info::clear_to_id() {
  to_id_ = GOOGLE_ULONGLONG(0);
  clear_has_to_id();
}
inline ::google::protobuf::uint64 emotion_comment_info::to_id() const {
  return to_id_;
}
inline void emotion_comment_info::set_to_id(::google::protobuf::uint64 value) {
  set_has_to_id();
  to_id_ = value;
}

// optional string to_name = 7;
inline bool emotion_comment_info::has_to_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void emotion_comment_info::set_has_to_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void emotion_comment_info::clear_has_to_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void emotion_comment_info::clear_to_name() {
  if (to_name_ != &::google::protobuf::internal::kEmptyString) {
    to_name_->clear();
  }
  clear_has_to_name();
}
inline const ::std::string& emotion_comment_info::to_name() const {
  return *to_name_;
}
inline void emotion_comment_info::set_to_name(const ::std::string& value) {
  set_has_to_name();
  if (to_name_ == &::google::protobuf::internal::kEmptyString) {
    to_name_ = new ::std::string;
  }
  to_name_->assign(value);
}
inline void emotion_comment_info::set_to_name(const char* value) {
  set_has_to_name();
  if (to_name_ == &::google::protobuf::internal::kEmptyString) {
    to_name_ = new ::std::string;
  }
  to_name_->assign(value);
}
inline void emotion_comment_info::set_to_name(const char* value, size_t size) {
  set_has_to_name();
  if (to_name_ == &::google::protobuf::internal::kEmptyString) {
    to_name_ = new ::std::string;
  }
  to_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_comment_info::mutable_to_name() {
  set_has_to_name();
  if (to_name_ == &::google::protobuf::internal::kEmptyString) {
    to_name_ = new ::std::string;
  }
  return to_name_;
}
inline ::std::string* emotion_comment_info::release_to_name() {
  clear_has_to_name();
  if (to_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_name_;
    to_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void emotion_comment_info::set_allocated_to_name(::std::string* to_name) {
  if (to_name_ != &::google::protobuf::internal::kEmptyString) {
    delete to_name_;
  }
  if (to_name) {
    set_has_to_name();
    to_name_ = to_name;
  } else {
    clear_has_to_name();
    to_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string msg_content = 8;
inline bool emotion_comment_info::has_msg_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void emotion_comment_info::set_has_msg_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void emotion_comment_info::clear_has_msg_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void emotion_comment_info::clear_msg_content() {
  if (msg_content_ != &::google::protobuf::internal::kEmptyString) {
    msg_content_->clear();
  }
  clear_has_msg_content();
}
inline const ::std::string& emotion_comment_info::msg_content() const {
  return *msg_content_;
}
inline void emotion_comment_info::set_msg_content(const ::std::string& value) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(value);
}
inline void emotion_comment_info::set_msg_content(const char* value) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(value);
}
inline void emotion_comment_info::set_msg_content(const char* value, size_t size) {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  msg_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* emotion_comment_info::mutable_msg_content() {
  set_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    msg_content_ = new ::std::string;
  }
  return msg_content_;
}
inline ::std::string* emotion_comment_info::release_msg_content() {
  clear_has_msg_content();
  if (msg_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_content_;
    msg_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void emotion_comment_info::set_allocated_msg_content(::std::string* msg_content) {
  if (msg_content_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_content_;
  }
  if (msg_content) {
    set_has_msg_content();
    msg_content_ = msg_content;
  } else {
    clear_has_msg_content();
    msg_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// emotion_opt_info

// optional int32 like_num = 1 [default = 0];
inline bool emotion_opt_info::has_like_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emotion_opt_info::set_has_like_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emotion_opt_info::clear_has_like_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emotion_opt_info::clear_like_num() {
  like_num_ = 0;
  clear_has_like_num();
}
inline ::google::protobuf::int32 emotion_opt_info::like_num() const {
  return like_num_;
}
inline void emotion_opt_info::set_like_num(::google::protobuf::int32 value) {
  set_has_like_num();
  like_num_ = value;
}

// optional int32 comment_num = 2 [default = 0];
inline bool emotion_opt_info::has_comment_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emotion_opt_info::set_has_comment_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emotion_opt_info::clear_has_comment_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emotion_opt_info::clear_comment_num() {
  comment_num_ = 0;
  clear_has_comment_num();
}
inline ::google::protobuf::int32 emotion_opt_info::comment_num() const {
  return comment_num_;
}
inline void emotion_opt_info::set_comment_num(::google::protobuf::int32 value) {
  set_has_comment_num();
  comment_num_ = value;
}

// -------------------------------------------------------------------

// emotion_info

// optional .SProtoSpace.emotion_base_info base_info = 1;
inline bool emotion_info::has_base_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emotion_info::set_has_base_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emotion_info::clear_has_base_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emotion_info::clear_base_info() {
  if (base_info_ != NULL) base_info_->::SProtoSpace::emotion_base_info::Clear();
  clear_has_base_info();
}
inline const ::SProtoSpace::emotion_base_info& emotion_info::base_info() const {
  return base_info_ != NULL ? *base_info_ : *default_instance_->base_info_;
}
inline ::SProtoSpace::emotion_base_info* emotion_info::mutable_base_info() {
  set_has_base_info();
  if (base_info_ == NULL) base_info_ = new ::SProtoSpace::emotion_base_info;
  return base_info_;
}
inline ::SProtoSpace::emotion_base_info* emotion_info::release_base_info() {
  clear_has_base_info();
  ::SProtoSpace::emotion_base_info* temp = base_info_;
  base_info_ = NULL;
  return temp;
}
inline void emotion_info::set_allocated_base_info(::SProtoSpace::emotion_base_info* base_info) {
  delete base_info_;
  base_info_ = base_info;
  if (base_info) {
    set_has_base_info();
  } else {
    clear_has_base_info();
  }
}

// repeated .SProtoSpace.emotion_like_info like_info = 2;
inline int emotion_info::like_info_size() const {
  return like_info_.size();
}
inline void emotion_info::clear_like_info() {
  like_info_.Clear();
}
inline const ::SProtoSpace::emotion_like_info& emotion_info::like_info(int index) const {
  return like_info_.Get(index);
}
inline ::SProtoSpace::emotion_like_info* emotion_info::mutable_like_info(int index) {
  return like_info_.Mutable(index);
}
inline ::SProtoSpace::emotion_like_info* emotion_info::add_like_info() {
  return like_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_like_info >&
emotion_info::like_info() const {
  return like_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_like_info >*
emotion_info::mutable_like_info() {
  return &like_info_;
}

// repeated .SProtoSpace.emotion_comment_info comment = 3;
inline int emotion_info::comment_size() const {
  return comment_.size();
}
inline void emotion_info::clear_comment() {
  comment_.Clear();
}
inline const ::SProtoSpace::emotion_comment_info& emotion_info::comment(int index) const {
  return comment_.Get(index);
}
inline ::SProtoSpace::emotion_comment_info* emotion_info::mutable_comment(int index) {
  return comment_.Mutable(index);
}
inline ::SProtoSpace::emotion_comment_info* emotion_info::add_comment() {
  return comment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_comment_info >&
emotion_info::comment() const {
  return comment_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_comment_info >*
emotion_info::mutable_comment() {
  return &comment_;
}

// optional .SProtoSpace.emotion_opt_info opt_info = 4;
inline bool emotion_info::has_opt_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void emotion_info::set_has_opt_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void emotion_info::clear_has_opt_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void emotion_info::clear_opt_info() {
  if (opt_info_ != NULL) opt_info_->::SProtoSpace::emotion_opt_info::Clear();
  clear_has_opt_info();
}
inline const ::SProtoSpace::emotion_opt_info& emotion_info::opt_info() const {
  return opt_info_ != NULL ? *opt_info_ : *default_instance_->opt_info_;
}
inline ::SProtoSpace::emotion_opt_info* emotion_info::mutable_opt_info() {
  set_has_opt_info();
  if (opt_info_ == NULL) opt_info_ = new ::SProtoSpace::emotion_opt_info;
  return opt_info_;
}
inline ::SProtoSpace::emotion_opt_info* emotion_info::release_opt_info() {
  clear_has_opt_info();
  ::SProtoSpace::emotion_opt_info* temp = opt_info_;
  opt_info_ = NULL;
  return temp;
}
inline void emotion_info::set_allocated_opt_info(::SProtoSpace::emotion_opt_info* opt_info) {
  delete opt_info_;
  opt_info_ = opt_info;
  if (opt_info) {
    set_has_opt_info();
  } else {
    clear_has_opt_info();
  }
}

// -------------------------------------------------------------------

// show_emotion_all_info

// repeated .SProtoSpace.emotion_info eminfo = 1;
inline int show_emotion_all_info::eminfo_size() const {
  return eminfo_.size();
}
inline void show_emotion_all_info::clear_eminfo() {
  eminfo_.Clear();
}
inline const ::SProtoSpace::emotion_info& show_emotion_all_info::eminfo(int index) const {
  return eminfo_.Get(index);
}
inline ::SProtoSpace::emotion_info* show_emotion_all_info::mutable_eminfo(int index) {
  return eminfo_.Mutable(index);
}
inline ::SProtoSpace::emotion_info* show_emotion_all_info::add_eminfo() {
  return eminfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_info >&
show_emotion_all_info::eminfo() const {
  return eminfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::emotion_info >*
show_emotion_all_info::mutable_eminfo() {
  return &eminfo_;
}

// -------------------------------------------------------------------

// label_info

// optional uint32 label_class = 1;
inline bool label_info::has_label_class() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void label_info::set_has_label_class() {
  _has_bits_[0] |= 0x00000001u;
}
inline void label_info::clear_has_label_class() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void label_info::clear_label_class() {
  label_class_ = 0u;
  clear_has_label_class();
}
inline ::google::protobuf::uint32 label_info::label_class() const {
  return label_class_;
}
inline void label_info::set_label_class(::google::protobuf::uint32 value) {
  set_has_label_class();
  label_class_ = value;
}

// optional uint32 label_config_id = 2;
inline bool label_info::has_label_config_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void label_info::set_has_label_config_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void label_info::clear_has_label_config_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void label_info::clear_label_config_id() {
  label_config_id_ = 0u;
  clear_has_label_config_id();
}
inline ::google::protobuf::uint32 label_info::label_config_id() const {
  return label_config_id_;
}
inline void label_info::set_label_config_id(::google::protobuf::uint32 value) {
  set_has_label_config_id();
  label_config_id_ = value;
}

// -------------------------------------------------------------------

// barrage_role_info

// optional uint64 role_id = 1;
inline bool barrage_role_info::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void barrage_role_info::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void barrage_role_info::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void barrage_role_info::clear_role_id() {
  role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_role_id();
}
inline ::google::protobuf::uint64 barrage_role_info::role_id() const {
  return role_id_;
}
inline void barrage_role_info::set_role_id(::google::protobuf::uint64 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional string role_name = 2;
inline bool barrage_role_info::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void barrage_role_info::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void barrage_role_info::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void barrage_role_info::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& barrage_role_info::role_name() const {
  return *role_name_;
}
inline void barrage_role_info::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void barrage_role_info::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void barrage_role_info::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* barrage_role_info::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* barrage_role_info::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void barrage_role_info::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 role_lv = 3;
inline bool barrage_role_info::has_role_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void barrage_role_info::set_has_role_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void barrage_role_info::clear_has_role_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void barrage_role_info::clear_role_lv() {
  role_lv_ = 0;
  clear_has_role_lv();
}
inline ::google::protobuf::int32 barrage_role_info::role_lv() const {
  return role_lv_;
}
inline void barrage_role_info::set_role_lv(::google::protobuf::int32 value) {
  set_has_role_lv();
  role_lv_ = value;
}

// -------------------------------------------------------------------

// barrage_single

// optional float time = 1;
inline bool barrage_single::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void barrage_single::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void barrage_single::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void barrage_single::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float barrage_single::time() const {
  return time_;
}
inline void barrage_single::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional string content = 2;
inline bool barrage_single::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void barrage_single::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void barrage_single::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void barrage_single::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& barrage_single::content() const {
  return *content_;
}
inline void barrage_single::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void barrage_single::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void barrage_single::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* barrage_single::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* barrage_single::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void barrage_single::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 3;
inline bool barrage_single::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void barrage_single::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void barrage_single::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void barrage_single::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 barrage_single::color() const {
  return color_;
}
inline void barrage_single::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// repeated int32 location = 4;
inline int barrage_single::location_size() const {
  return location_.size();
}
inline void barrage_single::clear_location() {
  location_.Clear();
}
inline ::google::protobuf::int32 barrage_single::location(int index) const {
  return location_.Get(index);
}
inline void barrage_single::set_location(int index, ::google::protobuf::int32 value) {
  location_.Set(index, value);
}
inline void barrage_single::add_location(::google::protobuf::int32 value) {
  location_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
barrage_single::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
barrage_single::mutable_location() {
  return &location_;
}

// optional .SProtoSpace.barrage_role_info role_info = 10;
inline bool barrage_single::has_role_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void barrage_single::set_has_role_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void barrage_single::clear_has_role_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void barrage_single::clear_role_info() {
  if (role_info_ != NULL) role_info_->::SProtoSpace::barrage_role_info::Clear();
  clear_has_role_info();
}
inline const ::SProtoSpace::barrage_role_info& barrage_single::role_info() const {
  return role_info_ != NULL ? *role_info_ : *default_instance_->role_info_;
}
inline ::SProtoSpace::barrage_role_info* barrage_single::mutable_role_info() {
  set_has_role_info();
  if (role_info_ == NULL) role_info_ = new ::SProtoSpace::barrage_role_info;
  return role_info_;
}
inline ::SProtoSpace::barrage_role_info* barrage_single::release_role_info() {
  clear_has_role_info();
  ::SProtoSpace::barrage_role_info* temp = role_info_;
  role_info_ = NULL;
  return temp;
}
inline void barrage_single::set_allocated_role_info(::SProtoSpace::barrage_role_info* role_info) {
  delete role_info_;
  role_info_ = role_info;
  if (role_info) {
    set_has_role_info();
  } else {
    clear_has_role_info();
  }
}

// -------------------------------------------------------------------

// barrage_pack

// repeated .SProtoSpace.barrage_single barrage = 1;
inline int barrage_pack::barrage_size() const {
  return barrage_.size();
}
inline void barrage_pack::clear_barrage() {
  barrage_.Clear();
}
inline const ::SProtoSpace::barrage_single& barrage_pack::barrage(int index) const {
  return barrage_.Get(index);
}
inline ::SProtoSpace::barrage_single* barrage_pack::mutable_barrage(int index) {
  return barrage_.Mutable(index);
}
inline ::SProtoSpace::barrage_single* barrage_pack::add_barrage() {
  return barrage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::barrage_single >&
barrage_pack::barrage() const {
  return barrage_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::barrage_single >*
barrage_pack::mutable_barrage() {
  return &barrage_;
}

// repeated int32 storage_id = 2;
inline int barrage_pack::storage_id_size() const {
  return storage_id_.size();
}
inline void barrage_pack::clear_storage_id() {
  storage_id_.Clear();
}
inline ::google::protobuf::int32 barrage_pack::storage_id(int index) const {
  return storage_id_.Get(index);
}
inline void barrage_pack::set_storage_id(int index, ::google::protobuf::int32 value) {
  storage_id_.Set(index, value);
}
inline void barrage_pack::add_storage_id(::google::protobuf::int32 value) {
  storage_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
barrage_pack::storage_id() const {
  return storage_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
barrage_pack::mutable_storage_id() {
  return &storage_id_;
}

// optional int32 desinty = 3;
inline bool barrage_pack::has_desinty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void barrage_pack::set_has_desinty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void barrage_pack::clear_has_desinty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void barrage_pack::clear_desinty() {
  desinty_ = 0;
  clear_has_desinty();
}
inline ::google::protobuf::int32 barrage_pack::desinty() const {
  return desinty_;
}
inline void barrage_pack::set_desinty(::google::protobuf::int32 value) {
  set_has_desinty();
  desinty_ = value;
}

// optional int32 start = 5;
inline bool barrage_pack::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void barrage_pack::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void barrage_pack::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void barrage_pack::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 barrage_pack::start() const {
  return start_;
}
inline void barrage_pack::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 end = 6;
inline bool barrage_pack::has_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void barrage_pack::set_has_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void barrage_pack::clear_has_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void barrage_pack::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 barrage_pack::end() const {
  return end_;
}
inline void barrage_pack::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SProtoSpace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EFriend_RETCODE>() {
  return ::SProtoSpace::EFriend_RETCODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EFRIEND_OPT_TYPE>() {
  return ::SProtoSpace::EFRIEND_OPT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EFRINED_PROCESS_STATUS>() {
  return ::SProtoSpace::EFRINED_PROCESS_STATUS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ESEARCHTYPE>() {
  return ::SProtoSpace::ESEARCHTYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EGET_FRINED_DO_TYPE>() {
  return ::SProtoSpace::EGET_FRINED_DO_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::ESLAPPROGRESS>() {
  return ::SProtoSpace::ESLAPPROGRESS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EHAREMTYPE>() {
  return ::SProtoSpace::EHAREMTYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EHAREMSHARETYPE>() {
  return ::SProtoSpace::EHAREMSHARETYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::eWorldChatType>() {
  return ::SProtoSpace::eWorldChatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EmotionType>() {
  return ::SProtoSpace::EmotionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SProtoSpace::EBarrageDefine>() {
  return ::SProtoSpace::EBarrageDefine_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cm_5fsocialtype_2eproto__INCLUDED
