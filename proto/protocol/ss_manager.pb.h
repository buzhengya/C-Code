// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ss_manager.proto

#ifndef PROTOBUF_ss_5fmanager_2eproto__INCLUDED
#define PROTOBUF_ss_5fmanager_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ss_protoid.pb.h"
// @@protoc_insertion_point(includes)

namespace SProtoSpace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ss_5fmanager_2eproto();
void protobuf_AssignDesc_ss_5fmanager_2eproto();
void protobuf_ShutdownFile_ss_5fmanager_2eproto();

class listen_node;
class connect_relateion;
class connect_info;
class gateserver_info;
class gameserver_info;
class dbserver_info;
class sync_connection_info_req;
class sync_connection_info_ack;
class node_version_info_ntf;
class sync_conection_info_ntf;
class register_listen_info_req;
class gm2manager_status_req;
class manager2gm_status_ack;
class gm2manager_area_info_req;
class manager2gm_area_info_ack;
class gm_update_config_req;
class gm_update_config_ack;
class gm_update_config_ntf;
class area_cancel_update_req;
class area_cancel_update_ack;
class config_version_req;
class config_version_ack;
class area_update_config_req;
class area_update_config_ack;
class area_monitor_data_reset_ntf;
class assign_new_master_req;
class register_master_info_req;
class mail_item_data;
class gm_send_mail_req;
class gm_send_broadcast_req;
class gm_send_bulletin_req;
class gm_send_shutdown_req;
class gm_open_login_whitelist_req;
class gm_add_login_whitelist_req;

// ===================================================================

class listen_node : public ::google::protobuf::Message {
 public:
  listen_node();
  virtual ~listen_node();

  listen_node(const listen_node& from);

  inline listen_node& operator=(const listen_node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const listen_node& default_instance();

  void Swap(listen_node* other);

  // implements Message ----------------------------------------------

  listen_node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const listen_node& from);
  void MergeFrom(const listen_node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 pipe_id = 1;
  inline bool has_pipe_id() const;
  inline void clear_pipe_id();
  static const int kPipeIdFieldNumber = 1;
  inline ::google::protobuf::uint64 pipe_id() const;
  inline void set_pipe_id(::google::protobuf::uint64 value);

  // optional uint32 listen_ip = 2;
  inline bool has_listen_ip() const;
  inline void clear_listen_ip();
  static const int kListenIpFieldNumber = 2;
  inline ::google::protobuf::uint32 listen_ip() const;
  inline void set_listen_ip(::google::protobuf::uint32 value);

  // optional uint32 listen_port = 3;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 3;
  inline ::google::protobuf::uint32 listen_port() const;
  inline void set_listen_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.listen_node)
 private:
  inline void set_has_pipe_id();
  inline void clear_has_pipe_id();
  inline void set_has_listen_ip();
  inline void clear_has_listen_ip();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 pipe_id_;
  ::google::protobuf::uint32 listen_ip_;
  ::google::protobuf::uint32 listen_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static listen_node* default_instance_;
};
// -------------------------------------------------------------------

class connect_relateion : public ::google::protobuf::Message {
 public:
  connect_relateion();
  virtual ~connect_relateion();

  connect_relateion(const connect_relateion& from);

  inline connect_relateion& operator=(const connect_relateion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connect_relateion& default_instance();

  void Swap(connect_relateion* other);

  // implements Message ----------------------------------------------

  connect_relateion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connect_relateion& from);
  void MergeFrom(const connect_relateion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated uint32 connect = 2;
  inline int connect_size() const;
  inline void clear_connect();
  static const int kConnectFieldNumber = 2;
  inline ::google::protobuf::uint32 connect(int index) const;
  inline void set_connect(int index, ::google::protobuf::uint32 value);
  inline void add_connect(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      connect() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_connect();

  // @@protoc_insertion_point(class_scope:SProtoSpace.connect_relateion)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > connect_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static connect_relateion* default_instance_;
};
// -------------------------------------------------------------------

class connect_info : public ::google::protobuf::Message {
 public:
  connect_info();
  virtual ~connect_info();

  connect_info(const connect_info& from);

  inline connect_info& operator=(const connect_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connect_info& default_instance();

  void Swap(connect_info* other);

  // implements Message ----------------------------------------------

  connect_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connect_info& from);
  void MergeFrom(const connect_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 send_buffer_size = 2;
  inline bool has_send_buffer_size() const;
  inline void clear_send_buffer_size();
  static const int kSendBufferSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 send_buffer_size() const;
  inline void set_send_buffer_size(::google::protobuf::uint32 value);

  // optional uint32 recv_buffer_size = 3;
  inline bool has_recv_buffer_size() const;
  inline void clear_recv_buffer_size();
  static const int kRecvBufferSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 recv_buffer_size() const;
  inline void set_recv_buffer_size(::google::protobuf::uint32 value);

  // repeated .SProtoSpace.connect_relateion connection = 4;
  inline int connection_size() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 4;
  inline const ::SProtoSpace::connect_relateion& connection(int index) const;
  inline ::SProtoSpace::connect_relateion* mutable_connection(int index);
  inline ::SProtoSpace::connect_relateion* add_connection();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::connect_relateion >&
      connection() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::connect_relateion >*
      mutable_connection();

  // repeated .SProtoSpace.listen_node active_node = 5;
  inline int active_node_size() const;
  inline void clear_active_node();
  static const int kActiveNodeFieldNumber = 5;
  inline const ::SProtoSpace::listen_node& active_node(int index) const;
  inline ::SProtoSpace::listen_node* mutable_active_node(int index);
  inline ::SProtoSpace::listen_node* add_active_node();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::listen_node >&
      active_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::listen_node >*
      mutable_active_node();

  // @@protoc_insertion_point(class_scope:SProtoSpace.connect_info)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_send_buffer_size();
  inline void clear_has_send_buffer_size();
  inline void set_has_recv_buffer_size();
  inline void clear_has_recv_buffer_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 send_buffer_size_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::connect_relateion > connection_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::listen_node > active_node_;
  ::google::protobuf::uint32 recv_buffer_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static connect_info* default_instance_;
};
// -------------------------------------------------------------------

class gateserver_info : public ::google::protobuf::Message {
 public:
  gateserver_info();
  virtual ~gateserver_info();

  gateserver_info(const gateserver_info& from);

  inline gateserver_info& operator=(const gateserver_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gateserver_info& default_instance();

  void Swap(gateserver_info* other);

  // implements Message ----------------------------------------------

  gateserver_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gateserver_info& from);
  void MergeFrom(const gateserver_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_group_id = 1;
  inline bool has_server_group_id() const;
  inline void clear_server_group_id();
  static const int kServerGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_group_id() const;
  inline void set_server_group_id(::google::protobuf::uint32 value);

  // optional uint32 server_area_id = 2;
  inline bool has_server_area_id() const;
  inline void clear_server_area_id();
  static const int kServerAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_area_id() const;
  inline void set_server_area_id(::google::protobuf::uint32 value);

  // optional uint32 server_index = 3;
  inline bool has_server_index() const;
  inline void clear_server_index();
  static const int kServerIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 server_index() const;
  inline void set_server_index(::google::protobuf::uint32 value);

  // optional uint64 ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline ::google::protobuf::uint64 ip() const;
  inline void set_ip(::google::protobuf::uint64 value);

  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 login_role_count = 7;
  inline bool has_login_role_count() const;
  inline void clear_login_role_count();
  static const int kLoginRoleCountFieldNumber = 7;
  inline ::google::protobuf::uint64 login_role_count() const;
  inline void set_login_role_count(::google::protobuf::uint64 value);

  // optional uint32 center_server_count = 8;
  inline bool has_center_server_count() const;
  inline void clear_center_server_count();
  static const int kCenterServerCountFieldNumber = 8;
  inline ::google::protobuf::uint32 center_server_count() const;
  inline void set_center_server_count(::google::protobuf::uint32 value);

  // optional uint32 game_server_count = 9;
  inline bool has_game_server_count() const;
  inline void clear_game_server_count();
  static const int kGameServerCountFieldNumber = 9;
  inline ::google::protobuf::uint32 game_server_count() const;
  inline void set_game_server_count(::google::protobuf::uint32 value);

  // optional uint32 battel_server_count = 10;
  inline bool has_battel_server_count() const;
  inline void clear_battel_server_count();
  static const int kBattelServerCountFieldNumber = 10;
  inline ::google::protobuf::uint32 battel_server_count() const;
  inline void set_battel_server_count(::google::protobuf::uint32 value);

  // optional uint32 db_server_count = 11;
  inline bool has_db_server_count() const;
  inline void clear_db_server_count();
  static const int kDbServerCountFieldNumber = 11;
  inline ::google::protobuf::uint32 db_server_count() const;
  inline void set_db_server_count(::google::protobuf::uint32 value);

  // optional uint32 mail_server_count = 12;
  inline bool has_mail_server_count() const;
  inline void clear_mail_server_count();
  static const int kMailServerCountFieldNumber = 12;
  inline ::google::protobuf::uint32 mail_server_count() const;
  inline void set_mail_server_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gateserver_info)
 private:
  inline void set_has_server_group_id();
  inline void clear_has_server_group_id();
  inline void set_has_server_area_id();
  inline void clear_has_server_area_id();
  inline void set_has_server_index();
  inline void clear_has_server_index();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_login_role_count();
  inline void clear_has_login_role_count();
  inline void set_has_center_server_count();
  inline void clear_has_center_server_count();
  inline void set_has_game_server_count();
  inline void clear_has_game_server_count();
  inline void set_has_battel_server_count();
  inline void clear_has_battel_server_count();
  inline void set_has_db_server_count();
  inline void clear_has_db_server_count();
  inline void set_has_mail_server_count();
  inline void clear_has_mail_server_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_group_id_;
  ::google::protobuf::uint32 server_area_id_;
  ::google::protobuf::uint64 ip_;
  ::google::protobuf::uint32 server_index_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 login_role_count_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 center_server_count_;
  ::google::protobuf::uint32 game_server_count_;
  ::google::protobuf::uint32 battel_server_count_;
  ::google::protobuf::uint32 db_server_count_;
  ::google::protobuf::uint32 mail_server_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gateserver_info* default_instance_;
};
// -------------------------------------------------------------------

class gameserver_info : public ::google::protobuf::Message {
 public:
  gameserver_info();
  virtual ~gameserver_info();

  gameserver_info(const gameserver_info& from);

  inline gameserver_info& operator=(const gameserver_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gameserver_info& default_instance();

  void Swap(gameserver_info* other);

  // implements Message ----------------------------------------------

  gameserver_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gameserver_info& from);
  void MergeFrom(const gameserver_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_group_id = 1;
  inline bool has_server_group_id() const;
  inline void clear_server_group_id();
  static const int kServerGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_group_id() const;
  inline void set_server_group_id(::google::protobuf::uint32 value);

  // optional uint32 server_area_id = 2;
  inline bool has_server_area_id() const;
  inline void clear_server_area_id();
  static const int kServerAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_area_id() const;
  inline void set_server_area_id(::google::protobuf::uint32 value);

  // optional uint32 server_index = 3;
  inline bool has_server_index() const;
  inline void clear_server_index();
  static const int kServerIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 server_index() const;
  inline void set_server_index(::google::protobuf::uint32 value);

  // optional uint64 ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline ::google::protobuf::uint64 ip() const;
  inline void set_ip(::google::protobuf::uint64 value);

  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 login_role_count = 7;
  inline bool has_login_role_count() const;
  inline void clear_login_role_count();
  static const int kLoginRoleCountFieldNumber = 7;
  inline ::google::protobuf::uint64 login_role_count() const;
  inline void set_login_role_count(::google::protobuf::uint64 value);

  // optional uint32 gate_server_count = 8;
  inline bool has_gate_server_count() const;
  inline void clear_gate_server_count();
  static const int kGateServerCountFieldNumber = 8;
  inline ::google::protobuf::uint32 gate_server_count() const;
  inline void set_gate_server_count(::google::protobuf::uint32 value);

  // optional uint32 mail_server_count = 9;
  inline bool has_mail_server_count() const;
  inline void clear_mail_server_count();
  static const int kMailServerCountFieldNumber = 9;
  inline ::google::protobuf::uint32 mail_server_count() const;
  inline void set_mail_server_count(::google::protobuf::uint32 value);

  // optional uint32 battel_server_count = 10;
  inline bool has_battel_server_count() const;
  inline void clear_battel_server_count();
  static const int kBattelServerCountFieldNumber = 10;
  inline ::google::protobuf::uint32 battel_server_count() const;
  inline void set_battel_server_count(::google::protobuf::uint32 value);

  // optional uint32 db_server_count = 11;
  inline bool has_db_server_count() const;
  inline void clear_db_server_count();
  static const int kDbServerCountFieldNumber = 11;
  inline ::google::protobuf::uint32 db_server_count() const;
  inline void set_db_server_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gameserver_info)
 private:
  inline void set_has_server_group_id();
  inline void clear_has_server_group_id();
  inline void set_has_server_area_id();
  inline void clear_has_server_area_id();
  inline void set_has_server_index();
  inline void clear_has_server_index();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_login_role_count();
  inline void clear_has_login_role_count();
  inline void set_has_gate_server_count();
  inline void clear_has_gate_server_count();
  inline void set_has_mail_server_count();
  inline void clear_has_mail_server_count();
  inline void set_has_battel_server_count();
  inline void clear_has_battel_server_count();
  inline void set_has_db_server_count();
  inline void clear_has_db_server_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_group_id_;
  ::google::protobuf::uint32 server_area_id_;
  ::google::protobuf::uint64 ip_;
  ::google::protobuf::uint32 server_index_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 login_role_count_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 gate_server_count_;
  ::google::protobuf::uint32 mail_server_count_;
  ::google::protobuf::uint32 battel_server_count_;
  ::google::protobuf::uint32 db_server_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gameserver_info* default_instance_;
};
// -------------------------------------------------------------------

class dbserver_info : public ::google::protobuf::Message {
 public:
  dbserver_info();
  virtual ~dbserver_info();

  dbserver_info(const dbserver_info& from);

  inline dbserver_info& operator=(const dbserver_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbserver_info& default_instance();

  void Swap(dbserver_info* other);

  // implements Message ----------------------------------------------

  dbserver_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dbserver_info& from);
  void MergeFrom(const dbserver_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_group_id = 1;
  inline bool has_server_group_id() const;
  inline void clear_server_group_id();
  static const int kServerGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_group_id() const;
  inline void set_server_group_id(::google::protobuf::uint32 value);

  // optional uint32 server_area_id = 2;
  inline bool has_server_area_id() const;
  inline void clear_server_area_id();
  static const int kServerAreaIdFieldNumber = 2;
  inline ::google::protobuf::uint32 server_area_id() const;
  inline void set_server_area_id(::google::protobuf::uint32 value);

  // optional uint32 server_index = 3;
  inline bool has_server_index() const;
  inline void clear_server_index();
  static const int kServerIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 server_index() const;
  inline void set_server_index(::google::protobuf::uint32 value);

  // optional uint64 ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline ::google::protobuf::uint64 ip() const;
  inline void set_ip(::google::protobuf::uint64 value);

  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint64 redis_role_number = 7;
  inline bool has_redis_role_number() const;
  inline void clear_redis_role_number();
  static const int kRedisRoleNumberFieldNumber = 7;
  inline ::google::protobuf::uint64 redis_role_number() const;
  inline void set_redis_role_number(::google::protobuf::uint64 value);

  // optional uint64 redis_memory_usage = 8;
  inline bool has_redis_memory_usage() const;
  inline void clear_redis_memory_usage();
  static const int kRedisMemoryUsageFieldNumber = 8;
  inline ::google::protobuf::uint64 redis_memory_usage() const;
  inline void set_redis_memory_usage(::google::protobuf::uint64 value);

  // optional uint32 sql_status = 9;
  inline bool has_sql_status() const;
  inline void clear_sql_status();
  static const int kSqlStatusFieldNumber = 9;
  inline ::google::protobuf::uint32 sql_status() const;
  inline void set_sql_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.dbserver_info)
 private:
  inline void set_has_server_group_id();
  inline void clear_has_server_group_id();
  inline void set_has_server_area_id();
  inline void clear_has_server_area_id();
  inline void set_has_server_index();
  inline void clear_has_server_index();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_redis_role_number();
  inline void clear_has_redis_role_number();
  inline void set_has_redis_memory_usage();
  inline void clear_has_redis_memory_usage();
  inline void set_has_sql_status();
  inline void clear_has_sql_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_group_id_;
  ::google::protobuf::uint32 server_area_id_;
  ::google::protobuf::uint64 ip_;
  ::google::protobuf::uint32 server_index_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 redis_role_number_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 sql_status_;
  ::google::protobuf::uint64 redis_memory_usage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static dbserver_info* default_instance_;
};
// -------------------------------------------------------------------

class sync_connection_info_req : public ::google::protobuf::Message {
 public:
  sync_connection_info_req();
  virtual ~sync_connection_info_req();

  sync_connection_info_req(const sync_connection_info_req& from);

  inline sync_connection_info_req& operator=(const sync_connection_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sync_connection_info_req& default_instance();

  void Swap(sync_connection_info_req* other);

  // implements Message ----------------------------------------------

  sync_connection_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sync_connection_info_req& from);
  void MergeFrom(const sync_connection_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_connection_info_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.sync_connection_info_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static sync_connection_info_req* default_instance_;
};
// -------------------------------------------------------------------

class sync_connection_info_ack : public ::google::protobuf::Message {
 public:
  sync_connection_info_ack();
  virtual ~sync_connection_info_ack();

  sync_connection_info_ack(const sync_connection_info_ack& from);

  inline sync_connection_info_ack& operator=(const sync_connection_info_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sync_connection_info_ack& default_instance();

  void Swap(sync_connection_info_ack* other);

  // implements Message ----------------------------------------------

  sync_connection_info_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sync_connection_info_ack& from);
  void MergeFrom(const sync_connection_info_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_connection_info_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.connect_info info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::SProtoSpace::connect_info& info() const;
  inline ::SProtoSpace::connect_info* mutable_info();
  inline ::SProtoSpace::connect_info* release_info();
  inline void set_allocated_info(::SProtoSpace::connect_info* info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.sync_connection_info_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::connect_info* info_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static sync_connection_info_ack* default_instance_;
};
// -------------------------------------------------------------------

class node_version_info_ntf : public ::google::protobuf::Message {
 public:
  node_version_info_ntf();
  virtual ~node_version_info_ntf();

  node_version_info_ntf(const node_version_info_ntf& from);

  inline node_version_info_ntf& operator=(const node_version_info_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const node_version_info_ntf& default_instance();

  void Swap(node_version_info_ntf* other);

  // implements Message ----------------------------------------------

  node_version_info_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const node_version_info_ntf& from);
  void MergeFrom(const node_version_info_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = node_version_info_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.node_version_info_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static node_version_info_ntf* default_instance_;
};
// -------------------------------------------------------------------

class sync_conection_info_ntf : public ::google::protobuf::Message {
 public:
  sync_conection_info_ntf();
  virtual ~sync_conection_info_ntf();

  sync_conection_info_ntf(const sync_conection_info_ntf& from);

  inline sync_conection_info_ntf& operator=(const sync_conection_info_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sync_conection_info_ntf& default_instance();

  void Swap(sync_conection_info_ntf* other);

  // implements Message ----------------------------------------------

  sync_conection_info_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sync_conection_info_ntf& from);
  void MergeFrom(const sync_conection_info_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_conection_info_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.connect_info info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::SProtoSpace::connect_info& info() const;
  inline ::SProtoSpace::connect_info* mutable_info();
  inline ::SProtoSpace::connect_info* release_info();
  inline void set_allocated_info(::SProtoSpace::connect_info* info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.sync_conection_info_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::connect_info* info_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static sync_conection_info_ntf* default_instance_;
};
// -------------------------------------------------------------------

class register_listen_info_req : public ::google::protobuf::Message {
 public:
  register_listen_info_req();
  virtual ~register_listen_info_req();

  register_listen_info_req(const register_listen_info_req& from);

  inline register_listen_info_req& operator=(const register_listen_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_listen_info_req& default_instance();

  void Swap(register_listen_info_req* other);

  // implements Message ----------------------------------------------

  register_listen_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const register_listen_info_req& from);
  void MergeFrom(const register_listen_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = register_listen_info_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 listen_ip = 2;
  inline bool has_listen_ip() const;
  inline void clear_listen_ip();
  static const int kListenIpFieldNumber = 2;
  inline ::google::protobuf::uint32 listen_ip() const;
  inline void set_listen_ip(::google::protobuf::uint32 value);

  // optional uint32 listen_port = 3;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 3;
  inline ::google::protobuf::uint32 listen_port() const;
  inline void set_listen_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.register_listen_info_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_listen_ip();
  inline void clear_has_listen_ip();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 listen_ip_;
  ::google::protobuf::uint32 listen_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static register_listen_info_req* default_instance_;
};
// -------------------------------------------------------------------

class gm2manager_status_req : public ::google::protobuf::Message {
 public:
  gm2manager_status_req();
  virtual ~gm2manager_status_req();

  gm2manager_status_req(const gm2manager_status_req& from);

  inline gm2manager_status_req& operator=(const gm2manager_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm2manager_status_req& default_instance();

  void Swap(gm2manager_status_req* other);

  // implements Message ----------------------------------------------

  gm2manager_status_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm2manager_status_req& from);
  void MergeFrom(const gm2manager_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2manager_status_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 info_detail = 2;
  inline bool has_info_detail() const;
  inline void clear_info_detail();
  static const int kInfoDetailFieldNumber = 2;
  inline ::google::protobuf::uint64 info_detail() const;
  inline void set_info_detail(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm2manager_status_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_info_detail();
  inline void clear_has_info_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 info_detail_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm2manager_status_req* default_instance_;
};
// -------------------------------------------------------------------

class manager2gm_status_ack : public ::google::protobuf::Message {
 public:
  manager2gm_status_ack();
  virtual ~manager2gm_status_ack();

  manager2gm_status_ack(const manager2gm_status_ack& from);

  inline manager2gm_status_ack& operator=(const manager2gm_status_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const manager2gm_status_ack& default_instance();

  void Swap(manager2gm_status_ack* other);

  // implements Message ----------------------------------------------

  manager2gm_status_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const manager2gm_status_ack& from);
  void MergeFrom(const manager2gm_status_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = manager2gm_status_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 game_count = 3;
  inline bool has_game_count() const;
  inline void clear_game_count();
  static const int kGameCountFieldNumber = 3;
  inline ::google::protobuf::uint32 game_count() const;
  inline void set_game_count(::google::protobuf::uint32 value);

  // optional uint32 db_count = 4;
  inline bool has_db_count() const;
  inline void clear_db_count();
  static const int kDbCountFieldNumber = 4;
  inline ::google::protobuf::uint32 db_count() const;
  inline void set_db_count(::google::protobuf::uint32 value);

  // optional uint32 gate_count = 5;
  inline bool has_gate_count() const;
  inline void clear_gate_count();
  static const int kGateCountFieldNumber = 5;
  inline ::google::protobuf::uint32 gate_count() const;
  inline void set_gate_count(::google::protobuf::uint32 value);

  // optional uint32 manager_count = 6;
  inline bool has_manager_count() const;
  inline void clear_manager_count();
  static const int kManagerCountFieldNumber = 6;
  inline ::google::protobuf::uint32 manager_count() const;
  inline void set_manager_count(::google::protobuf::uint32 value);

  // repeated uint64 overload_pipe_ids = 7;
  inline int overload_pipe_ids_size() const;
  inline void clear_overload_pipe_ids();
  static const int kOverloadPipeIdsFieldNumber = 7;
  inline ::google::protobuf::uint64 overload_pipe_ids(int index) const;
  inline void set_overload_pipe_ids(int index, ::google::protobuf::uint64 value);
  inline void add_overload_pipe_ids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      overload_pipe_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_overload_pipe_ids();

  // optional uint32 area_id = 8;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 8;
  inline ::google::protobuf::uint32 area_id() const;
  inline void set_area_id(::google::protobuf::uint32 value);

  // optional uint32 group_id = 9;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 9;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional string area_name = 10;
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 10;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  inline void set_allocated_area_name(::std::string* area_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.manager2gm_status_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_game_count();
  inline void clear_has_game_count();
  inline void set_has_db_count();
  inline void clear_has_db_count();
  inline void set_has_gate_count();
  inline void clear_has_gate_count();
  inline void set_has_manager_count();
  inline void clear_has_manager_count();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_area_name();
  inline void clear_has_area_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 game_count_;
  ::google::protobuf::uint32 db_count_;
  ::google::protobuf::uint32 gate_count_;
  ::google::protobuf::uint32 manager_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > overload_pipe_ids_;
  ::google::protobuf::uint32 area_id_;
  ::google::protobuf::uint32 group_id_;
  ::std::string* area_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static manager2gm_status_ack* default_instance_;
};
// -------------------------------------------------------------------

class gm2manager_area_info_req : public ::google::protobuf::Message {
 public:
  gm2manager_area_info_req();
  virtual ~gm2manager_area_info_req();

  gm2manager_area_info_req(const gm2manager_area_info_req& from);

  inline gm2manager_area_info_req& operator=(const gm2manager_area_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm2manager_area_info_req& default_instance();

  void Swap(gm2manager_area_info_req* other);

  // implements Message ----------------------------------------------

  gm2manager_area_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm2manager_area_info_req& from);
  void MergeFrom(const gm2manager_area_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2manager_area_info_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 info_detail = 2;
  inline bool has_info_detail() const;
  inline void clear_info_detail();
  static const int kInfoDetailFieldNumber = 2;
  inline ::google::protobuf::uint64 info_detail() const;
  inline void set_info_detail(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm2manager_area_info_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_info_detail();
  inline void clear_has_info_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 info_detail_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm2manager_area_info_req* default_instance_;
};
// -------------------------------------------------------------------

class manager2gm_area_info_ack : public ::google::protobuf::Message {
 public:
  manager2gm_area_info_ack();
  virtual ~manager2gm_area_info_ack();

  manager2gm_area_info_ack(const manager2gm_area_info_ack& from);

  inline manager2gm_area_info_ack& operator=(const manager2gm_area_info_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const manager2gm_area_info_ack& default_instance();

  void Swap(manager2gm_area_info_ack* other);

  // implements Message ----------------------------------------------

  manager2gm_area_info_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const manager2gm_area_info_ack& from);
  void MergeFrom(const manager2gm_area_info_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = manager2gm_area_info_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated .SProtoSpace.gameserver_info gameserver_this_area = 2;
  inline int gameserver_this_area_size() const;
  inline void clear_gameserver_this_area();
  static const int kGameserverThisAreaFieldNumber = 2;
  inline const ::SProtoSpace::gameserver_info& gameserver_this_area(int index) const;
  inline ::SProtoSpace::gameserver_info* mutable_gameserver_this_area(int index);
  inline ::SProtoSpace::gameserver_info* add_gameserver_this_area();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gameserver_info >&
      gameserver_this_area() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gameserver_info >*
      mutable_gameserver_this_area();

  // repeated .SProtoSpace.dbserver_info dbserver_this_area = 3;
  inline int dbserver_this_area_size() const;
  inline void clear_dbserver_this_area();
  static const int kDbserverThisAreaFieldNumber = 3;
  inline const ::SProtoSpace::dbserver_info& dbserver_this_area(int index) const;
  inline ::SProtoSpace::dbserver_info* mutable_dbserver_this_area(int index);
  inline ::SProtoSpace::dbserver_info* add_dbserver_this_area();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::dbserver_info >&
      dbserver_this_area() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::dbserver_info >*
      mutable_dbserver_this_area();

  // repeated .SProtoSpace.gateserver_info gateserver_this_area = 4;
  inline int gateserver_this_area_size() const;
  inline void clear_gateserver_this_area();
  static const int kGateserverThisAreaFieldNumber = 4;
  inline const ::SProtoSpace::gateserver_info& gateserver_this_area(int index) const;
  inline ::SProtoSpace::gateserver_info* mutable_gateserver_this_area(int index);
  inline ::SProtoSpace::gateserver_info* add_gateserver_this_area();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gateserver_info >&
      gateserver_this_area() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gateserver_info >*
      mutable_gateserver_this_area();

  // @@protoc_insertion_point(class_scope:SProtoSpace.manager2gm_area_info_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gameserver_info > gameserver_this_area_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::dbserver_info > dbserver_this_area_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gateserver_info > gateserver_this_area_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static manager2gm_area_info_ack* default_instance_;
};
// -------------------------------------------------------------------

class gm_update_config_req : public ::google::protobuf::Message {
 public:
  gm_update_config_req();
  virtual ~gm_update_config_req();

  gm_update_config_req(const gm_update_config_req& from);

  inline gm_update_config_req& operator=(const gm_update_config_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_update_config_req& default_instance();

  void Swap(gm_update_config_req* other);

  // implements Message ----------------------------------------------

  gm_update_config_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_update_config_req& from);
  void MergeFrom(const gm_update_config_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 update_time = 2;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_update_config_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 update_time_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_update_config_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_update_config_ack : public ::google::protobuf::Message {
 public:
  gm_update_config_ack();
  virtual ~gm_update_config_ack();

  gm_update_config_ack(const gm_update_config_ack& from);

  inline gm_update_config_ack& operator=(const gm_update_config_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_update_config_ack& default_instance();

  void Swap(gm_update_config_ack* other);

  // implements Message ----------------------------------------------

  gm_update_config_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_update_config_ack& from);
  void MergeFrom(const gm_update_config_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_update_config_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_update_config_ack* default_instance_;
};
// -------------------------------------------------------------------

class gm_update_config_ntf : public ::google::protobuf::Message {
 public:
  gm_update_config_ntf();
  virtual ~gm_update_config_ntf();

  gm_update_config_ntf(const gm_update_config_ntf& from);

  inline gm_update_config_ntf& operator=(const gm_update_config_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_update_config_ntf& default_instance();

  void Swap(gm_update_config_ntf* other);

  // implements Message ----------------------------------------------

  gm_update_config_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_update_config_ntf& from);
  void MergeFrom(const gm_update_config_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional uint64 err_server_pipe = 3;
  inline bool has_err_server_pipe() const;
  inline void clear_err_server_pipe();
  static const int kErrServerPipeFieldNumber = 3;
  inline ::google::protobuf::uint64 err_server_pipe() const;
  inline void set_err_server_pipe(::google::protobuf::uint64 value);

  // optional string ret_debug = 4;
  inline bool has_ret_debug() const;
  inline void clear_ret_debug();
  static const int kRetDebugFieldNumber = 4;
  inline const ::std::string& ret_debug() const;
  inline void set_ret_debug(const ::std::string& value);
  inline void set_ret_debug(const char* value);
  inline void set_ret_debug(const char* value, size_t size);
  inline ::std::string* mutable_ret_debug();
  inline ::std::string* release_ret_debug();
  inline void set_allocated_ret_debug(::std::string* ret_debug);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_update_config_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_err_server_pipe();
  inline void clear_has_err_server_pipe();
  inline void set_has_ret_debug();
  inline void clear_has_ret_debug();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::uint64 err_server_pipe_;
  ::std::string* ret_debug_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_update_config_ntf* default_instance_;
};
// -------------------------------------------------------------------

class area_cancel_update_req : public ::google::protobuf::Message {
 public:
  area_cancel_update_req();
  virtual ~area_cancel_update_req();

  area_cancel_update_req(const area_cancel_update_req& from);

  inline area_cancel_update_req& operator=(const area_cancel_update_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_cancel_update_req& default_instance();

  void Swap(area_cancel_update_req* other);

  // implements Message ----------------------------------------------

  area_cancel_update_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_cancel_update_req& from);
  void MergeFrom(const area_cancel_update_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_cancel_update_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_cancel_update_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static area_cancel_update_req* default_instance_;
};
// -------------------------------------------------------------------

class area_cancel_update_ack : public ::google::protobuf::Message {
 public:
  area_cancel_update_ack();
  virtual ~area_cancel_update_ack();

  area_cancel_update_ack(const area_cancel_update_ack& from);

  inline area_cancel_update_ack& operator=(const area_cancel_update_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_cancel_update_ack& default_instance();

  void Swap(area_cancel_update_ack* other);

  // implements Message ----------------------------------------------

  area_cancel_update_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_cancel_update_ack& from);
  void MergeFrom(const area_cancel_update_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_cancel_update_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_cancel_update_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static area_cancel_update_ack* default_instance_;
};
// -------------------------------------------------------------------

class config_version_req : public ::google::protobuf::Message {
 public:
  config_version_req();
  virtual ~config_version_req();

  config_version_req(const config_version_req& from);

  inline config_version_req& operator=(const config_version_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const config_version_req& default_instance();

  void Swap(config_version_req* other);

  // implements Message ----------------------------------------------

  config_version_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const config_version_req& from);
  void MergeFrom(const config_version_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = config_version_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.config_version_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static config_version_req* default_instance_;
};
// -------------------------------------------------------------------

class config_version_ack : public ::google::protobuf::Message {
 public:
  config_version_ack();
  virtual ~config_version_ack();

  config_version_ack(const config_version_ack& from);

  inline config_version_ack& operator=(const config_version_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const config_version_ack& default_instance();

  void Swap(config_version_ack* other);

  // implements Message ----------------------------------------------

  config_version_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const config_version_ack& from);
  void MergeFrom(const config_version_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = config_version_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 update_version = 2;
  inline bool has_update_version() const;
  inline void clear_update_version();
  static const int kUpdateVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 update_version() const;
  inline void set_update_version(::google::protobuf::uint64 value);

  // optional string update_name = 3;
  inline bool has_update_name() const;
  inline void clear_update_name();
  static const int kUpdateNameFieldNumber = 3;
  inline const ::std::string& update_name() const;
  inline void set_update_name(const ::std::string& value);
  inline void set_update_name(const char* value);
  inline void set_update_name(const char* value, size_t size);
  inline ::std::string* mutable_update_name();
  inline ::std::string* release_update_name();
  inline void set_allocated_update_name(::std::string* update_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.config_version_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_update_version();
  inline void clear_has_update_version();
  inline void set_has_update_name();
  inline void clear_has_update_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 update_version_;
  ::std::string* update_name_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static config_version_ack* default_instance_;
};
// -------------------------------------------------------------------

class area_update_config_req : public ::google::protobuf::Message {
 public:
  area_update_config_req();
  virtual ~area_update_config_req();

  area_update_config_req(const area_update_config_req& from);

  inline area_update_config_req& operator=(const area_update_config_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_update_config_req& default_instance();

  void Swap(area_update_config_req* other);

  // implements Message ----------------------------------------------

  area_update_config_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_update_config_req& from);
  void MergeFrom(const area_update_config_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_update_config_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 update_version = 2;
  inline bool has_update_version() const;
  inline void clear_update_version();
  static const int kUpdateVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 update_version() const;
  inline void set_update_version(::google::protobuf::uint64 value);

  // optional uint64 update_time = 3;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // optional string update_name = 4;
  inline bool has_update_name() const;
  inline void clear_update_name();
  static const int kUpdateNameFieldNumber = 4;
  inline const ::std::string& update_name() const;
  inline void set_update_name(const ::std::string& value);
  inline void set_update_name(const char* value);
  inline void set_update_name(const char* value, size_t size);
  inline ::std::string* mutable_update_name();
  inline ::std::string* release_update_name();
  inline void set_allocated_update_name(::std::string* update_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_update_config_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_update_version();
  inline void clear_has_update_version();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_update_name();
  inline void clear_has_update_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 update_version_;
  ::google::protobuf::uint64 update_time_;
  ::std::string* update_name_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static area_update_config_req* default_instance_;
};
// -------------------------------------------------------------------

class area_update_config_ack : public ::google::protobuf::Message {
 public:
  area_update_config_ack();
  virtual ~area_update_config_ack();

  area_update_config_ack(const area_update_config_ack& from);

  inline area_update_config_ack& operator=(const area_update_config_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_update_config_ack& default_instance();

  void Swap(area_update_config_ack* other);

  // implements Message ----------------------------------------------

  area_update_config_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_update_config_ack& from);
  void MergeFrom(const area_update_config_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_update_config_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional string ret_debug = 3;
  inline bool has_ret_debug() const;
  inline void clear_ret_debug();
  static const int kRetDebugFieldNumber = 3;
  inline const ::std::string& ret_debug() const;
  inline void set_ret_debug(const ::std::string& value);
  inline void set_ret_debug(const char* value);
  inline void set_ret_debug(const char* value, size_t size);
  inline ::std::string* mutable_ret_debug();
  inline ::std::string* release_ret_debug();
  inline void set_allocated_ret_debug(::std::string* ret_debug);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_update_config_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ret_debug();
  inline void clear_has_ret_debug();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 ret_;
  ::std::string* ret_debug_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static area_update_config_ack* default_instance_;
};
// -------------------------------------------------------------------

class area_monitor_data_reset_ntf : public ::google::protobuf::Message {
 public:
  area_monitor_data_reset_ntf();
  virtual ~area_monitor_data_reset_ntf();

  area_monitor_data_reset_ntf(const area_monitor_data_reset_ntf& from);

  inline area_monitor_data_reset_ntf& operator=(const area_monitor_data_reset_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_monitor_data_reset_ntf& default_instance();

  void Swap(area_monitor_data_reset_ntf* other);

  // implements Message ----------------------------------------------

  area_monitor_data_reset_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_monitor_data_reset_ntf& from);
  void MergeFrom(const area_monitor_data_reset_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_monitor_data_reset_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional bool gate_net = 2;
  inline bool has_gate_net() const;
  inline void clear_gate_net();
  static const int kGateNetFieldNumber = 2;
  inline bool gate_net() const;
  inline void set_gate_net(bool value);

  // optional bool db_mem = 3;
  inline bool has_db_mem() const;
  inline void clear_db_mem();
  static const int kDbMemFieldNumber = 3;
  inline bool db_mem() const;
  inline void set_db_mem(bool value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_monitor_data_reset_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_gate_net();
  inline void clear_has_gate_net();
  inline void set_has_db_mem();
  inline void clear_has_db_mem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  bool gate_net_;
  bool db_mem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static area_monitor_data_reset_ntf* default_instance_;
};
// -------------------------------------------------------------------

class assign_new_master_req : public ::google::protobuf::Message {
 public:
  assign_new_master_req();
  virtual ~assign_new_master_req();

  assign_new_master_req(const assign_new_master_req& from);

  inline assign_new_master_req& operator=(const assign_new_master_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const assign_new_master_req& default_instance();

  void Swap(assign_new_master_req* other);

  // implements Message ----------------------------------------------

  assign_new_master_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const assign_new_master_req& from);
  void MergeFrom(const assign_new_master_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = assign_new_master_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 master_server_type = 2;
  inline bool has_master_server_type() const;
  inline void clear_master_server_type();
  static const int kMasterServerTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 master_server_type() const;
  inline void set_master_server_type(::google::protobuf::uint32 value);

  // optional uint64 master_server_id = 3;
  inline bool has_master_server_id() const;
  inline void clear_master_server_id();
  static const int kMasterServerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 master_server_id() const;
  inline void set_master_server_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.assign_new_master_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_master_server_type();
  inline void clear_has_master_server_type();
  inline void set_has_master_server_id();
  inline void clear_has_master_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 master_server_type_;
  ::google::protobuf::uint64 master_server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static assign_new_master_req* default_instance_;
};
// -------------------------------------------------------------------

class register_master_info_req : public ::google::protobuf::Message {
 public:
  register_master_info_req();
  virtual ~register_master_info_req();

  register_master_info_req(const register_master_info_req& from);

  inline register_master_info_req& operator=(const register_master_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_master_info_req& default_instance();

  void Swap(register_master_info_req* other);

  // implements Message ----------------------------------------------

  register_master_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const register_master_info_req& from);
  void MergeFrom(const register_master_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = register_master_info_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 master_server_type = 2;
  inline bool has_master_server_type() const;
  inline void clear_master_server_type();
  static const int kMasterServerTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 master_server_type() const;
  inline void set_master_server_type(::google::protobuf::uint32 value);

  // optional uint64 master_server_id = 3;
  inline bool has_master_server_id() const;
  inline void clear_master_server_id();
  static const int kMasterServerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 master_server_id() const;
  inline void set_master_server_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.register_master_info_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_master_server_type();
  inline void clear_has_master_server_type();
  inline void set_has_master_server_id();
  inline void clear_has_master_server_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 master_server_type_;
  ::google::protobuf::uint64 master_server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static register_master_info_req* default_instance_;
};
// -------------------------------------------------------------------

class mail_item_data : public ::google::protobuf::Message {
 public:
  mail_item_data();
  virtual ~mail_item_data();

  mail_item_data(const mail_item_data& from);

  inline mail_item_data& operator=(const mail_item_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mail_item_data& default_instance();

  void Swap(mail_item_data* other);

  // implements Message ----------------------------------------------

  mail_item_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mail_item_data& from);
  void MergeFrom(const mail_item_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.mail_item_data)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static mail_item_data* default_instance_;
};
// -------------------------------------------------------------------

class gm_send_mail_req : public ::google::protobuf::Message {
 public:
  gm_send_mail_req();
  virtual ~gm_send_mail_req();

  gm_send_mail_req(const gm_send_mail_req& from);

  inline gm_send_mail_req& operator=(const gm_send_mail_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_send_mail_req& default_instance();

  void Swap(gm_send_mail_req* other);

  // implements Message ----------------------------------------------

  gm_send_mail_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_send_mail_req& from);
  void MergeFrom(const gm_send_mail_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_mail_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string mail_title = 2;
  inline bool has_mail_title() const;
  inline void clear_mail_title();
  static const int kMailTitleFieldNumber = 2;
  inline const ::std::string& mail_title() const;
  inline void set_mail_title(const ::std::string& value);
  inline void set_mail_title(const char* value);
  inline void set_mail_title(const char* value, size_t size);
  inline ::std::string* mutable_mail_title();
  inline ::std::string* release_mail_title();
  inline void set_allocated_mail_title(::std::string* mail_title);

  // optional string mail_content = 3;
  inline bool has_mail_content() const;
  inline void clear_mail_content();
  static const int kMailContentFieldNumber = 3;
  inline const ::std::string& mail_content() const;
  inline void set_mail_content(const ::std::string& value);
  inline void set_mail_content(const char* value);
  inline void set_mail_content(const char* value, size_t size);
  inline ::std::string* mutable_mail_content();
  inline ::std::string* release_mail_content();
  inline void set_allocated_mail_content(::std::string* mail_content);

  // repeated .SProtoSpace.mail_item_data mail_items = 4;
  inline int mail_items_size() const;
  inline void clear_mail_items();
  static const int kMailItemsFieldNumber = 4;
  inline const ::SProtoSpace::mail_item_data& mail_items(int index) const;
  inline ::SProtoSpace::mail_item_data* mutable_mail_items(int index);
  inline ::SProtoSpace::mail_item_data* add_mail_items();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::mail_item_data >&
      mail_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::mail_item_data >*
      mutable_mail_items();

  // optional uint64 to_role_id = 5;
  inline bool has_to_role_id() const;
  inline void clear_to_role_id();
  static const int kToRoleIdFieldNumber = 5;
  inline ::google::protobuf::uint64 to_role_id() const;
  inline void set_to_role_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_send_mail_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_mail_title();
  inline void clear_has_mail_title();
  inline void set_has_mail_content();
  inline void clear_has_mail_content();
  inline void set_has_to_role_id();
  inline void clear_has_to_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mail_title_;
  ::std::string* mail_content_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::mail_item_data > mail_items_;
  ::google::protobuf::uint64 to_role_id_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_send_mail_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_send_broadcast_req : public ::google::protobuf::Message {
 public:
  gm_send_broadcast_req();
  virtual ~gm_send_broadcast_req();

  gm_send_broadcast_req(const gm_send_broadcast_req& from);

  inline gm_send_broadcast_req& operator=(const gm_send_broadcast_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_send_broadcast_req& default_instance();

  void Swap(gm_send_broadcast_req* other);

  // implements Message ----------------------------------------------

  gm_send_broadcast_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_send_broadcast_req& from);
  void MergeFrom(const gm_send_broadcast_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_broadcast_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // optional string end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const char* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // repeated uint32 servers = 4;
  inline int servers_size() const;
  inline void clear_servers();
  static const int kServersFieldNumber = 4;
  inline ::google::protobuf::uint32 servers(int index) const;
  inline void set_servers(int index, ::google::protobuf::uint32 value);
  inline void add_servers(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      servers() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_servers();

  // optional uint32 intervals = 5;
  inline bool has_intervals() const;
  inline void clear_intervals();
  static const int kIntervalsFieldNumber = 5;
  inline ::google::protobuf::uint32 intervals() const;
  inline void set_intervals(::google::protobuf::uint32 value);

  // optional string content = 6;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 6;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_send_broadcast_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_intervals();
  inline void clear_has_intervals();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* start_time_;
  ::std::string* end_time_;
  int protoid_;
  ::google::protobuf::uint32 intervals_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > servers_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_send_broadcast_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_send_bulletin_req : public ::google::protobuf::Message {
 public:
  gm_send_bulletin_req();
  virtual ~gm_send_bulletin_req();

  gm_send_bulletin_req(const gm_send_bulletin_req& from);

  inline gm_send_bulletin_req& operator=(const gm_send_bulletin_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_send_bulletin_req& default_instance();

  void Swap(gm_send_bulletin_req* other);

  // implements Message ----------------------------------------------

  gm_send_bulletin_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_send_bulletin_req& from);
  void MergeFrom(const gm_send_bulletin_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_bulletin_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // optional string end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const char* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // optional uint32 channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional string title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 6;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 6;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_send_bulletin_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* start_time_;
  int protoid_;
  ::google::protobuf::uint32 channel_;
  ::std::string* end_time_;
  ::std::string* title_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_send_bulletin_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_send_shutdown_req : public ::google::protobuf::Message {
 public:
  gm_send_shutdown_req();
  virtual ~gm_send_shutdown_req();

  gm_send_shutdown_req(const gm_send_shutdown_req& from);

  inline gm_send_shutdown_req& operator=(const gm_send_shutdown_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_send_shutdown_req& default_instance();

  void Swap(gm_send_shutdown_req* other);

  // implements Message ----------------------------------------------

  gm_send_shutdown_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_send_shutdown_req& from);
  void MergeFrom(const gm_send_shutdown_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_shutdown_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string shutdown_time = 2;
  inline bool has_shutdown_time() const;
  inline void clear_shutdown_time();
  static const int kShutdownTimeFieldNumber = 2;
  inline const ::std::string& shutdown_time() const;
  inline void set_shutdown_time(const ::std::string& value);
  inline void set_shutdown_time(const char* value);
  inline void set_shutdown_time(const char* value, size_t size);
  inline ::std::string* mutable_shutdown_time();
  inline ::std::string* release_shutdown_time();
  inline void set_allocated_shutdown_time(::std::string* shutdown_time);

  // optional int32 signal = 3;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 3;
  inline ::google::protobuf::int32 signal() const;
  inline void set_signal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_send_shutdown_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_shutdown_time();
  inline void clear_has_shutdown_time();
  inline void set_has_signal();
  inline void clear_has_signal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* shutdown_time_;
  int protoid_;
  ::google::protobuf::int32 signal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_send_shutdown_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_open_login_whitelist_req : public ::google::protobuf::Message {
 public:
  gm_open_login_whitelist_req();
  virtual ~gm_open_login_whitelist_req();

  gm_open_login_whitelist_req(const gm_open_login_whitelist_req& from);

  inline gm_open_login_whitelist_req& operator=(const gm_open_login_whitelist_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_open_login_whitelist_req& default_instance();

  void Swap(gm_open_login_whitelist_req* other);

  // implements Message ----------------------------------------------

  gm_open_login_whitelist_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_open_login_whitelist_req& from);
  void MergeFrom(const gm_open_login_whitelist_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_open_login_whitelist_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional bool is_open = 2;
  inline bool has_is_open() const;
  inline void clear_is_open();
  static const int kIsOpenFieldNumber = 2;
  inline bool is_open() const;
  inline void set_is_open(bool value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_open_login_whitelist_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_is_open();
  inline void clear_has_is_open();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  bool is_open_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_open_login_whitelist_req* default_instance_;
};
// -------------------------------------------------------------------

class gm_add_login_whitelist_req : public ::google::protobuf::Message {
 public:
  gm_add_login_whitelist_req();
  virtual ~gm_add_login_whitelist_req();

  gm_add_login_whitelist_req(const gm_add_login_whitelist_req& from);

  inline gm_add_login_whitelist_req& operator=(const gm_add_login_whitelist_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_add_login_whitelist_req& default_instance();

  void Swap(gm_add_login_whitelist_req* other);

  // implements Message ----------------------------------------------

  gm_add_login_whitelist_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_add_login_whitelist_req& from);
  void MergeFrom(const gm_add_login_whitelist_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_add_login_whitelist_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated string account = 2;
  inline int account_size() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account(int index) const;
  inline ::std::string* mutable_account(int index);
  inline void set_account(int index, const ::std::string& value);
  inline void set_account(int index, const char* value);
  inline void set_account(int index, const char* value, size_t size);
  inline ::std::string* add_account();
  inline void add_account(const ::std::string& value);
  inline void add_account(const char* value);
  inline void add_account(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& account() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_account();

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm_add_login_whitelist_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> account_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fmanager_2eproto();
  friend void protobuf_AssignDesc_ss_5fmanager_2eproto();
  friend void protobuf_ShutdownFile_ss_5fmanager_2eproto();

  void InitAsDefaultInstance();
  static gm_add_login_whitelist_req* default_instance_;
};
// ===================================================================


// ===================================================================

// listen_node

// optional uint64 pipe_id = 1;
inline bool listen_node::has_pipe_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void listen_node::set_has_pipe_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void listen_node::clear_has_pipe_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void listen_node::clear_pipe_id() {
  pipe_id_ = GOOGLE_ULONGLONG(0);
  clear_has_pipe_id();
}
inline ::google::protobuf::uint64 listen_node::pipe_id() const {
  return pipe_id_;
}
inline void listen_node::set_pipe_id(::google::protobuf::uint64 value) {
  set_has_pipe_id();
  pipe_id_ = value;
}

// optional uint32 listen_ip = 2;
inline bool listen_node::has_listen_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void listen_node::set_has_listen_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void listen_node::clear_has_listen_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void listen_node::clear_listen_ip() {
  listen_ip_ = 0u;
  clear_has_listen_ip();
}
inline ::google::protobuf::uint32 listen_node::listen_ip() const {
  return listen_ip_;
}
inline void listen_node::set_listen_ip(::google::protobuf::uint32 value) {
  set_has_listen_ip();
  listen_ip_ = value;
}

// optional uint32 listen_port = 3;
inline bool listen_node::has_listen_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void listen_node::set_has_listen_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void listen_node::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void listen_node::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 listen_node::listen_port() const {
  return listen_port_;
}
inline void listen_node::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// -------------------------------------------------------------------

// connect_relateion

// optional uint32 type = 1;
inline bool connect_relateion::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connect_relateion::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connect_relateion::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connect_relateion::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 connect_relateion::type() const {
  return type_;
}
inline void connect_relateion::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated uint32 connect = 2;
inline int connect_relateion::connect_size() const {
  return connect_.size();
}
inline void connect_relateion::clear_connect() {
  connect_.Clear();
}
inline ::google::protobuf::uint32 connect_relateion::connect(int index) const {
  return connect_.Get(index);
}
inline void connect_relateion::set_connect(int index, ::google::protobuf::uint32 value) {
  connect_.Set(index, value);
}
inline void connect_relateion::add_connect(::google::protobuf::uint32 value) {
  connect_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
connect_relateion::connect() const {
  return connect_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
connect_relateion::mutable_connect() {
  return &connect_;
}

// -------------------------------------------------------------------

// connect_info

// optional uint32 version = 1;
inline bool connect_info::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connect_info::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connect_info::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connect_info::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 connect_info::version() const {
  return version_;
}
inline void connect_info::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional uint32 send_buffer_size = 2;
inline bool connect_info::has_send_buffer_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connect_info::set_has_send_buffer_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connect_info::clear_has_send_buffer_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connect_info::clear_send_buffer_size() {
  send_buffer_size_ = 0u;
  clear_has_send_buffer_size();
}
inline ::google::protobuf::uint32 connect_info::send_buffer_size() const {
  return send_buffer_size_;
}
inline void connect_info::set_send_buffer_size(::google::protobuf::uint32 value) {
  set_has_send_buffer_size();
  send_buffer_size_ = value;
}

// optional uint32 recv_buffer_size = 3;
inline bool connect_info::has_recv_buffer_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connect_info::set_has_recv_buffer_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connect_info::clear_has_recv_buffer_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connect_info::clear_recv_buffer_size() {
  recv_buffer_size_ = 0u;
  clear_has_recv_buffer_size();
}
inline ::google::protobuf::uint32 connect_info::recv_buffer_size() const {
  return recv_buffer_size_;
}
inline void connect_info::set_recv_buffer_size(::google::protobuf::uint32 value) {
  set_has_recv_buffer_size();
  recv_buffer_size_ = value;
}

// repeated .SProtoSpace.connect_relateion connection = 4;
inline int connect_info::connection_size() const {
  return connection_.size();
}
inline void connect_info::clear_connection() {
  connection_.Clear();
}
inline const ::SProtoSpace::connect_relateion& connect_info::connection(int index) const {
  return connection_.Get(index);
}
inline ::SProtoSpace::connect_relateion* connect_info::mutable_connection(int index) {
  return connection_.Mutable(index);
}
inline ::SProtoSpace::connect_relateion* connect_info::add_connection() {
  return connection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::connect_relateion >&
connect_info::connection() const {
  return connection_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::connect_relateion >*
connect_info::mutable_connection() {
  return &connection_;
}

// repeated .SProtoSpace.listen_node active_node = 5;
inline int connect_info::active_node_size() const {
  return active_node_.size();
}
inline void connect_info::clear_active_node() {
  active_node_.Clear();
}
inline const ::SProtoSpace::listen_node& connect_info::active_node(int index) const {
  return active_node_.Get(index);
}
inline ::SProtoSpace::listen_node* connect_info::mutable_active_node(int index) {
  return active_node_.Mutable(index);
}
inline ::SProtoSpace::listen_node* connect_info::add_active_node() {
  return active_node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::listen_node >&
connect_info::active_node() const {
  return active_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::listen_node >*
connect_info::mutable_active_node() {
  return &active_node_;
}

// -------------------------------------------------------------------

// gateserver_info

// optional uint32 server_group_id = 1;
inline bool gateserver_info::has_server_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gateserver_info::set_has_server_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gateserver_info::clear_has_server_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gateserver_info::clear_server_group_id() {
  server_group_id_ = 0u;
  clear_has_server_group_id();
}
inline ::google::protobuf::uint32 gateserver_info::server_group_id() const {
  return server_group_id_;
}
inline void gateserver_info::set_server_group_id(::google::protobuf::uint32 value) {
  set_has_server_group_id();
  server_group_id_ = value;
}

// optional uint32 server_area_id = 2;
inline bool gateserver_info::has_server_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gateserver_info::set_has_server_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gateserver_info::clear_has_server_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gateserver_info::clear_server_area_id() {
  server_area_id_ = 0u;
  clear_has_server_area_id();
}
inline ::google::protobuf::uint32 gateserver_info::server_area_id() const {
  return server_area_id_;
}
inline void gateserver_info::set_server_area_id(::google::protobuf::uint32 value) {
  set_has_server_area_id();
  server_area_id_ = value;
}

// optional uint32 server_index = 3;
inline bool gateserver_info::has_server_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gateserver_info::set_has_server_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gateserver_info::clear_has_server_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gateserver_info::clear_server_index() {
  server_index_ = 0u;
  clear_has_server_index();
}
inline ::google::protobuf::uint32 gateserver_info::server_index() const {
  return server_index_;
}
inline void gateserver_info::set_server_index(::google::protobuf::uint32 value) {
  set_has_server_index();
  server_index_ = value;
}

// optional uint64 ip = 4;
inline bool gateserver_info::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gateserver_info::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gateserver_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gateserver_info::clear_ip() {
  ip_ = GOOGLE_ULONGLONG(0);
  clear_has_ip();
}
inline ::google::protobuf::uint64 gateserver_info::ip() const {
  return ip_;
}
inline void gateserver_info::set_ip(::google::protobuf::uint64 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 5;
inline bool gateserver_info::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gateserver_info::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gateserver_info::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gateserver_info::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 gateserver_info::port() const {
  return port_;
}
inline void gateserver_info::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 status = 6;
inline bool gateserver_info::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gateserver_info::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gateserver_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gateserver_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 gateserver_info::status() const {
  return status_;
}
inline void gateserver_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 login_role_count = 7;
inline bool gateserver_info::has_login_role_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gateserver_info::set_has_login_role_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gateserver_info::clear_has_login_role_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gateserver_info::clear_login_role_count() {
  login_role_count_ = GOOGLE_ULONGLONG(0);
  clear_has_login_role_count();
}
inline ::google::protobuf::uint64 gateserver_info::login_role_count() const {
  return login_role_count_;
}
inline void gateserver_info::set_login_role_count(::google::protobuf::uint64 value) {
  set_has_login_role_count();
  login_role_count_ = value;
}

// optional uint32 center_server_count = 8;
inline bool gateserver_info::has_center_server_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void gateserver_info::set_has_center_server_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void gateserver_info::clear_has_center_server_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void gateserver_info::clear_center_server_count() {
  center_server_count_ = 0u;
  clear_has_center_server_count();
}
inline ::google::protobuf::uint32 gateserver_info::center_server_count() const {
  return center_server_count_;
}
inline void gateserver_info::set_center_server_count(::google::protobuf::uint32 value) {
  set_has_center_server_count();
  center_server_count_ = value;
}

// optional uint32 game_server_count = 9;
inline bool gateserver_info::has_game_server_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void gateserver_info::set_has_game_server_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void gateserver_info::clear_has_game_server_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void gateserver_info::clear_game_server_count() {
  game_server_count_ = 0u;
  clear_has_game_server_count();
}
inline ::google::protobuf::uint32 gateserver_info::game_server_count() const {
  return game_server_count_;
}
inline void gateserver_info::set_game_server_count(::google::protobuf::uint32 value) {
  set_has_game_server_count();
  game_server_count_ = value;
}

// optional uint32 battel_server_count = 10;
inline bool gateserver_info::has_battel_server_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void gateserver_info::set_has_battel_server_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void gateserver_info::clear_has_battel_server_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void gateserver_info::clear_battel_server_count() {
  battel_server_count_ = 0u;
  clear_has_battel_server_count();
}
inline ::google::protobuf::uint32 gateserver_info::battel_server_count() const {
  return battel_server_count_;
}
inline void gateserver_info::set_battel_server_count(::google::protobuf::uint32 value) {
  set_has_battel_server_count();
  battel_server_count_ = value;
}

// optional uint32 db_server_count = 11;
inline bool gateserver_info::has_db_server_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void gateserver_info::set_has_db_server_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void gateserver_info::clear_has_db_server_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void gateserver_info::clear_db_server_count() {
  db_server_count_ = 0u;
  clear_has_db_server_count();
}
inline ::google::protobuf::uint32 gateserver_info::db_server_count() const {
  return db_server_count_;
}
inline void gateserver_info::set_db_server_count(::google::protobuf::uint32 value) {
  set_has_db_server_count();
  db_server_count_ = value;
}

// optional uint32 mail_server_count = 12;
inline bool gateserver_info::has_mail_server_count() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void gateserver_info::set_has_mail_server_count() {
  _has_bits_[0] |= 0x00000800u;
}
inline void gateserver_info::clear_has_mail_server_count() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void gateserver_info::clear_mail_server_count() {
  mail_server_count_ = 0u;
  clear_has_mail_server_count();
}
inline ::google::protobuf::uint32 gateserver_info::mail_server_count() const {
  return mail_server_count_;
}
inline void gateserver_info::set_mail_server_count(::google::protobuf::uint32 value) {
  set_has_mail_server_count();
  mail_server_count_ = value;
}

// -------------------------------------------------------------------

// gameserver_info

// optional uint32 server_group_id = 1;
inline bool gameserver_info::has_server_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gameserver_info::set_has_server_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gameserver_info::clear_has_server_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gameserver_info::clear_server_group_id() {
  server_group_id_ = 0u;
  clear_has_server_group_id();
}
inline ::google::protobuf::uint32 gameserver_info::server_group_id() const {
  return server_group_id_;
}
inline void gameserver_info::set_server_group_id(::google::protobuf::uint32 value) {
  set_has_server_group_id();
  server_group_id_ = value;
}

// optional uint32 server_area_id = 2;
inline bool gameserver_info::has_server_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gameserver_info::set_has_server_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gameserver_info::clear_has_server_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gameserver_info::clear_server_area_id() {
  server_area_id_ = 0u;
  clear_has_server_area_id();
}
inline ::google::protobuf::uint32 gameserver_info::server_area_id() const {
  return server_area_id_;
}
inline void gameserver_info::set_server_area_id(::google::protobuf::uint32 value) {
  set_has_server_area_id();
  server_area_id_ = value;
}

// optional uint32 server_index = 3;
inline bool gameserver_info::has_server_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gameserver_info::set_has_server_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gameserver_info::clear_has_server_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gameserver_info::clear_server_index() {
  server_index_ = 0u;
  clear_has_server_index();
}
inline ::google::protobuf::uint32 gameserver_info::server_index() const {
  return server_index_;
}
inline void gameserver_info::set_server_index(::google::protobuf::uint32 value) {
  set_has_server_index();
  server_index_ = value;
}

// optional uint64 ip = 4;
inline bool gameserver_info::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gameserver_info::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gameserver_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gameserver_info::clear_ip() {
  ip_ = GOOGLE_ULONGLONG(0);
  clear_has_ip();
}
inline ::google::protobuf::uint64 gameserver_info::ip() const {
  return ip_;
}
inline void gameserver_info::set_ip(::google::protobuf::uint64 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 5;
inline bool gameserver_info::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gameserver_info::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gameserver_info::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gameserver_info::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 gameserver_info::port() const {
  return port_;
}
inline void gameserver_info::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 status = 6;
inline bool gameserver_info::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gameserver_info::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gameserver_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gameserver_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 gameserver_info::status() const {
  return status_;
}
inline void gameserver_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 login_role_count = 7;
inline bool gameserver_info::has_login_role_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gameserver_info::set_has_login_role_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gameserver_info::clear_has_login_role_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gameserver_info::clear_login_role_count() {
  login_role_count_ = GOOGLE_ULONGLONG(0);
  clear_has_login_role_count();
}
inline ::google::protobuf::uint64 gameserver_info::login_role_count() const {
  return login_role_count_;
}
inline void gameserver_info::set_login_role_count(::google::protobuf::uint64 value) {
  set_has_login_role_count();
  login_role_count_ = value;
}

// optional uint32 gate_server_count = 8;
inline bool gameserver_info::has_gate_server_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void gameserver_info::set_has_gate_server_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void gameserver_info::clear_has_gate_server_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void gameserver_info::clear_gate_server_count() {
  gate_server_count_ = 0u;
  clear_has_gate_server_count();
}
inline ::google::protobuf::uint32 gameserver_info::gate_server_count() const {
  return gate_server_count_;
}
inline void gameserver_info::set_gate_server_count(::google::protobuf::uint32 value) {
  set_has_gate_server_count();
  gate_server_count_ = value;
}

// optional uint32 mail_server_count = 9;
inline bool gameserver_info::has_mail_server_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void gameserver_info::set_has_mail_server_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void gameserver_info::clear_has_mail_server_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void gameserver_info::clear_mail_server_count() {
  mail_server_count_ = 0u;
  clear_has_mail_server_count();
}
inline ::google::protobuf::uint32 gameserver_info::mail_server_count() const {
  return mail_server_count_;
}
inline void gameserver_info::set_mail_server_count(::google::protobuf::uint32 value) {
  set_has_mail_server_count();
  mail_server_count_ = value;
}

// optional uint32 battel_server_count = 10;
inline bool gameserver_info::has_battel_server_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void gameserver_info::set_has_battel_server_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void gameserver_info::clear_has_battel_server_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void gameserver_info::clear_battel_server_count() {
  battel_server_count_ = 0u;
  clear_has_battel_server_count();
}
inline ::google::protobuf::uint32 gameserver_info::battel_server_count() const {
  return battel_server_count_;
}
inline void gameserver_info::set_battel_server_count(::google::protobuf::uint32 value) {
  set_has_battel_server_count();
  battel_server_count_ = value;
}

// optional uint32 db_server_count = 11;
inline bool gameserver_info::has_db_server_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void gameserver_info::set_has_db_server_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void gameserver_info::clear_has_db_server_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void gameserver_info::clear_db_server_count() {
  db_server_count_ = 0u;
  clear_has_db_server_count();
}
inline ::google::protobuf::uint32 gameserver_info::db_server_count() const {
  return db_server_count_;
}
inline void gameserver_info::set_db_server_count(::google::protobuf::uint32 value) {
  set_has_db_server_count();
  db_server_count_ = value;
}

// -------------------------------------------------------------------

// dbserver_info

// optional uint32 server_group_id = 1;
inline bool dbserver_info::has_server_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbserver_info::set_has_server_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbserver_info::clear_has_server_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbserver_info::clear_server_group_id() {
  server_group_id_ = 0u;
  clear_has_server_group_id();
}
inline ::google::protobuf::uint32 dbserver_info::server_group_id() const {
  return server_group_id_;
}
inline void dbserver_info::set_server_group_id(::google::protobuf::uint32 value) {
  set_has_server_group_id();
  server_group_id_ = value;
}

// optional uint32 server_area_id = 2;
inline bool dbserver_info::has_server_area_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbserver_info::set_has_server_area_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbserver_info::clear_has_server_area_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbserver_info::clear_server_area_id() {
  server_area_id_ = 0u;
  clear_has_server_area_id();
}
inline ::google::protobuf::uint32 dbserver_info::server_area_id() const {
  return server_area_id_;
}
inline void dbserver_info::set_server_area_id(::google::protobuf::uint32 value) {
  set_has_server_area_id();
  server_area_id_ = value;
}

// optional uint32 server_index = 3;
inline bool dbserver_info::has_server_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbserver_info::set_has_server_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dbserver_info::clear_has_server_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dbserver_info::clear_server_index() {
  server_index_ = 0u;
  clear_has_server_index();
}
inline ::google::protobuf::uint32 dbserver_info::server_index() const {
  return server_index_;
}
inline void dbserver_info::set_server_index(::google::protobuf::uint32 value) {
  set_has_server_index();
  server_index_ = value;
}

// optional uint64 ip = 4;
inline bool dbserver_info::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbserver_info::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dbserver_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dbserver_info::clear_ip() {
  ip_ = GOOGLE_ULONGLONG(0);
  clear_has_ip();
}
inline ::google::protobuf::uint64 dbserver_info::ip() const {
  return ip_;
}
inline void dbserver_info::set_ip(::google::protobuf::uint64 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 5;
inline bool dbserver_info::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbserver_info::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dbserver_info::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dbserver_info::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 dbserver_info::port() const {
  return port_;
}
inline void dbserver_info::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint32 status = 6;
inline bool dbserver_info::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbserver_info::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dbserver_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dbserver_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 dbserver_info::status() const {
  return status_;
}
inline void dbserver_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint64 redis_role_number = 7;
inline bool dbserver_info::has_redis_role_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbserver_info::set_has_redis_role_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dbserver_info::clear_has_redis_role_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dbserver_info::clear_redis_role_number() {
  redis_role_number_ = GOOGLE_ULONGLONG(0);
  clear_has_redis_role_number();
}
inline ::google::protobuf::uint64 dbserver_info::redis_role_number() const {
  return redis_role_number_;
}
inline void dbserver_info::set_redis_role_number(::google::protobuf::uint64 value) {
  set_has_redis_role_number();
  redis_role_number_ = value;
}

// optional uint64 redis_memory_usage = 8;
inline bool dbserver_info::has_redis_memory_usage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dbserver_info::set_has_redis_memory_usage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dbserver_info::clear_has_redis_memory_usage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dbserver_info::clear_redis_memory_usage() {
  redis_memory_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_redis_memory_usage();
}
inline ::google::protobuf::uint64 dbserver_info::redis_memory_usage() const {
  return redis_memory_usage_;
}
inline void dbserver_info::set_redis_memory_usage(::google::protobuf::uint64 value) {
  set_has_redis_memory_usage();
  redis_memory_usage_ = value;
}

// optional uint32 sql_status = 9;
inline bool dbserver_info::has_sql_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dbserver_info::set_has_sql_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dbserver_info::clear_has_sql_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dbserver_info::clear_sql_status() {
  sql_status_ = 0u;
  clear_has_sql_status();
}
inline ::google::protobuf::uint32 dbserver_info::sql_status() const {
  return sql_status_;
}
inline void dbserver_info::set_sql_status(::google::protobuf::uint32 value) {
  set_has_sql_status();
  sql_status_ = value;
}

// -------------------------------------------------------------------

// sync_connection_info_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_connection_info_req_id];
inline bool sync_connection_info_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sync_connection_info_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sync_connection_info_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sync_connection_info_req::clear_protoid() {
  protoid_ = 100;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID sync_connection_info_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void sync_connection_info_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// sync_connection_info_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_connection_info_ack_id];
inline bool sync_connection_info_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sync_connection_info_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sync_connection_info_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sync_connection_info_ack::clear_protoid() {
  protoid_ = 101;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID sync_connection_info_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void sync_connection_info_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.connect_info info = 2;
inline bool sync_connection_info_ack::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sync_connection_info_ack::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sync_connection_info_ack::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sync_connection_info_ack::clear_info() {
  if (info_ != NULL) info_->::SProtoSpace::connect_info::Clear();
  clear_has_info();
}
inline const ::SProtoSpace::connect_info& sync_connection_info_ack::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::SProtoSpace::connect_info* sync_connection_info_ack::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::SProtoSpace::connect_info;
  return info_;
}
inline ::SProtoSpace::connect_info* sync_connection_info_ack::release_info() {
  clear_has_info();
  ::SProtoSpace::connect_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void sync_connection_info_ack::set_allocated_info(::SProtoSpace::connect_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// node_version_info_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = node_version_info_ntf_id];
inline bool node_version_info_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void node_version_info_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void node_version_info_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void node_version_info_ntf::clear_protoid() {
  protoid_ = 102;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID node_version_info_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void node_version_info_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 version = 2;
inline bool node_version_info_ntf::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void node_version_info_ntf::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void node_version_info_ntf::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void node_version_info_ntf::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 node_version_info_ntf::version() const {
  return version_;
}
inline void node_version_info_ntf::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// sync_conection_info_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = sync_conection_info_ntf_id];
inline bool sync_conection_info_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sync_conection_info_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sync_conection_info_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sync_conection_info_ntf::clear_protoid() {
  protoid_ = 103;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID sync_conection_info_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void sync_conection_info_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.connect_info info = 2;
inline bool sync_conection_info_ntf::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sync_conection_info_ntf::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sync_conection_info_ntf::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sync_conection_info_ntf::clear_info() {
  if (info_ != NULL) info_->::SProtoSpace::connect_info::Clear();
  clear_has_info();
}
inline const ::SProtoSpace::connect_info& sync_conection_info_ntf::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::SProtoSpace::connect_info* sync_conection_info_ntf::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::SProtoSpace::connect_info;
  return info_;
}
inline ::SProtoSpace::connect_info* sync_conection_info_ntf::release_info() {
  clear_has_info();
  ::SProtoSpace::connect_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void sync_conection_info_ntf::set_allocated_info(::SProtoSpace::connect_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// register_listen_info_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = register_listen_info_req_id];
inline bool register_listen_info_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void register_listen_info_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void register_listen_info_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void register_listen_info_req::clear_protoid() {
  protoid_ = 104;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID register_listen_info_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void register_listen_info_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 listen_ip = 2;
inline bool register_listen_info_req::has_listen_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void register_listen_info_req::set_has_listen_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void register_listen_info_req::clear_has_listen_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void register_listen_info_req::clear_listen_ip() {
  listen_ip_ = 0u;
  clear_has_listen_ip();
}
inline ::google::protobuf::uint32 register_listen_info_req::listen_ip() const {
  return listen_ip_;
}
inline void register_listen_info_req::set_listen_ip(::google::protobuf::uint32 value) {
  set_has_listen_ip();
  listen_ip_ = value;
}

// optional uint32 listen_port = 3;
inline bool register_listen_info_req::has_listen_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void register_listen_info_req::set_has_listen_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void register_listen_info_req::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void register_listen_info_req::clear_listen_port() {
  listen_port_ = 0u;
  clear_has_listen_port();
}
inline ::google::protobuf::uint32 register_listen_info_req::listen_port() const {
  return listen_port_;
}
inline void register_listen_info_req::set_listen_port(::google::protobuf::uint32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// -------------------------------------------------------------------

// gm2manager_status_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2manager_status_req_id];
inline bool gm2manager_status_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm2manager_status_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm2manager_status_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm2manager_status_req::clear_protoid() {
  protoid_ = 110;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm2manager_status_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm2manager_status_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 info_detail = 2;
inline bool gm2manager_status_req::has_info_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm2manager_status_req::set_has_info_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm2manager_status_req::clear_has_info_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm2manager_status_req::clear_info_detail() {
  info_detail_ = GOOGLE_ULONGLONG(0);
  clear_has_info_detail();
}
inline ::google::protobuf::uint64 gm2manager_status_req::info_detail() const {
  return info_detail_;
}
inline void gm2manager_status_req::set_info_detail(::google::protobuf::uint64 value) {
  set_has_info_detail();
  info_detail_ = value;
}

// -------------------------------------------------------------------

// manager2gm_status_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = manager2gm_status_ack_id];
inline bool manager2gm_status_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void manager2gm_status_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void manager2gm_status_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void manager2gm_status_ack::clear_protoid() {
  protoid_ = 111;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID manager2gm_status_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void manager2gm_status_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 status = 2;
inline bool manager2gm_status_ack::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void manager2gm_status_ack::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void manager2gm_status_ack::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void manager2gm_status_ack::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::status() const {
  return status_;
}
inline void manager2gm_status_ack::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 game_count = 3;
inline bool manager2gm_status_ack::has_game_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void manager2gm_status_ack::set_has_game_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void manager2gm_status_ack::clear_has_game_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void manager2gm_status_ack::clear_game_count() {
  game_count_ = 0u;
  clear_has_game_count();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::game_count() const {
  return game_count_;
}
inline void manager2gm_status_ack::set_game_count(::google::protobuf::uint32 value) {
  set_has_game_count();
  game_count_ = value;
}

// optional uint32 db_count = 4;
inline bool manager2gm_status_ack::has_db_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void manager2gm_status_ack::set_has_db_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void manager2gm_status_ack::clear_has_db_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void manager2gm_status_ack::clear_db_count() {
  db_count_ = 0u;
  clear_has_db_count();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::db_count() const {
  return db_count_;
}
inline void manager2gm_status_ack::set_db_count(::google::protobuf::uint32 value) {
  set_has_db_count();
  db_count_ = value;
}

// optional uint32 gate_count = 5;
inline bool manager2gm_status_ack::has_gate_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void manager2gm_status_ack::set_has_gate_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void manager2gm_status_ack::clear_has_gate_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void manager2gm_status_ack::clear_gate_count() {
  gate_count_ = 0u;
  clear_has_gate_count();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::gate_count() const {
  return gate_count_;
}
inline void manager2gm_status_ack::set_gate_count(::google::protobuf::uint32 value) {
  set_has_gate_count();
  gate_count_ = value;
}

// optional uint32 manager_count = 6;
inline bool manager2gm_status_ack::has_manager_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void manager2gm_status_ack::set_has_manager_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void manager2gm_status_ack::clear_has_manager_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void manager2gm_status_ack::clear_manager_count() {
  manager_count_ = 0u;
  clear_has_manager_count();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::manager_count() const {
  return manager_count_;
}
inline void manager2gm_status_ack::set_manager_count(::google::protobuf::uint32 value) {
  set_has_manager_count();
  manager_count_ = value;
}

// repeated uint64 overload_pipe_ids = 7;
inline int manager2gm_status_ack::overload_pipe_ids_size() const {
  return overload_pipe_ids_.size();
}
inline void manager2gm_status_ack::clear_overload_pipe_ids() {
  overload_pipe_ids_.Clear();
}
inline ::google::protobuf::uint64 manager2gm_status_ack::overload_pipe_ids(int index) const {
  return overload_pipe_ids_.Get(index);
}
inline void manager2gm_status_ack::set_overload_pipe_ids(int index, ::google::protobuf::uint64 value) {
  overload_pipe_ids_.Set(index, value);
}
inline void manager2gm_status_ack::add_overload_pipe_ids(::google::protobuf::uint64 value) {
  overload_pipe_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
manager2gm_status_ack::overload_pipe_ids() const {
  return overload_pipe_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
manager2gm_status_ack::mutable_overload_pipe_ids() {
  return &overload_pipe_ids_;
}

// optional uint32 area_id = 8;
inline bool manager2gm_status_ack::has_area_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void manager2gm_status_ack::set_has_area_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void manager2gm_status_ack::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void manager2gm_status_ack::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::area_id() const {
  return area_id_;
}
inline void manager2gm_status_ack::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional uint32 group_id = 9;
inline bool manager2gm_status_ack::has_group_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void manager2gm_status_ack::set_has_group_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void manager2gm_status_ack::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void manager2gm_status_ack::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 manager2gm_status_ack::group_id() const {
  return group_id_;
}
inline void manager2gm_status_ack::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional string area_name = 10;
inline bool manager2gm_status_ack::has_area_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void manager2gm_status_ack::set_has_area_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void manager2gm_status_ack::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void manager2gm_status_ack::clear_area_name() {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    area_name_->clear();
  }
  clear_has_area_name();
}
inline const ::std::string& manager2gm_status_ack::area_name() const {
  return *area_name_;
}
inline void manager2gm_status_ack::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void manager2gm_status_ack::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void manager2gm_status_ack::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* manager2gm_status_ack::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}
inline ::std::string* manager2gm_status_ack::release_area_name() {
  clear_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void manager2gm_status_ack::set_allocated_area_name(::std::string* area_name) {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    delete area_name_;
  }
  if (area_name) {
    set_has_area_name();
    area_name_ = area_name;
  } else {
    clear_has_area_name();
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gm2manager_area_info_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2manager_area_info_req_id];
inline bool gm2manager_area_info_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm2manager_area_info_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm2manager_area_info_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm2manager_area_info_req::clear_protoid() {
  protoid_ = 112;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm2manager_area_info_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm2manager_area_info_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 info_detail = 2;
inline bool gm2manager_area_info_req::has_info_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm2manager_area_info_req::set_has_info_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm2manager_area_info_req::clear_has_info_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm2manager_area_info_req::clear_info_detail() {
  info_detail_ = GOOGLE_ULONGLONG(0);
  clear_has_info_detail();
}
inline ::google::protobuf::uint64 gm2manager_area_info_req::info_detail() const {
  return info_detail_;
}
inline void gm2manager_area_info_req::set_info_detail(::google::protobuf::uint64 value) {
  set_has_info_detail();
  info_detail_ = value;
}

// -------------------------------------------------------------------

// manager2gm_area_info_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = manager2gm_area_info_ack_id];
inline bool manager2gm_area_info_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void manager2gm_area_info_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void manager2gm_area_info_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void manager2gm_area_info_ack::clear_protoid() {
  protoid_ = 113;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID manager2gm_area_info_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void manager2gm_area_info_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated .SProtoSpace.gameserver_info gameserver_this_area = 2;
inline int manager2gm_area_info_ack::gameserver_this_area_size() const {
  return gameserver_this_area_.size();
}
inline void manager2gm_area_info_ack::clear_gameserver_this_area() {
  gameserver_this_area_.Clear();
}
inline const ::SProtoSpace::gameserver_info& manager2gm_area_info_ack::gameserver_this_area(int index) const {
  return gameserver_this_area_.Get(index);
}
inline ::SProtoSpace::gameserver_info* manager2gm_area_info_ack::mutable_gameserver_this_area(int index) {
  return gameserver_this_area_.Mutable(index);
}
inline ::SProtoSpace::gameserver_info* manager2gm_area_info_ack::add_gameserver_this_area() {
  return gameserver_this_area_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gameserver_info >&
manager2gm_area_info_ack::gameserver_this_area() const {
  return gameserver_this_area_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gameserver_info >*
manager2gm_area_info_ack::mutable_gameserver_this_area() {
  return &gameserver_this_area_;
}

// repeated .SProtoSpace.dbserver_info dbserver_this_area = 3;
inline int manager2gm_area_info_ack::dbserver_this_area_size() const {
  return dbserver_this_area_.size();
}
inline void manager2gm_area_info_ack::clear_dbserver_this_area() {
  dbserver_this_area_.Clear();
}
inline const ::SProtoSpace::dbserver_info& manager2gm_area_info_ack::dbserver_this_area(int index) const {
  return dbserver_this_area_.Get(index);
}
inline ::SProtoSpace::dbserver_info* manager2gm_area_info_ack::mutable_dbserver_this_area(int index) {
  return dbserver_this_area_.Mutable(index);
}
inline ::SProtoSpace::dbserver_info* manager2gm_area_info_ack::add_dbserver_this_area() {
  return dbserver_this_area_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::dbserver_info >&
manager2gm_area_info_ack::dbserver_this_area() const {
  return dbserver_this_area_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::dbserver_info >*
manager2gm_area_info_ack::mutable_dbserver_this_area() {
  return &dbserver_this_area_;
}

// repeated .SProtoSpace.gateserver_info gateserver_this_area = 4;
inline int manager2gm_area_info_ack::gateserver_this_area_size() const {
  return gateserver_this_area_.size();
}
inline void manager2gm_area_info_ack::clear_gateserver_this_area() {
  gateserver_this_area_.Clear();
}
inline const ::SProtoSpace::gateserver_info& manager2gm_area_info_ack::gateserver_this_area(int index) const {
  return gateserver_this_area_.Get(index);
}
inline ::SProtoSpace::gateserver_info* manager2gm_area_info_ack::mutable_gateserver_this_area(int index) {
  return gateserver_this_area_.Mutable(index);
}
inline ::SProtoSpace::gateserver_info* manager2gm_area_info_ack::add_gateserver_this_area() {
  return gateserver_this_area_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gateserver_info >&
manager2gm_area_info_ack::gateserver_this_area() const {
  return gateserver_this_area_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gateserver_info >*
manager2gm_area_info_ack::mutable_gateserver_this_area() {
  return &gateserver_this_area_;
}

// -------------------------------------------------------------------

// gm_update_config_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_req_id];
inline bool gm_update_config_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_update_config_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_update_config_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_update_config_req::clear_protoid() {
  protoid_ = 114;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_update_config_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_update_config_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 update_time = 2;
inline bool gm_update_config_req::has_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_update_config_req::set_has_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_update_config_req::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_update_config_req::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 gm_update_config_req::update_time() const {
  return update_time_;
}
inline void gm_update_config_req::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
}

// -------------------------------------------------------------------

// gm_update_config_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_ack_id];
inline bool gm_update_config_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_update_config_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_update_config_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_update_config_ack::clear_protoid() {
  protoid_ = 115;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_update_config_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_update_config_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 ret = 2;
inline bool gm_update_config_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_update_config_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_update_config_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_update_config_ack::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 gm_update_config_ack::ret() const {
  return ret_;
}
inline void gm_update_config_ack::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// gm_update_config_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_update_config_ntf_id];
inline bool gm_update_config_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_update_config_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_update_config_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_update_config_ntf::clear_protoid() {
  protoid_ = 116;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_update_config_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_update_config_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 ret = 2;
inline bool gm_update_config_ntf::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_update_config_ntf::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_update_config_ntf::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_update_config_ntf::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 gm_update_config_ntf::ret() const {
  return ret_;
}
inline void gm_update_config_ntf::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional uint64 err_server_pipe = 3;
inline bool gm_update_config_ntf::has_err_server_pipe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gm_update_config_ntf::set_has_err_server_pipe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gm_update_config_ntf::clear_has_err_server_pipe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gm_update_config_ntf::clear_err_server_pipe() {
  err_server_pipe_ = GOOGLE_ULONGLONG(0);
  clear_has_err_server_pipe();
}
inline ::google::protobuf::uint64 gm_update_config_ntf::err_server_pipe() const {
  return err_server_pipe_;
}
inline void gm_update_config_ntf::set_err_server_pipe(::google::protobuf::uint64 value) {
  set_has_err_server_pipe();
  err_server_pipe_ = value;
}

// optional string ret_debug = 4;
inline bool gm_update_config_ntf::has_ret_debug() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gm_update_config_ntf::set_has_ret_debug() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gm_update_config_ntf::clear_has_ret_debug() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gm_update_config_ntf::clear_ret_debug() {
  if (ret_debug_ != &::google::protobuf::internal::kEmptyString) {
    ret_debug_->clear();
  }
  clear_has_ret_debug();
}
inline const ::std::string& gm_update_config_ntf::ret_debug() const {
  return *ret_debug_;
}
inline void gm_update_config_ntf::set_ret_debug(const ::std::string& value) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(value);
}
inline void gm_update_config_ntf::set_ret_debug(const char* value) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(value);
}
inline void gm_update_config_ntf::set_ret_debug(const char* value, size_t size) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_update_config_ntf::mutable_ret_debug() {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  return ret_debug_;
}
inline ::std::string* gm_update_config_ntf::release_ret_debug() {
  clear_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_debug_;
    ret_debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_update_config_ntf::set_allocated_ret_debug(::std::string* ret_debug) {
  if (ret_debug_ != &::google::protobuf::internal::kEmptyString) {
    delete ret_debug_;
  }
  if (ret_debug) {
    set_has_ret_debug();
    ret_debug_ = ret_debug;
  } else {
    clear_has_ret_debug();
    ret_debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_cancel_update_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_cancel_update_req_id];
inline bool area_cancel_update_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_cancel_update_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_cancel_update_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_cancel_update_req::clear_protoid() {
  protoid_ = 122;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_cancel_update_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_cancel_update_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// area_cancel_update_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_cancel_update_ack_id];
inline bool area_cancel_update_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_cancel_update_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_cancel_update_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_cancel_update_ack::clear_protoid() {
  protoid_ = 123;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_cancel_update_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_cancel_update_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 ret = 2;
inline bool area_cancel_update_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_cancel_update_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_cancel_update_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_cancel_update_ack::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 area_cancel_update_ack::ret() const {
  return ret_;
}
inline void area_cancel_update_ack::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// config_version_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = config_version_req_id];
inline bool config_version_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void config_version_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void config_version_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void config_version_req::clear_protoid() {
  protoid_ = 117;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID config_version_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void config_version_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// config_version_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = config_version_ack_id];
inline bool config_version_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void config_version_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void config_version_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void config_version_ack::clear_protoid() {
  protoid_ = 118;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID config_version_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void config_version_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 update_version = 2;
inline bool config_version_ack::has_update_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void config_version_ack::set_has_update_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void config_version_ack::clear_has_update_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void config_version_ack::clear_update_version() {
  update_version_ = GOOGLE_ULONGLONG(0);
  clear_has_update_version();
}
inline ::google::protobuf::uint64 config_version_ack::update_version() const {
  return update_version_;
}
inline void config_version_ack::set_update_version(::google::protobuf::uint64 value) {
  set_has_update_version();
  update_version_ = value;
}

// optional string update_name = 3;
inline bool config_version_ack::has_update_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void config_version_ack::set_has_update_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void config_version_ack::clear_has_update_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void config_version_ack::clear_update_name() {
  if (update_name_ != &::google::protobuf::internal::kEmptyString) {
    update_name_->clear();
  }
  clear_has_update_name();
}
inline const ::std::string& config_version_ack::update_name() const {
  return *update_name_;
}
inline void config_version_ack::set_update_name(const ::std::string& value) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(value);
}
inline void config_version_ack::set_update_name(const char* value) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(value);
}
inline void config_version_ack::set_update_name(const char* value, size_t size) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* config_version_ack::mutable_update_name() {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  return update_name_;
}
inline ::std::string* config_version_ack::release_update_name() {
  clear_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_name_;
    update_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void config_version_ack::set_allocated_update_name(::std::string* update_name) {
  if (update_name_ != &::google::protobuf::internal::kEmptyString) {
    delete update_name_;
  }
  if (update_name) {
    set_has_update_name();
    update_name_ = update_name;
  } else {
    clear_has_update_name();
    update_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_update_config_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_update_config_req_id];
inline bool area_update_config_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_update_config_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_update_config_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_update_config_req::clear_protoid() {
  protoid_ = 119;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_update_config_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_update_config_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 update_version = 2;
inline bool area_update_config_req::has_update_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_update_config_req::set_has_update_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_update_config_req::clear_has_update_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_update_config_req::clear_update_version() {
  update_version_ = GOOGLE_ULONGLONG(0);
  clear_has_update_version();
}
inline ::google::protobuf::uint64 area_update_config_req::update_version() const {
  return update_version_;
}
inline void area_update_config_req::set_update_version(::google::protobuf::uint64 value) {
  set_has_update_version();
  update_version_ = value;
}

// optional uint64 update_time = 3;
inline bool area_update_config_req::has_update_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area_update_config_req::set_has_update_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area_update_config_req::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area_update_config_req::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 area_update_config_req::update_time() const {
  return update_time_;
}
inline void area_update_config_req::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
}

// optional string update_name = 4;
inline bool area_update_config_req::has_update_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void area_update_config_req::set_has_update_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void area_update_config_req::clear_has_update_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void area_update_config_req::clear_update_name() {
  if (update_name_ != &::google::protobuf::internal::kEmptyString) {
    update_name_->clear();
  }
  clear_has_update_name();
}
inline const ::std::string& area_update_config_req::update_name() const {
  return *update_name_;
}
inline void area_update_config_req::set_update_name(const ::std::string& value) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(value);
}
inline void area_update_config_req::set_update_name(const char* value) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(value);
}
inline void area_update_config_req::set_update_name(const char* value, size_t size) {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  update_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area_update_config_req::mutable_update_name() {
  set_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    update_name_ = new ::std::string;
  }
  return update_name_;
}
inline ::std::string* area_update_config_req::release_update_name() {
  clear_has_update_name();
  if (update_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_name_;
    update_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area_update_config_req::set_allocated_update_name(::std::string* update_name) {
  if (update_name_ != &::google::protobuf::internal::kEmptyString) {
    delete update_name_;
  }
  if (update_name) {
    set_has_update_name();
    update_name_ = update_name;
  } else {
    clear_has_update_name();
    update_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_update_config_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_update_config_ack_id];
inline bool area_update_config_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_update_config_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_update_config_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_update_config_ack::clear_protoid() {
  protoid_ = 120;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_update_config_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_update_config_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 ret = 2;
inline bool area_update_config_ack::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_update_config_ack::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_update_config_ack::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_update_config_ack::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 area_update_config_ack::ret() const {
  return ret_;
}
inline void area_update_config_ack::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional string ret_debug = 3;
inline bool area_update_config_ack::has_ret_debug() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area_update_config_ack::set_has_ret_debug() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area_update_config_ack::clear_has_ret_debug() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area_update_config_ack::clear_ret_debug() {
  if (ret_debug_ != &::google::protobuf::internal::kEmptyString) {
    ret_debug_->clear();
  }
  clear_has_ret_debug();
}
inline const ::std::string& area_update_config_ack::ret_debug() const {
  return *ret_debug_;
}
inline void area_update_config_ack::set_ret_debug(const ::std::string& value) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(value);
}
inline void area_update_config_ack::set_ret_debug(const char* value) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(value);
}
inline void area_update_config_ack::set_ret_debug(const char* value, size_t size) {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  ret_debug_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area_update_config_ack::mutable_ret_debug() {
  set_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    ret_debug_ = new ::std::string;
  }
  return ret_debug_;
}
inline ::std::string* area_update_config_ack::release_ret_debug() {
  clear_has_ret_debug();
  if (ret_debug_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_debug_;
    ret_debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area_update_config_ack::set_allocated_ret_debug(::std::string* ret_debug) {
  if (ret_debug_ != &::google::protobuf::internal::kEmptyString) {
    delete ret_debug_;
  }
  if (ret_debug) {
    set_has_ret_debug();
    ret_debug_ = ret_debug;
  } else {
    clear_has_ret_debug();
    ret_debug_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_monitor_data_reset_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_monitor_data_reset_ntf_id];
inline bool area_monitor_data_reset_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_monitor_data_reset_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_monitor_data_reset_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_monitor_data_reset_ntf::clear_protoid() {
  protoid_ = 124;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_monitor_data_reset_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_monitor_data_reset_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional bool gate_net = 2;
inline bool area_monitor_data_reset_ntf::has_gate_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_monitor_data_reset_ntf::set_has_gate_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_monitor_data_reset_ntf::clear_has_gate_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_monitor_data_reset_ntf::clear_gate_net() {
  gate_net_ = false;
  clear_has_gate_net();
}
inline bool area_monitor_data_reset_ntf::gate_net() const {
  return gate_net_;
}
inline void area_monitor_data_reset_ntf::set_gate_net(bool value) {
  set_has_gate_net();
  gate_net_ = value;
}

// optional bool db_mem = 3;
inline bool area_monitor_data_reset_ntf::has_db_mem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area_monitor_data_reset_ntf::set_has_db_mem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area_monitor_data_reset_ntf::clear_has_db_mem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area_monitor_data_reset_ntf::clear_db_mem() {
  db_mem_ = false;
  clear_has_db_mem();
}
inline bool area_monitor_data_reset_ntf::db_mem() const {
  return db_mem_;
}
inline void area_monitor_data_reset_ntf::set_db_mem(bool value) {
  set_has_db_mem();
  db_mem_ = value;
}

// -------------------------------------------------------------------

// assign_new_master_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = assign_new_master_req_id];
inline bool assign_new_master_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void assign_new_master_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void assign_new_master_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void assign_new_master_req::clear_protoid() {
  protoid_ = 130;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID assign_new_master_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void assign_new_master_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 master_server_type = 2;
inline bool assign_new_master_req::has_master_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void assign_new_master_req::set_has_master_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void assign_new_master_req::clear_has_master_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void assign_new_master_req::clear_master_server_type() {
  master_server_type_ = 0u;
  clear_has_master_server_type();
}
inline ::google::protobuf::uint32 assign_new_master_req::master_server_type() const {
  return master_server_type_;
}
inline void assign_new_master_req::set_master_server_type(::google::protobuf::uint32 value) {
  set_has_master_server_type();
  master_server_type_ = value;
}

// optional uint64 master_server_id = 3;
inline bool assign_new_master_req::has_master_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void assign_new_master_req::set_has_master_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void assign_new_master_req::clear_has_master_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void assign_new_master_req::clear_master_server_id() {
  master_server_id_ = GOOGLE_ULONGLONG(0);
  clear_has_master_server_id();
}
inline ::google::protobuf::uint64 assign_new_master_req::master_server_id() const {
  return master_server_id_;
}
inline void assign_new_master_req::set_master_server_id(::google::protobuf::uint64 value) {
  set_has_master_server_id();
  master_server_id_ = value;
}

// -------------------------------------------------------------------

// register_master_info_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = register_master_info_req_id];
inline bool register_master_info_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void register_master_info_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void register_master_info_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void register_master_info_req::clear_protoid() {
  protoid_ = 131;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID register_master_info_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void register_master_info_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 master_server_type = 2;
inline bool register_master_info_req::has_master_server_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void register_master_info_req::set_has_master_server_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void register_master_info_req::clear_has_master_server_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void register_master_info_req::clear_master_server_type() {
  master_server_type_ = 0u;
  clear_has_master_server_type();
}
inline ::google::protobuf::uint32 register_master_info_req::master_server_type() const {
  return master_server_type_;
}
inline void register_master_info_req::set_master_server_type(::google::protobuf::uint32 value) {
  set_has_master_server_type();
  master_server_type_ = value;
}

// optional uint64 master_server_id = 3;
inline bool register_master_info_req::has_master_server_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void register_master_info_req::set_has_master_server_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void register_master_info_req::clear_has_master_server_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void register_master_info_req::clear_master_server_id() {
  master_server_id_ = GOOGLE_ULONGLONG(0);
  clear_has_master_server_id();
}
inline ::google::protobuf::uint64 register_master_info_req::master_server_id() const {
  return master_server_id_;
}
inline void register_master_info_req::set_master_server_id(::google::protobuf::uint64 value) {
  set_has_master_server_id();
  master_server_id_ = value;
}

// -------------------------------------------------------------------

// mail_item_data

// optional uint32 item_id = 1;
inline bool mail_item_data::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mail_item_data::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mail_item_data::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mail_item_data::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 mail_item_data::item_id() const {
  return item_id_;
}
inline void mail_item_data::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 item_num = 2;
inline bool mail_item_data::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mail_item_data::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mail_item_data::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mail_item_data::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 mail_item_data::item_num() const {
  return item_num_;
}
inline void mail_item_data::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// gm_send_mail_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_mail_req_id];
inline bool gm_send_mail_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_send_mail_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_send_mail_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_send_mail_req::clear_protoid() {
  protoid_ = 125;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_send_mail_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_send_mail_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string mail_title = 2;
inline bool gm_send_mail_req::has_mail_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_send_mail_req::set_has_mail_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_send_mail_req::clear_has_mail_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_send_mail_req::clear_mail_title() {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    mail_title_->clear();
  }
  clear_has_mail_title();
}
inline const ::std::string& gm_send_mail_req::mail_title() const {
  return *mail_title_;
}
inline void gm_send_mail_req::set_mail_title(const ::std::string& value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void gm_send_mail_req::set_mail_title(const char* value) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(value);
}
inline void gm_send_mail_req::set_mail_title(const char* value, size_t size) {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  mail_title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_mail_req::mutable_mail_title() {
  set_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    mail_title_ = new ::std::string;
  }
  return mail_title_;
}
inline ::std::string* gm_send_mail_req::release_mail_title() {
  clear_has_mail_title();
  if (mail_title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_title_;
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_mail_req::set_allocated_mail_title(::std::string* mail_title) {
  if (mail_title_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_title_;
  }
  if (mail_title) {
    set_has_mail_title();
    mail_title_ = mail_title;
  } else {
    clear_has_mail_title();
    mail_title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mail_content = 3;
inline bool gm_send_mail_req::has_mail_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gm_send_mail_req::set_has_mail_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gm_send_mail_req::clear_has_mail_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gm_send_mail_req::clear_mail_content() {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    mail_content_->clear();
  }
  clear_has_mail_content();
}
inline const ::std::string& gm_send_mail_req::mail_content() const {
  return *mail_content_;
}
inline void gm_send_mail_req::set_mail_content(const ::std::string& value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void gm_send_mail_req::set_mail_content(const char* value) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(value);
}
inline void gm_send_mail_req::set_mail_content(const char* value, size_t size) {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  mail_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_mail_req::mutable_mail_content() {
  set_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    mail_content_ = new ::std::string;
  }
  return mail_content_;
}
inline ::std::string* gm_send_mail_req::release_mail_content() {
  clear_has_mail_content();
  if (mail_content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_content_;
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_mail_req::set_allocated_mail_content(::std::string* mail_content) {
  if (mail_content_ != &::google::protobuf::internal::kEmptyString) {
    delete mail_content_;
  }
  if (mail_content) {
    set_has_mail_content();
    mail_content_ = mail_content;
  } else {
    clear_has_mail_content();
    mail_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SProtoSpace.mail_item_data mail_items = 4;
inline int gm_send_mail_req::mail_items_size() const {
  return mail_items_.size();
}
inline void gm_send_mail_req::clear_mail_items() {
  mail_items_.Clear();
}
inline const ::SProtoSpace::mail_item_data& gm_send_mail_req::mail_items(int index) const {
  return mail_items_.Get(index);
}
inline ::SProtoSpace::mail_item_data* gm_send_mail_req::mutable_mail_items(int index) {
  return mail_items_.Mutable(index);
}
inline ::SProtoSpace::mail_item_data* gm_send_mail_req::add_mail_items() {
  return mail_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::mail_item_data >&
gm_send_mail_req::mail_items() const {
  return mail_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::mail_item_data >*
gm_send_mail_req::mutable_mail_items() {
  return &mail_items_;
}

// optional uint64 to_role_id = 5;
inline bool gm_send_mail_req::has_to_role_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gm_send_mail_req::set_has_to_role_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gm_send_mail_req::clear_has_to_role_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gm_send_mail_req::clear_to_role_id() {
  to_role_id_ = GOOGLE_ULONGLONG(0);
  clear_has_to_role_id();
}
inline ::google::protobuf::uint64 gm_send_mail_req::to_role_id() const {
  return to_role_id_;
}
inline void gm_send_mail_req::set_to_role_id(::google::protobuf::uint64 value) {
  set_has_to_role_id();
  to_role_id_ = value;
}

// -------------------------------------------------------------------

// gm_send_broadcast_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_broadcast_req_id];
inline bool gm_send_broadcast_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_send_broadcast_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_send_broadcast_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_send_broadcast_req::clear_protoid() {
  protoid_ = 126;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_send_broadcast_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_send_broadcast_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string start_time = 2;
inline bool gm_send_broadcast_req::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_send_broadcast_req::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_send_broadcast_req::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_send_broadcast_req::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& gm_send_broadcast_req::start_time() const {
  return *start_time_;
}
inline void gm_send_broadcast_req::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void gm_send_broadcast_req::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void gm_send_broadcast_req::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_broadcast_req::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}
inline ::std::string* gm_send_broadcast_req::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_broadcast_req::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string end_time = 3;
inline bool gm_send_broadcast_req::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gm_send_broadcast_req::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gm_send_broadcast_req::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gm_send_broadcast_req::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& gm_send_broadcast_req::end_time() const {
  return *end_time_;
}
inline void gm_send_broadcast_req::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void gm_send_broadcast_req::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void gm_send_broadcast_req::set_end_time(const char* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_broadcast_req::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  return end_time_;
}
inline ::std::string* gm_send_broadcast_req::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_broadcast_req::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 servers = 4;
inline int gm_send_broadcast_req::servers_size() const {
  return servers_.size();
}
inline void gm_send_broadcast_req::clear_servers() {
  servers_.Clear();
}
inline ::google::protobuf::uint32 gm_send_broadcast_req::servers(int index) const {
  return servers_.Get(index);
}
inline void gm_send_broadcast_req::set_servers(int index, ::google::protobuf::uint32 value) {
  servers_.Set(index, value);
}
inline void gm_send_broadcast_req::add_servers(::google::protobuf::uint32 value) {
  servers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
gm_send_broadcast_req::servers() const {
  return servers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
gm_send_broadcast_req::mutable_servers() {
  return &servers_;
}

// optional uint32 intervals = 5;
inline bool gm_send_broadcast_req::has_intervals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gm_send_broadcast_req::set_has_intervals() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gm_send_broadcast_req::clear_has_intervals() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gm_send_broadcast_req::clear_intervals() {
  intervals_ = 0u;
  clear_has_intervals();
}
inline ::google::protobuf::uint32 gm_send_broadcast_req::intervals() const {
  return intervals_;
}
inline void gm_send_broadcast_req::set_intervals(::google::protobuf::uint32 value) {
  set_has_intervals();
  intervals_ = value;
}

// optional string content = 6;
inline bool gm_send_broadcast_req::has_content() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gm_send_broadcast_req::set_has_content() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gm_send_broadcast_req::clear_has_content() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gm_send_broadcast_req::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& gm_send_broadcast_req::content() const {
  return *content_;
}
inline void gm_send_broadcast_req::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gm_send_broadcast_req::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gm_send_broadcast_req::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_broadcast_req::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* gm_send_broadcast_req::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_broadcast_req::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gm_send_bulletin_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_bulletin_req_id];
inline bool gm_send_bulletin_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_send_bulletin_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_send_bulletin_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_send_bulletin_req::clear_protoid() {
  protoid_ = 127;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_send_bulletin_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_send_bulletin_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string start_time = 2;
inline bool gm_send_bulletin_req::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_send_bulletin_req::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_send_bulletin_req::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_send_bulletin_req::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& gm_send_bulletin_req::start_time() const {
  return *start_time_;
}
inline void gm_send_bulletin_req::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void gm_send_bulletin_req::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void gm_send_bulletin_req::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_bulletin_req::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}
inline ::std::string* gm_send_bulletin_req::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_bulletin_req::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string end_time = 3;
inline bool gm_send_bulletin_req::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gm_send_bulletin_req::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gm_send_bulletin_req::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gm_send_bulletin_req::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& gm_send_bulletin_req::end_time() const {
  return *end_time_;
}
inline void gm_send_bulletin_req::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void gm_send_bulletin_req::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
}
inline void gm_send_bulletin_req::set_end_time(const char* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_bulletin_req::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    end_time_ = new ::std::string;
  }
  return end_time_;
}
inline ::std::string* gm_send_bulletin_req::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_bulletin_req::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::kEmptyString) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 channel = 4;
inline bool gm_send_bulletin_req::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gm_send_bulletin_req::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gm_send_bulletin_req::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gm_send_bulletin_req::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 gm_send_bulletin_req::channel() const {
  return channel_;
}
inline void gm_send_bulletin_req::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string title = 5;
inline bool gm_send_bulletin_req::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gm_send_bulletin_req::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gm_send_bulletin_req::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gm_send_bulletin_req::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& gm_send_bulletin_req::title() const {
  return *title_;
}
inline void gm_send_bulletin_req::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void gm_send_bulletin_req::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void gm_send_bulletin_req::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_bulletin_req::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* gm_send_bulletin_req::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_bulletin_req::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 6;
inline bool gm_send_bulletin_req::has_content() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gm_send_bulletin_req::set_has_content() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gm_send_bulletin_req::clear_has_content() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gm_send_bulletin_req::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& gm_send_bulletin_req::content() const {
  return *content_;
}
inline void gm_send_bulletin_req::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gm_send_bulletin_req::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void gm_send_bulletin_req::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_bulletin_req::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* gm_send_bulletin_req::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_bulletin_req::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gm_send_shutdown_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_send_shutdown_req_id];
inline bool gm_send_shutdown_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_send_shutdown_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_send_shutdown_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_send_shutdown_req::clear_protoid() {
  protoid_ = 128;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_send_shutdown_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_send_shutdown_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string shutdown_time = 2;
inline bool gm_send_shutdown_req::has_shutdown_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_send_shutdown_req::set_has_shutdown_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_send_shutdown_req::clear_has_shutdown_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_send_shutdown_req::clear_shutdown_time() {
  if (shutdown_time_ != &::google::protobuf::internal::kEmptyString) {
    shutdown_time_->clear();
  }
  clear_has_shutdown_time();
}
inline const ::std::string& gm_send_shutdown_req::shutdown_time() const {
  return *shutdown_time_;
}
inline void gm_send_shutdown_req::set_shutdown_time(const ::std::string& value) {
  set_has_shutdown_time();
  if (shutdown_time_ == &::google::protobuf::internal::kEmptyString) {
    shutdown_time_ = new ::std::string;
  }
  shutdown_time_->assign(value);
}
inline void gm_send_shutdown_req::set_shutdown_time(const char* value) {
  set_has_shutdown_time();
  if (shutdown_time_ == &::google::protobuf::internal::kEmptyString) {
    shutdown_time_ = new ::std::string;
  }
  shutdown_time_->assign(value);
}
inline void gm_send_shutdown_req::set_shutdown_time(const char* value, size_t size) {
  set_has_shutdown_time();
  if (shutdown_time_ == &::google::protobuf::internal::kEmptyString) {
    shutdown_time_ = new ::std::string;
  }
  shutdown_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_send_shutdown_req::mutable_shutdown_time() {
  set_has_shutdown_time();
  if (shutdown_time_ == &::google::protobuf::internal::kEmptyString) {
    shutdown_time_ = new ::std::string;
  }
  return shutdown_time_;
}
inline ::std::string* gm_send_shutdown_req::release_shutdown_time() {
  clear_has_shutdown_time();
  if (shutdown_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shutdown_time_;
    shutdown_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gm_send_shutdown_req::set_allocated_shutdown_time(::std::string* shutdown_time) {
  if (shutdown_time_ != &::google::protobuf::internal::kEmptyString) {
    delete shutdown_time_;
  }
  if (shutdown_time) {
    set_has_shutdown_time();
    shutdown_time_ = shutdown_time;
  } else {
    clear_has_shutdown_time();
    shutdown_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 signal = 3;
inline bool gm_send_shutdown_req::has_signal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gm_send_shutdown_req::set_has_signal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gm_send_shutdown_req::clear_has_signal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gm_send_shutdown_req::clear_signal() {
  signal_ = 0;
  clear_has_signal();
}
inline ::google::protobuf::int32 gm_send_shutdown_req::signal() const {
  return signal_;
}
inline void gm_send_shutdown_req::set_signal(::google::protobuf::int32 value) {
  set_has_signal();
  signal_ = value;
}

// -------------------------------------------------------------------

// gm_open_login_whitelist_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_open_login_whitelist_req_id];
inline bool gm_open_login_whitelist_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_open_login_whitelist_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_open_login_whitelist_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_open_login_whitelist_req::clear_protoid() {
  protoid_ = 132;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_open_login_whitelist_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_open_login_whitelist_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional bool is_open = 2;
inline bool gm_open_login_whitelist_req::has_is_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm_open_login_whitelist_req::set_has_is_open() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm_open_login_whitelist_req::clear_has_is_open() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm_open_login_whitelist_req::clear_is_open() {
  is_open_ = false;
  clear_has_is_open();
}
inline bool gm_open_login_whitelist_req::is_open() const {
  return is_open_;
}
inline void gm_open_login_whitelist_req::set_is_open(bool value) {
  set_has_is_open();
  is_open_ = value;
}

// -------------------------------------------------------------------

// gm_add_login_whitelist_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm_add_login_whitelist_req_id];
inline bool gm_add_login_whitelist_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_add_login_whitelist_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_add_login_whitelist_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_add_login_whitelist_req::clear_protoid() {
  protoid_ = 133;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm_add_login_whitelist_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm_add_login_whitelist_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated string account = 2;
inline int gm_add_login_whitelist_req::account_size() const {
  return account_.size();
}
inline void gm_add_login_whitelist_req::clear_account() {
  account_.Clear();
}
inline const ::std::string& gm_add_login_whitelist_req::account(int index) const {
  return account_.Get(index);
}
inline ::std::string* gm_add_login_whitelist_req::mutable_account(int index) {
  return account_.Mutable(index);
}
inline void gm_add_login_whitelist_req::set_account(int index, const ::std::string& value) {
  account_.Mutable(index)->assign(value);
}
inline void gm_add_login_whitelist_req::set_account(int index, const char* value) {
  account_.Mutable(index)->assign(value);
}
inline void gm_add_login_whitelist_req::set_account(int index, const char* value, size_t size) {
  account_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gm_add_login_whitelist_req::add_account() {
  return account_.Add();
}
inline void gm_add_login_whitelist_req::add_account(const ::std::string& value) {
  account_.Add()->assign(value);
}
inline void gm_add_login_whitelist_req::add_account(const char* value) {
  account_.Add()->assign(value);
}
inline void gm_add_login_whitelist_req::add_account(const char* value, size_t size) {
  account_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
gm_add_login_whitelist_req::account() const {
  return account_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
gm_add_login_whitelist_req::mutable_account() {
  return &account_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SProtoSpace

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ss_5fmanager_2eproto__INCLUDED
