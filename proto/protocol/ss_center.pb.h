// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ss_center.proto

#ifndef PROTOBUF_ss_5fcenter_2eproto__INCLUDED
#define PROTOBUF_ss_5fcenter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ss_protoid.pb.h"
#include "cm_roletype.pb.h"
// @@protoc_insertion_point(includes)

namespace SProtoSpace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ss_5fcenter_2eproto();
void protobuf_AssignDesc_ss_5fcenter_2eproto();
void protobuf_ShutdownFile_ss_5fcenter_2eproto();

class gate_listen_report;
class gate_role_num_report;
class role_login_verify_req;
class role_login_verify_ack;
class kick_out_req;
class kick_out_ack;
class gt_reconnect_check_req;
class ct_reconnect_check_ack;
class ct_reconnect_kick_req;
class gt_reconnect_kick_ack;
class gt_online_client_ntf;
class gt_game_server_player_num_ntf;
class ct_need_queued_ntf;
class ct_end_queued_ntf;
class gt_queued_state_req;
class ct_queued_state_ack;
class gt_cancel_queue_req;
class ct_cancel_queue_ack;
class account_login_ntf;
class account_login_ntf_ack;
class area_list_req;
class gate_net_info;
class area_brief_info;
class area_record;
class group_area_info;
class area_list_ack;
class area_gateserver_info_req;
class area_gateserver_info_ack;
class area_gateserver_info_ntf;
class update_area_info_ntf;
class lc_heartbeat_req;
class lc_heartbeat_ack;
class role_leave_game_ntf;
class gm2center_close_req;
class center2gm_close_ack;
class gm2center_center_status_req;
class center2gm_center_status_ack;
class gm2center_center_reset_req;
class center2gm_center_reset_ack;

// ===================================================================

class gate_listen_report : public ::google::protobuf::Message {
 public:
  gate_listen_report();
  virtual ~gate_listen_report();

  gate_listen_report(const gate_listen_report& from);

  inline gate_listen_report& operator=(const gate_listen_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate_listen_report& default_instance();

  void Swap(gate_listen_report* other);

  // implements Message ----------------------------------------------

  gate_listen_report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate_listen_report& from);
  void MergeFrom(const gate_listen_report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gate_listen_report_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string Ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 Port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string GroupName = 4;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional bool new = 5;
  inline bool has_new_() const;
  inline void clear_new_();
  static const int kNewFieldNumber = 5;
  inline bool new_() const;
  inline void set_new_(bool value);

  // optional int32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional uint32 groupindex = 7;
  inline bool has_groupindex() const;
  inline void clear_groupindex();
  static const int kGroupindexFieldNumber = 7;
  inline ::google::protobuf::uint32 groupindex() const;
  inline void set_groupindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gate_listen_report)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_new_();
  inline void clear_has_new_();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_groupindex();
  inline void clear_has_groupindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  int protoid_;
  ::google::protobuf::int32 port_;
  ::std::string* groupname_;
  bool new__;
  ::google::protobuf::int32 state_;
  ::google::protobuf::uint32 groupindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gate_listen_report* default_instance_;
};
// -------------------------------------------------------------------

class gate_role_num_report : public ::google::protobuf::Message {
 public:
  gate_role_num_report();
  virtual ~gate_role_num_report();

  gate_role_num_report(const gate_role_num_report& from);

  inline gate_role_num_report& operator=(const gate_role_num_report& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate_role_num_report& default_instance();

  void Swap(gate_role_num_report* other);

  // implements Message ----------------------------------------------

  gate_role_num_report* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate_role_num_report& from);
  void MergeFrom(const gate_role_num_report& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gate_role_num_report_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gate_role_num_report)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gate_role_num_report* default_instance_;
};
// -------------------------------------------------------------------

class role_login_verify_req : public ::google::protobuf::Message {
 public:
  role_login_verify_req();
  virtual ~role_login_verify_req();

  role_login_verify_req(const role_login_verify_req& from);

  inline role_login_verify_req& operator=(const role_login_verify_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_login_verify_req& default_instance();

  void Swap(role_login_verify_req* other);

  // implements Message ----------------------------------------------

  role_login_verify_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_login_verify_req& from);
  void MergeFrom(const role_login_verify_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_login_verify_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 tempid = 4;
  inline bool has_tempid() const;
  inline void clear_tempid();
  static const int kTempidFieldNumber = 4;
  inline ::google::protobuf::uint32 tempid() const;
  inline void set_tempid(::google::protobuf::uint32 value);

  // optional uint32 clientid = 5;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 5;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 areaid = 6;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaidFieldNumber = 6;
  inline ::google::protobuf::uint32 areaid() const;
  inline void set_areaid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.role_login_verify_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_tempid();
  inline void clear_has_tempid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_areaid();
  inline void clear_has_areaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 tempid_;
  ::std::string* token_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 areaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static role_login_verify_req* default_instance_;
};
// -------------------------------------------------------------------

class role_login_verify_ack : public ::google::protobuf::Message {
 public:
  role_login_verify_ack();
  virtual ~role_login_verify_ack();

  role_login_verify_ack(const role_login_verify_ack& from);

  inline role_login_verify_ack& operator=(const role_login_verify_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_login_verify_ack& default_instance();

  void Swap(role_login_verify_ack* other);

  // implements Message ----------------------------------------------

  role_login_verify_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_login_verify_ack& from);
  void MergeFrom(const role_login_verify_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_login_verify_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional int32 retcode = 2;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 2;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 4;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 4;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional bool isreconnect = 6;
  inline bool has_isreconnect() const;
  inline void clear_isreconnect();
  static const int kIsreconnectFieldNumber = 6;
  inline bool isreconnect() const;
  inline void set_isreconnect(bool value);

  // optional uint32 areaid = 7;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaidFieldNumber = 7;
  inline ::google::protobuf::uint32 areaid() const;
  inline void set_areaid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.role_login_verify_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_isreconnect();
  inline void clear_has_isreconnect();
  inline void set_has_areaid();
  inline void clear_has_areaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::int32 retcode_;
  ::std::string* account_;
  ::std::string* token_;
  ::google::protobuf::uint32 clientid_;
  bool isreconnect_;
  ::google::protobuf::uint32 areaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static role_login_verify_ack* default_instance_;
};
// -------------------------------------------------------------------

class kick_out_req : public ::google::protobuf::Message {
 public:
  kick_out_req();
  virtual ~kick_out_req();

  kick_out_req(const kick_out_req& from);

  inline kick_out_req& operator=(const kick_out_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const kick_out_req& default_instance();

  void Swap(kick_out_req* other);

  // implements Message ----------------------------------------------

  kick_out_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kick_out_req& from);
  void MergeFrom(const kick_out_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = kick_out_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 newclientid = 3;
  inline bool has_newclientid() const;
  inline void clear_newclientid();
  static const int kNewclientidFieldNumber = 3;
  inline ::google::protobuf::uint32 newclientid() const;
  inline void set_newclientid(::google::protobuf::uint32 value);

  // optional uint64 newgateid = 4;
  inline bool has_newgateid() const;
  inline void clear_newgateid();
  static const int kNewgateidFieldNumber = 4;
  inline ::google::protobuf::uint64 newgateid() const;
  inline void set_newgateid(::google::protobuf::uint64 value);

  // optional .SProtoSpace.eKickoutReason reason = 5;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 5;
  inline ::SProtoSpace::eKickoutReason reason() const;
  inline void set_reason(::SProtoSpace::eKickoutReason value);

  // optional string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 areaid = 7;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaidFieldNumber = 7;
  inline ::google::protobuf::uint32 areaid() const;
  inline void set_areaid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.kick_out_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_newclientid();
  inline void clear_has_newclientid();
  inline void set_has_newgateid();
  inline void clear_has_newgateid();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_areaid();
  inline void clear_has_areaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 newclientid_;
  ::google::protobuf::uint64 newgateid_;
  ::std::string* token_;
  int reason_;
  ::google::protobuf::uint32 areaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static kick_out_req* default_instance_;
};
// -------------------------------------------------------------------

class kick_out_ack : public ::google::protobuf::Message {
 public:
  kick_out_ack();
  virtual ~kick_out_ack();

  kick_out_ack(const kick_out_ack& from);

  inline kick_out_ack& operator=(const kick_out_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const kick_out_ack& default_instance();

  void Swap(kick_out_ack* other);

  // implements Message ----------------------------------------------

  kick_out_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kick_out_ack& from);
  void MergeFrom(const kick_out_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = kick_out_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 newclientid = 4;
  inline bool has_newclientid() const;
  inline void clear_newclientid();
  static const int kNewclientidFieldNumber = 4;
  inline ::google::protobuf::uint32 newclientid() const;
  inline void set_newclientid(::google::protobuf::uint32 value);

  // optional uint64 newgateid = 5;
  inline bool has_newgateid() const;
  inline void clear_newgateid();
  static const int kNewgateidFieldNumber = 5;
  inline ::google::protobuf::uint64 newgateid() const;
  inline void set_newgateid(::google::protobuf::uint64 value);

  // optional string token = 6;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 6;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 areaid = 7;
  inline bool has_areaid() const;
  inline void clear_areaid();
  static const int kAreaidFieldNumber = 7;
  inline ::google::protobuf::uint32 areaid() const;
  inline void set_areaid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.kick_out_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_newclientid();
  inline void clear_has_newclientid();
  inline void set_has_newgateid();
  inline void clear_has_newgateid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_areaid();
  inline void clear_has_areaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 newclientid_;
  ::google::protobuf::uint64 newgateid_;
  ::std::string* token_;
  ::google::protobuf::uint32 areaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static kick_out_ack* default_instance_;
};
// -------------------------------------------------------------------

class gt_reconnect_check_req : public ::google::protobuf::Message {
 public:
  gt_reconnect_check_req();
  virtual ~gt_reconnect_check_req();

  gt_reconnect_check_req(const gt_reconnect_check_req& from);

  inline gt_reconnect_check_req& operator=(const gt_reconnect_check_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_reconnect_check_req& default_instance();

  void Swap(gt_reconnect_check_req* other);

  // implements Message ----------------------------------------------

  gt_reconnect_check_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_reconnect_check_req& from);
  void MergeFrom(const gt_reconnect_check_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_reconnect_check_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 4;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_reconnect_check_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_reconnect_check_req* default_instance_;
};
// -------------------------------------------------------------------

class ct_reconnect_check_ack : public ::google::protobuf::Message {
 public:
  ct_reconnect_check_ack();
  virtual ~ct_reconnect_check_ack();

  ct_reconnect_check_ack(const ct_reconnect_check_ack& from);

  inline ct_reconnect_check_ack& operator=(const ct_reconnect_check_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_reconnect_check_ack& default_instance();

  void Swap(ct_reconnect_check_ack* other);

  // implements Message ----------------------------------------------

  ct_reconnect_check_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_reconnect_check_ack& from);
  void MergeFrom(const ct_reconnect_check_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_reconnect_check_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 4;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_reconnect_check_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_reconnect_check_ack* default_instance_;
};
// -------------------------------------------------------------------

class ct_reconnect_kick_req : public ::google::protobuf::Message {
 public:
  ct_reconnect_kick_req();
  virtual ~ct_reconnect_kick_req();

  ct_reconnect_kick_req(const ct_reconnect_kick_req& from);

  inline ct_reconnect_kick_req& operator=(const ct_reconnect_kick_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_reconnect_kick_req& default_instance();

  void Swap(ct_reconnect_kick_req* other);

  // implements Message ----------------------------------------------

  ct_reconnect_kick_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_reconnect_kick_req& from);
  void MergeFrom(const ct_reconnect_kick_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_reconnect_kick_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 4;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional uint64 new_gate_id = 5;
  inline bool has_new_gate_id() const;
  inline void clear_new_gate_id();
  static const int kNewGateIdFieldNumber = 5;
  inline ::google::protobuf::uint64 new_gate_id() const;
  inline void set_new_gate_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_reconnect_kick_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_new_gate_id();
  inline void clear_has_new_gate_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::uint64 new_gate_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_reconnect_kick_req* default_instance_;
};
// -------------------------------------------------------------------

class gt_reconnect_kick_ack : public ::google::protobuf::Message {
 public:
  gt_reconnect_kick_ack();
  virtual ~gt_reconnect_kick_ack();

  gt_reconnect_kick_ack(const gt_reconnect_kick_ack& from);

  inline gt_reconnect_kick_ack& operator=(const gt_reconnect_kick_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_reconnect_kick_ack& default_instance();

  void Swap(gt_reconnect_kick_ack* other);

  // implements Message ----------------------------------------------

  gt_reconnect_kick_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_reconnect_kick_ack& from);
  void MergeFrom(const gt_reconnect_kick_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_reconnect_kick_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint64 playerid = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 4;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional uint64 new_gate_id = 5;
  inline bool has_new_gate_id() const;
  inline void clear_new_gate_id();
  static const int kNewGateIdFieldNumber = 5;
  inline ::google::protobuf::uint64 new_gate_id() const;
  inline void set_new_gate_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_reconnect_kick_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_new_gate_id();
  inline void clear_has_new_gate_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint64 playerid_;
  ::google::protobuf::uint64 new_gate_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_reconnect_kick_ack* default_instance_;
};
// -------------------------------------------------------------------

class gt_online_client_ntf : public ::google::protobuf::Message {
 public:
  gt_online_client_ntf();
  virtual ~gt_online_client_ntf();

  gt_online_client_ntf(const gt_online_client_ntf& from);

  inline gt_online_client_ntf& operator=(const gt_online_client_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_online_client_ntf& default_instance();

  void Swap(gt_online_client_ntf* other);

  // implements Message ----------------------------------------------

  gt_online_client_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_online_client_ntf& from);
  void MergeFrom(const gt_online_client_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_online_client_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated uint32 accountid = 2;
  inline int accountid_size() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  inline ::google::protobuf::uint32 accountid(int index) const;
  inline void set_accountid(int index, ::google::protobuf::uint32 value);
  inline void add_accountid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      accountid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_accountid();

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_online_client_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > accountid_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_online_client_ntf* default_instance_;
};
// -------------------------------------------------------------------

class gt_game_server_player_num_ntf : public ::google::protobuf::Message {
 public:
  gt_game_server_player_num_ntf();
  virtual ~gt_game_server_player_num_ntf();

  gt_game_server_player_num_ntf(const gt_game_server_player_num_ntf& from);

  inline gt_game_server_player_num_ntf& operator=(const gt_game_server_player_num_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_game_server_player_num_ntf& default_instance();

  void Swap(gt_game_server_player_num_ntf* other);

  // implements Message ----------------------------------------------

  gt_game_server_player_num_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_game_server_player_num_ntf& from);
  void MergeFrom(const gt_game_server_player_num_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_game_server_player_num_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 game_server_id = 2;
  inline bool has_game_server_id() const;
  inline void clear_game_server_id();
  static const int kGameServerIdFieldNumber = 2;
  inline ::google::protobuf::uint32 game_server_id() const;
  inline void set_game_server_id(::google::protobuf::uint32 value);

  // optional uint32 player_num = 3;
  inline bool has_player_num() const;
  inline void clear_player_num();
  static const int kPlayerNumFieldNumber = 3;
  inline ::google::protobuf::uint32 player_num() const;
  inline void set_player_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_game_server_player_num_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_game_server_id();
  inline void clear_has_game_server_id();
  inline void set_has_player_num();
  inline void clear_has_player_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 game_server_id_;
  ::google::protobuf::uint32 player_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_game_server_player_num_ntf* default_instance_;
};
// -------------------------------------------------------------------

class ct_need_queued_ntf : public ::google::protobuf::Message {
 public:
  ct_need_queued_ntf();
  virtual ~ct_need_queued_ntf();

  ct_need_queued_ntf(const ct_need_queued_ntf& from);

  inline ct_need_queued_ntf& operator=(const ct_need_queued_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_need_queued_ntf& default_instance();

  void Swap(ct_need_queued_ntf* other);

  // implements Message ----------------------------------------------

  ct_need_queued_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_need_queued_ntf& from);
  void MergeFrom(const ct_need_queued_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_need_queued_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_need_queued_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_need_queued_ntf* default_instance_;
};
// -------------------------------------------------------------------

class ct_end_queued_ntf : public ::google::protobuf::Message {
 public:
  ct_end_queued_ntf();
  virtual ~ct_end_queued_ntf();

  ct_end_queued_ntf(const ct_end_queued_ntf& from);

  inline ct_end_queued_ntf& operator=(const ct_end_queued_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_end_queued_ntf& default_instance();

  void Swap(ct_end_queued_ntf* other);

  // implements Message ----------------------------------------------

  ct_end_queued_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_end_queued_ntf& from);
  void MergeFrom(const ct_end_queued_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_end_queued_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_end_queued_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_end_queued_ntf* default_instance_;
};
// -------------------------------------------------------------------

class gt_queued_state_req : public ::google::protobuf::Message {
 public:
  gt_queued_state_req();
  virtual ~gt_queued_state_req();

  gt_queued_state_req(const gt_queued_state_req& from);

  inline gt_queued_state_req& operator=(const gt_queued_state_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_queued_state_req& default_instance();

  void Swap(gt_queued_state_req* other);

  // implements Message ----------------------------------------------

  gt_queued_state_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_queued_state_req& from);
  void MergeFrom(const gt_queued_state_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_queued_state_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 accountid = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 3;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_queued_state_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 accountid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_queued_state_req* default_instance_;
};
// -------------------------------------------------------------------

class ct_queued_state_ack : public ::google::protobuf::Message {
 public:
  ct_queued_state_ack();
  virtual ~ct_queued_state_ack();

  ct_queued_state_ack(const ct_queued_state_ack& from);

  inline ct_queued_state_ack& operator=(const ct_queued_state_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_queued_state_ack& default_instance();

  void Swap(ct_queued_state_ack* other);

  // implements Message ----------------------------------------------

  ct_queued_state_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_queued_state_ack& from);
  void MergeFrom(const ct_queued_state_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_queued_state_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_queued_state_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_queued_state_ack* default_instance_;
};
// -------------------------------------------------------------------

class gt_cancel_queue_req : public ::google::protobuf::Message {
 public:
  gt_cancel_queue_req();
  virtual ~gt_cancel_queue_req();

  gt_cancel_queue_req(const gt_cancel_queue_req& from);

  inline gt_cancel_queue_req& operator=(const gt_cancel_queue_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gt_cancel_queue_req& default_instance();

  void Swap(gt_cancel_queue_req* other);

  // implements Message ----------------------------------------------

  gt_cancel_queue_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gt_cancel_queue_req& from);
  void MergeFrom(const gt_cancel_queue_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_cancel_queue_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // optional uint32 accountid = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 3;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gt_cancel_queue_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::uint32 accountid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gt_cancel_queue_req* default_instance_;
};
// -------------------------------------------------------------------

class ct_cancel_queue_ack : public ::google::protobuf::Message {
 public:
  ct_cancel_queue_ack();
  virtual ~ct_cancel_queue_ack();

  ct_cancel_queue_ack(const ct_cancel_queue_ack& from);

  inline ct_cancel_queue_ack& operator=(const ct_cancel_queue_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ct_cancel_queue_ack& default_instance();

  void Swap(ct_cancel_queue_ack* other);

  // implements Message ----------------------------------------------

  ct_cancel_queue_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ct_cancel_queue_ack& from);
  void MergeFrom(const ct_cancel_queue_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_cancel_queue_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 clientid = 2;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 2;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.ct_cancel_queue_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static ct_cancel_queue_ack* default_instance_;
};
// -------------------------------------------------------------------

class account_login_ntf : public ::google::protobuf::Message {
 public:
  account_login_ntf();
  virtual ~account_login_ntf();

  account_login_ntf(const account_login_ntf& from);

  inline account_login_ntf& operator=(const account_login_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const account_login_ntf& default_instance();

  void Swap(account_login_ntf* other);

  // implements Message ----------------------------------------------

  account_login_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const account_login_ntf& from);
  void MergeFrom(const account_login_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = account_login_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string accountid = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 tempid = 4;
  inline bool has_tempid() const;
  inline void clear_tempid();
  static const int kTempidFieldNumber = 4;
  inline ::google::protobuf::uint32 tempid() const;
  inline void set_tempid(::google::protobuf::uint32 value);

  // optional uint32 lastverifytime = 5;
  inline bool has_lastverifytime() const;
  inline void clear_lastverifytime();
  static const int kLastverifytimeFieldNumber = 5;
  inline ::google::protobuf::uint32 lastverifytime() const;
  inline void set_lastverifytime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.account_login_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_tempid();
  inline void clear_has_tempid();
  inline void set_has_lastverifytime();
  inline void clear_has_lastverifytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* accountid_;
  int protoid_;
  ::google::protobuf::uint32 tempid_;
  ::std::string* token_;
  ::google::protobuf::uint32 lastverifytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static account_login_ntf* default_instance_;
};
// -------------------------------------------------------------------

class account_login_ntf_ack : public ::google::protobuf::Message {
 public:
  account_login_ntf_ack();
  virtual ~account_login_ntf_ack();

  account_login_ntf_ack(const account_login_ntf_ack& from);

  inline account_login_ntf_ack& operator=(const account_login_ntf_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const account_login_ntf_ack& default_instance();

  void Swap(account_login_ntf_ack* other);

  // implements Message ----------------------------------------------

  account_login_ntf_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const account_login_ntf_ack& from);
  void MergeFrom(const account_login_ntf_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = account_login_ntf_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string accountid = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // @@protoc_insertion_point(class_scope:SProtoSpace.account_login_ntf_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* accountid_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static account_login_ntf_ack* default_instance_;
};
// -------------------------------------------------------------------

class area_list_req : public ::google::protobuf::Message {
 public:
  area_list_req();
  virtual ~area_list_req();

  area_list_req(const area_list_req& from);

  inline area_list_req& operator=(const area_list_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_list_req& default_instance();

  void Swap(area_list_req* other);

  // implements Message ----------------------------------------------

  area_list_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_list_req& from);
  void MergeFrom(const area_list_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_list_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_list_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_list_req* default_instance_;
};
// -------------------------------------------------------------------

class gate_net_info : public ::google::protobuf::Message {
 public:
  gate_net_info();
  virtual ~gate_net_info();

  gate_net_info(const gate_net_info& from);

  inline gate_net_info& operator=(const gate_net_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gate_net_info& default_instance();

  void Swap(gate_net_info* other);

  // implements Message ----------------------------------------------

  gate_net_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gate_net_info& from);
  void MergeFrom(const gate_net_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional bool new = 5;
  inline bool has_new_() const;
  inline void clear_new_();
  static const int kNewFieldNumber = 5;
  inline bool new_() const;
  inline void set_new_(bool value);

  // optional int32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional uint32 groupindex = 7;
  inline bool has_groupindex() const;
  inline void clear_groupindex();
  static const int kGroupindexFieldNumber = 7;
  inline ::google::protobuf::uint32 groupindex() const;
  inline void set_groupindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gate_net_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_new_();
  inline void clear_has_new_();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_groupindex();
  inline void clear_has_groupindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* ip_;
  ::std::string* group_name_;
  ::google::protobuf::int32 port_;
  bool new__;
  ::google::protobuf::int32 state_;
  ::google::protobuf::uint32 groupindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gate_net_info* default_instance_;
};
// -------------------------------------------------------------------

class area_brief_info : public ::google::protobuf::Message {
 public:
  area_brief_info();
  virtual ~area_brief_info();

  area_brief_info(const area_brief_info& from);

  inline area_brief_info& operator=(const area_brief_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_brief_info& default_instance();

  void Swap(area_brief_info* other);

  // implements Message ----------------------------------------------

  area_brief_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_brief_info& from);
  void MergeFrom(const area_brief_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 area_id = 1;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_brief_info)
 private:
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::int32 area_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_brief_info* default_instance_;
};
// -------------------------------------------------------------------

class area_record : public ::google::protobuf::Message {
 public:
  area_record();
  virtual ~area_record();

  area_record(const area_record& from);

  inline area_record& operator=(const area_record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_record& default_instance();

  void Swap(area_record* other);

  // implements Message ----------------------------------------------

  area_record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_record& from);
  void MergeFrom(const area_record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_area_id = 1;
  inline bool has_last_area_id() const;
  inline void clear_last_area_id();
  static const int kLastAreaIdFieldNumber = 1;
  inline ::google::protobuf::uint32 last_area_id() const;
  inline void set_last_area_id(::google::protobuf::uint32 value);

  // repeated .SProtoSpace.area_brief_info areas = 2;
  inline int areas_size() const;
  inline void clear_areas();
  static const int kAreasFieldNumber = 2;
  inline const ::SProtoSpace::area_brief_info& areas(int index) const;
  inline ::SProtoSpace::area_brief_info* mutable_areas(int index);
  inline ::SProtoSpace::area_brief_info* add_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_brief_info >&
      areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_brief_info >*
      mutable_areas();

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_record)
 private:
  inline void set_has_last_area_id();
  inline void clear_has_last_area_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_brief_info > areas_;
  ::google::protobuf::uint32 last_area_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_record* default_instance_;
};
// -------------------------------------------------------------------

class group_area_info : public ::google::protobuf::Message {
 public:
  group_area_info();
  virtual ~group_area_info();

  group_area_info(const group_area_info& from);

  inline group_area_info& operator=(const group_area_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const group_area_info& default_instance();

  void Swap(group_area_info* other);

  // implements Message ----------------------------------------------

  group_area_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const group_area_info& from);
  void MergeFrom(const group_area_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 groupids = 1;
  inline int groupids_size() const;
  inline void clear_groupids();
  static const int kGroupidsFieldNumber = 1;
  inline ::google::protobuf::uint64 groupids(int index) const;
  inline void set_groupids(int index, ::google::protobuf::uint64 value);
  inline void add_groupids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      groupids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_groupids();

  // optional string area_group_name = 2;
  inline bool has_area_group_name() const;
  inline void clear_area_group_name();
  static const int kAreaGroupNameFieldNumber = 2;
  inline const ::std::string& area_group_name() const;
  inline void set_area_group_name(const ::std::string& value);
  inline void set_area_group_name(const char* value);
  inline void set_area_group_name(const char* value, size_t size);
  inline ::std::string* mutable_area_group_name();
  inline ::std::string* release_area_group_name();
  inline void set_allocated_area_group_name(::std::string* area_group_name);

  // @@protoc_insertion_point(class_scope:SProtoSpace.group_area_info)
 private:
  inline void set_has_area_group_name();
  inline void clear_has_area_group_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > groupids_;
  ::std::string* area_group_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static group_area_info* default_instance_;
};
// -------------------------------------------------------------------

class area_list_ack : public ::google::protobuf::Message {
 public:
  area_list_ack();
  virtual ~area_list_ack();

  area_list_ack(const area_list_ack& from);

  inline area_list_ack& operator=(const area_list_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_list_ack& default_instance();

  void Swap(area_list_ack* other);

  // implements Message ----------------------------------------------

  area_list_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_list_ack& from);
  void MergeFrom(const area_list_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_list_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 clientid = 3;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 3;
  inline ::google::protobuf::uint32 clientid() const;
  inline void set_clientid(::google::protobuf::uint32 value);

  // repeated .SProtoSpace.gate_net_info groups = 4;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 4;
  inline const ::SProtoSpace::gate_net_info& groups(int index) const;
  inline ::SProtoSpace::gate_net_info* mutable_groups(int index);
  inline ::SProtoSpace::gate_net_info* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gate_net_info >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gate_net_info >*
      mutable_groups();

  // optional uint64 centerid = 5;
  inline bool has_centerid() const;
  inline void clear_centerid();
  static const int kCenteridFieldNumber = 5;
  inline ::google::protobuf::uint64 centerid() const;
  inline void set_centerid(::google::protobuf::uint64 value);

  // repeated .SProtoSpace.group_area_info area_groups = 6;
  inline int area_groups_size() const;
  inline void clear_area_groups();
  static const int kAreaGroupsFieldNumber = 6;
  inline const ::SProtoSpace::group_area_info& area_groups(int index) const;
  inline ::SProtoSpace::group_area_info* mutable_area_groups(int index);
  inline ::SProtoSpace::group_area_info* add_area_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >&
      area_groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >*
      mutable_area_groups();

  // repeated .SProtoSpace.group_area_info recommend_areas = 7;
  inline int recommend_areas_size() const;
  inline void clear_recommend_areas();
  static const int kRecommendAreasFieldNumber = 7;
  inline const ::SProtoSpace::group_area_info& recommend_areas(int index) const;
  inline ::SProtoSpace::group_area_info* mutable_recommend_areas(int index);
  inline ::SProtoSpace::group_area_info* add_recommend_areas();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >&
      recommend_areas() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >*
      mutable_recommend_areas();

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_list_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_centerid();
  inline void clear_has_centerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int protoid_;
  ::google::protobuf::uint32 clientid_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gate_net_info > groups_;
  ::google::protobuf::uint64 centerid_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info > area_groups_;
  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info > recommend_areas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_list_ack* default_instance_;
};
// -------------------------------------------------------------------

class area_gateserver_info_req : public ::google::protobuf::Message {
 public:
  area_gateserver_info_req();
  virtual ~area_gateserver_info_req();

  area_gateserver_info_req(const area_gateserver_info_req& from);

  inline area_gateserver_info_req& operator=(const area_gateserver_info_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_gateserver_info_req& default_instance();

  void Swap(area_gateserver_info_req* other);

  // implements Message ----------------------------------------------

  area_gateserver_info_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_gateserver_info_req& from);
  void MergeFrom(const area_gateserver_info_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_gateserver_info_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_gateserver_info_req* default_instance_;
};
// -------------------------------------------------------------------

class area_gateserver_info_ack : public ::google::protobuf::Message {
 public:
  area_gateserver_info_ack();
  virtual ~area_gateserver_info_ack();

  area_gateserver_info_ack(const area_gateserver_info_ack& from);

  inline area_gateserver_info_ack& operator=(const area_gateserver_info_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_gateserver_info_ack& default_instance();

  void Swap(area_gateserver_info_ack* other);

  // implements Message ----------------------------------------------

  area_gateserver_info_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_gateserver_info_ack& from);
  void MergeFrom(const area_gateserver_info_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // repeated .SProtoSpace.area_gateserver_info gs_info = 2;
  inline int gs_info_size() const;
  inline void clear_gs_info();
  static const int kGsInfoFieldNumber = 2;
  inline const ::SProtoSpace::area_gateserver_info& gs_info(int index) const;
  inline ::SProtoSpace::area_gateserver_info* mutable_gs_info(int index);
  inline ::SProtoSpace::area_gateserver_info* add_gs_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_gateserver_info >&
      gs_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_gateserver_info >*
      mutable_gs_info();

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_gateserver_info_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_gateserver_info > gs_info_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_gateserver_info_ack* default_instance_;
};
// -------------------------------------------------------------------

class area_gateserver_info_ntf : public ::google::protobuf::Message {
 public:
  area_gateserver_info_ntf();
  virtual ~area_gateserver_info_ntf();

  area_gateserver_info_ntf(const area_gateserver_info_ntf& from);

  inline area_gateserver_info_ntf& operator=(const area_gateserver_info_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const area_gateserver_info_ntf& default_instance();

  void Swap(area_gateserver_info_ntf* other);

  // implements Message ----------------------------------------------

  area_gateserver_info_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const area_gateserver_info_ntf& from);
  void MergeFrom(const area_gateserver_info_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional .SProtoSpace.area_gateserver_info gs_info = 2;
  inline bool has_gs_info() const;
  inline void clear_gs_info();
  static const int kGsInfoFieldNumber = 2;
  inline const ::SProtoSpace::area_gateserver_info& gs_info() const;
  inline ::SProtoSpace::area_gateserver_info* mutable_gs_info();
  inline ::SProtoSpace::area_gateserver_info* release_gs_info();
  inline void set_allocated_gs_info(::SProtoSpace::area_gateserver_info* gs_info);

  // @@protoc_insertion_point(class_scope:SProtoSpace.area_gateserver_info_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_gs_info();
  inline void clear_has_gs_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SProtoSpace::area_gateserver_info* gs_info_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static area_gateserver_info_ntf* default_instance_;
};
// -------------------------------------------------------------------

class update_area_info_ntf : public ::google::protobuf::Message {
 public:
  update_area_info_ntf();
  virtual ~update_area_info_ntf();

  update_area_info_ntf(const update_area_info_ntf& from);

  inline update_area_info_ntf& operator=(const update_area_info_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const update_area_info_ntf& default_instance();

  void Swap(update_area_info_ntf* other);

  // implements Message ----------------------------------------------

  update_area_info_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const update_area_info_ntf& from);
  void MergeFrom(const update_area_info_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = update_area_info_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .SProtoSpace.area_brief_info data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::SProtoSpace::area_brief_info& data() const;
  inline ::SProtoSpace::area_brief_info* mutable_data();
  inline ::SProtoSpace::area_brief_info* release_data();
  inline void set_allocated_data(::SProtoSpace::area_brief_info* data);

  // @@protoc_insertion_point(class_scope:SProtoSpace.update_area_info_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::SProtoSpace::area_brief_info* data_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static update_area_info_ntf* default_instance_;
};
// -------------------------------------------------------------------

class lc_heartbeat_req : public ::google::protobuf::Message {
 public:
  lc_heartbeat_req();
  virtual ~lc_heartbeat_req();

  lc_heartbeat_req(const lc_heartbeat_req& from);

  inline lc_heartbeat_req& operator=(const lc_heartbeat_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lc_heartbeat_req& default_instance();

  void Swap(lc_heartbeat_req* other);

  // implements Message ----------------------------------------------

  lc_heartbeat_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lc_heartbeat_req& from);
  void MergeFrom(const lc_heartbeat_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = lc_heartbeat_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // optional uint32 tm = 3;
  inline bool has_tm() const;
  inline void clear_tm();
  static const int kTmFieldNumber = 3;
  inline ::google::protobuf::uint32 tm() const;
  inline void set_tm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.lc_heartbeat_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_tm();
  inline void clear_has_tm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 sid_;
  ::google::protobuf::uint32 tm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static lc_heartbeat_req* default_instance_;
};
// -------------------------------------------------------------------

class lc_heartbeat_ack : public ::google::protobuf::Message {
 public:
  lc_heartbeat_ack();
  virtual ~lc_heartbeat_ack();

  lc_heartbeat_ack(const lc_heartbeat_ack& from);

  inline lc_heartbeat_ack& operator=(const lc_heartbeat_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lc_heartbeat_ack& default_instance();

  void Swap(lc_heartbeat_ack* other);

  // implements Message ----------------------------------------------

  lc_heartbeat_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lc_heartbeat_ack& from);
  void MergeFrom(const lc_heartbeat_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = lc_heartbeat_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 region = 2;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline ::google::protobuf::uint32 region() const;
  inline void set_region(::google::protobuf::uint32 value);

  // optional uint32 group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // optional uint32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 sid = 6;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 6;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // optional uint32 tm = 7;
  inline bool has_tm() const;
  inline void clear_tm();
  static const int kTmFieldNumber = 7;
  inline ::google::protobuf::uint32 tm() const;
  inline void set_tm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.lc_heartbeat_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_tm();
  inline void clear_has_tm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 region_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 sid_;
  ::google::protobuf::uint32 tm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static lc_heartbeat_ack* default_instance_;
};
// -------------------------------------------------------------------

class role_leave_game_ntf : public ::google::protobuf::Message {
 public:
  role_leave_game_ntf();
  virtual ~role_leave_game_ntf();

  role_leave_game_ntf(const role_leave_game_ntf& from);

  inline role_leave_game_ntf& operator=(const role_leave_game_ntf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_leave_game_ntf& default_instance();

  void Swap(role_leave_game_ntf* other);

  // implements Message ----------------------------------------------

  role_leave_game_ntf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_leave_game_ntf& from);
  void MergeFrom(const role_leave_game_ntf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_leave_game_ntf_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 accountid = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 3;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // optional uint64 groupid = 4;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 4;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 heroid = 6;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroidFieldNumber = 6;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // optional uint32 lastlogindate = 7;
  inline bool has_lastlogindate() const;
  inline void clear_lastlogindate();
  static const int kLastlogindateFieldNumber = 7;
  inline ::google::protobuf::uint32 lastlogindate() const;
  inline void set_lastlogindate(::google::protobuf::uint32 value);

  // optional string account = 8;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 8;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:SProtoSpace.role_leave_game_ntf)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_lastlogindate();
  inline void clear_has_lastlogindate();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int protoid_;
  ::google::protobuf::uint32 accountid_;
  ::google::protobuf::uint64 groupid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 heroid_;
  ::std::string* account_;
  ::google::protobuf::uint32 lastlogindate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static role_leave_game_ntf* default_instance_;
};
// -------------------------------------------------------------------

class gm2center_close_req : public ::google::protobuf::Message {
 public:
  gm2center_close_req();
  virtual ~gm2center_close_req();

  gm2center_close_req(const gm2center_close_req& from);

  inline gm2center_close_req& operator=(const gm2center_close_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm2center_close_req& default_instance();

  void Swap(gm2center_close_req* other);

  // implements Message ----------------------------------------------

  gm2center_close_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm2center_close_req& from);
  void MergeFrom(const gm2center_close_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_close_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm2center_close_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gm2center_close_req* default_instance_;
};
// -------------------------------------------------------------------

class center2gm_close_ack : public ::google::protobuf::Message {
 public:
  center2gm_close_ack();
  virtual ~center2gm_close_ack();

  center2gm_close_ack(const center2gm_close_ack& from);

  inline center2gm_close_ack& operator=(const center2gm_close_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const center2gm_close_ack& default_instance();

  void Swap(center2gm_close_ack* other);

  // implements Message ----------------------------------------------

  center2gm_close_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const center2gm_close_ack& from);
  void MergeFrom(const center2gm_close_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_close_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 retcode = 2;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.center2gm_close_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_retcode();
  inline void clear_has_retcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static center2gm_close_ack* default_instance_;
};
// -------------------------------------------------------------------

class gm2center_center_status_req : public ::google::protobuf::Message {
 public:
  gm2center_center_status_req();
  virtual ~gm2center_center_status_req();

  gm2center_center_status_req(const gm2center_center_status_req& from);

  inline gm2center_center_status_req& operator=(const gm2center_center_status_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm2center_center_status_req& default_instance();

  void Swap(gm2center_center_status_req* other);

  // implements Message ----------------------------------------------

  gm2center_center_status_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm2center_center_status_req& from);
  void MergeFrom(const gm2center_center_status_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_center_status_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint64 info_detail = 2;
  inline bool has_info_detail() const;
  inline void clear_info_detail();
  static const int kInfoDetailFieldNumber = 2;
  inline ::google::protobuf::uint64 info_detail() const;
  inline void set_info_detail(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm2center_center_status_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_info_detail();
  inline void clear_has_info_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 info_detail_;
  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gm2center_center_status_req* default_instance_;
};
// -------------------------------------------------------------------

class center2gm_center_status_ack : public ::google::protobuf::Message {
 public:
  center2gm_center_status_ack();
  virtual ~center2gm_center_status_ack();

  center2gm_center_status_ack(const center2gm_center_status_ack& from);

  inline center2gm_center_status_ack& operator=(const center2gm_center_status_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const center2gm_center_status_ack& default_instance();

  void Swap(center2gm_center_status_ack* other);

  // implements Message ----------------------------------------------

  center2gm_center_status_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const center2gm_center_status_ack& from);
  void MergeFrom(const center2gm_center_status_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_center_status_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // optional uint32 server_status = 2;
  inline bool has_server_status() const;
  inline void clear_server_status();
  static const int kServerStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 server_status() const;
  inline void set_server_status(::google::protobuf::uint32 value);

  // optional uint32 account_count = 3;
  inline bool has_account_count() const;
  inline void clear_account_count();
  static const int kAccountCountFieldNumber = 3;
  inline ::google::protobuf::uint32 account_count() const;
  inline void set_account_count(::google::protobuf::uint32 value);

  // optional uint64 server_id = 4;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 4;
  inline ::google::protobuf::uint64 server_id() const;
  inline void set_server_id(::google::protobuf::uint64 value);

  // optional uint64 server_port = 5;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 5;
  inline ::google::protobuf::uint64 server_port() const;
  inline void set_server_port(::google::protobuf::uint64 value);

  // optional uint64 server_redis_ip = 16;
  inline bool has_server_redis_ip() const;
  inline void clear_server_redis_ip();
  static const int kServerRedisIpFieldNumber = 16;
  inline ::google::protobuf::uint64 server_redis_ip() const;
  inline void set_server_redis_ip(::google::protobuf::uint64 value);

  // optional uint64 server_redis_port = 17;
  inline bool has_server_redis_port() const;
  inline void clear_server_redis_port();
  static const int kServerRedisPortFieldNumber = 17;
  inline ::google::protobuf::uint64 server_redis_port() const;
  inline void set_server_redis_port(::google::protobuf::uint64 value);

  // optional uint32 gateserver_count = 18;
  inline bool has_gateserver_count() const;
  inline void clear_gateserver_count();
  static const int kGateserverCountFieldNumber = 18;
  inline ::google::protobuf::uint32 gateserver_count() const;
  inline void set_gateserver_count(::google::protobuf::uint32 value);

  // optional uint32 redis_statue = 19;
  inline bool has_redis_statue() const;
  inline void clear_redis_statue();
  static const int kRedisStatueFieldNumber = 19;
  inline ::google::protobuf::uint32 redis_statue() const;
  inline void set_redis_statue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.center2gm_center_status_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();
  inline void set_has_server_status();
  inline void clear_has_server_status();
  inline void set_has_account_count();
  inline void clear_has_account_count();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_server_redis_ip();
  inline void clear_has_server_redis_ip();
  inline void set_has_server_redis_port();
  inline void clear_has_server_redis_port();
  inline void set_has_gateserver_count();
  inline void clear_has_gateserver_count();
  inline void set_has_redis_statue();
  inline void clear_has_redis_statue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;
  ::google::protobuf::uint32 server_status_;
  ::google::protobuf::uint64 server_id_;
  ::google::protobuf::uint64 server_port_;
  ::google::protobuf::uint32 account_count_;
  ::google::protobuf::uint32 gateserver_count_;
  ::google::protobuf::uint64 server_redis_ip_;
  ::google::protobuf::uint64 server_redis_port_;
  ::google::protobuf::uint32 redis_statue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static center2gm_center_status_ack* default_instance_;
};
// -------------------------------------------------------------------

class gm2center_center_reset_req : public ::google::protobuf::Message {
 public:
  gm2center_center_reset_req();
  virtual ~gm2center_center_reset_req();

  gm2center_center_reset_req(const gm2center_center_reset_req& from);

  inline gm2center_center_reset_req& operator=(const gm2center_center_reset_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm2center_center_reset_req& default_instance();

  void Swap(gm2center_center_reset_req* other);

  // implements Message ----------------------------------------------

  gm2center_center_reset_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm2center_center_reset_req& from);
  void MergeFrom(const gm2center_center_reset_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_center_reset_req_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.gm2center_center_reset_req)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static gm2center_center_reset_req* default_instance_;
};
// -------------------------------------------------------------------

class center2gm_center_reset_ack : public ::google::protobuf::Message {
 public:
  center2gm_center_reset_ack();
  virtual ~center2gm_center_reset_ack();

  center2gm_center_reset_ack(const center2gm_center_reset_ack& from);

  inline center2gm_center_reset_ack& operator=(const center2gm_center_reset_ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const center2gm_center_reset_ack& default_instance();

  void Swap(center2gm_center_reset_ack* other);

  // implements Message ----------------------------------------------

  center2gm_center_reset_ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const center2gm_center_reset_ack& from);
  void MergeFrom(const center2gm_center_reset_ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_center_reset_ack_id];
  inline bool has_protoid() const;
  inline void clear_protoid();
  static const int kProtoidFieldNumber = 1;
  inline ::SProtoSpace::ESSProtoID protoid() const;
  inline void set_protoid(::SProtoSpace::ESSProtoID value);

  // @@protoc_insertion_point(class_scope:SProtoSpace.center2gm_center_reset_ack)
 private:
  inline void set_has_protoid();
  inline void clear_has_protoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int protoid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ss_5fcenter_2eproto();
  friend void protobuf_AssignDesc_ss_5fcenter_2eproto();
  friend void protobuf_ShutdownFile_ss_5fcenter_2eproto();

  void InitAsDefaultInstance();
  static center2gm_center_reset_ack* default_instance_;
};
// ===================================================================


// ===================================================================

// gate_listen_report

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gate_listen_report_id];
inline bool gate_listen_report::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate_listen_report::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate_listen_report::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate_listen_report::clear_protoid() {
  protoid_ = 1;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gate_listen_report::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gate_listen_report::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string Ip = 2;
inline bool gate_listen_report::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate_listen_report::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate_listen_report::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate_listen_report::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& gate_listen_report::ip() const {
  return *ip_;
}
inline void gate_listen_report::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void gate_listen_report::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void gate_listen_report::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gate_listen_report::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* gate_listen_report::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gate_listen_report::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Port = 3;
inline bool gate_listen_report::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gate_listen_report::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gate_listen_report::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gate_listen_report::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 gate_listen_report::port() const {
  return port_;
}
inline void gate_listen_report::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string GroupName = 4;
inline bool gate_listen_report::has_groupname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gate_listen_report::set_has_groupname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gate_listen_report::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gate_listen_report::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& gate_listen_report::groupname() const {
  return *groupname_;
}
inline void gate_listen_report::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void gate_listen_report::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void gate_listen_report::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gate_listen_report::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* gate_listen_report::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gate_listen_report::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool new = 5;
inline bool gate_listen_report::has_new_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gate_listen_report::set_has_new_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gate_listen_report::clear_has_new_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gate_listen_report::clear_new_() {
  new__ = false;
  clear_has_new_();
}
inline bool gate_listen_report::new_() const {
  return new__;
}
inline void gate_listen_report::set_new_(bool value) {
  set_has_new_();
  new__ = value;
}

// optional int32 state = 6;
inline bool gate_listen_report::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gate_listen_report::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gate_listen_report::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gate_listen_report::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 gate_listen_report::state() const {
  return state_;
}
inline void gate_listen_report::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 groupindex = 7;
inline bool gate_listen_report::has_groupindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gate_listen_report::set_has_groupindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gate_listen_report::clear_has_groupindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gate_listen_report::clear_groupindex() {
  groupindex_ = 0u;
  clear_has_groupindex();
}
inline ::google::protobuf::uint32 gate_listen_report::groupindex() const {
  return groupindex_;
}
inline void gate_listen_report::set_groupindex(::google::protobuf::uint32 value) {
  set_has_groupindex();
  groupindex_ = value;
}

// -------------------------------------------------------------------

// gate_role_num_report

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gate_role_num_report_id];
inline bool gate_role_num_report::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate_role_num_report::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate_role_num_report::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate_role_num_report::clear_protoid() {
  protoid_ = 2;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gate_role_num_report::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gate_role_num_report::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 num = 2;
inline bool gate_role_num_report::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate_role_num_report::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate_role_num_report::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate_role_num_report::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 gate_role_num_report::num() const {
  return num_;
}
inline void gate_role_num_report::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// role_login_verify_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_login_verify_req_id];
inline bool role_login_verify_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_login_verify_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_login_verify_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_login_verify_req::clear_protoid() {
  protoid_ = 3;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID role_login_verify_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void role_login_verify_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool role_login_verify_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_login_verify_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_login_verify_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_login_verify_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& role_login_verify_req::account() const {
  return *account_;
}
inline void role_login_verify_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_login_verify_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_login_verify_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_login_verify_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* role_login_verify_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_login_verify_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool role_login_verify_req::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_login_verify_req::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_login_verify_req::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_login_verify_req::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& role_login_verify_req::token() const {
  return *token_;
}
inline void role_login_verify_req::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void role_login_verify_req::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void role_login_verify_req::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_login_verify_req::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* role_login_verify_req::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_login_verify_req::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tempid = 4;
inline bool role_login_verify_req::has_tempid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_login_verify_req::set_has_tempid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_login_verify_req::clear_has_tempid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_login_verify_req::clear_tempid() {
  tempid_ = 0u;
  clear_has_tempid();
}
inline ::google::protobuf::uint32 role_login_verify_req::tempid() const {
  return tempid_;
}
inline void role_login_verify_req::set_tempid(::google::protobuf::uint32 value) {
  set_has_tempid();
  tempid_ = value;
}

// optional uint32 clientid = 5;
inline bool role_login_verify_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_login_verify_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_login_verify_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_login_verify_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 role_login_verify_req::clientid() const {
  return clientid_;
}
inline void role_login_verify_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 areaid = 6;
inline bool role_login_verify_req::has_areaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_login_verify_req::set_has_areaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_login_verify_req::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_login_verify_req::clear_areaid() {
  areaid_ = 0u;
  clear_has_areaid();
}
inline ::google::protobuf::uint32 role_login_verify_req::areaid() const {
  return areaid_;
}
inline void role_login_verify_req::set_areaid(::google::protobuf::uint32 value) {
  set_has_areaid();
  areaid_ = value;
}

// -------------------------------------------------------------------

// role_login_verify_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_login_verify_ack_id];
inline bool role_login_verify_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_login_verify_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_login_verify_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_login_verify_ack::clear_protoid() {
  protoid_ = 4;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID role_login_verify_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void role_login_verify_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional int32 retcode = 2;
inline bool role_login_verify_ack::has_retcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_login_verify_ack::set_has_retcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_login_verify_ack::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_login_verify_ack::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 role_login_verify_ack::retcode() const {
  return retcode_;
}
inline void role_login_verify_ack::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string account = 3;
inline bool role_login_verify_ack::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_login_verify_ack::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_login_verify_ack::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_login_verify_ack::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& role_login_verify_ack::account() const {
  return *account_;
}
inline void role_login_verify_ack::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_login_verify_ack::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_login_verify_ack::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_login_verify_ack::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* role_login_verify_ack::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_login_verify_ack::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 4;
inline bool role_login_verify_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_login_verify_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_login_verify_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_login_verify_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 role_login_verify_ack::clientid() const {
  return clientid_;
}
inline void role_login_verify_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional string token = 5;
inline bool role_login_verify_ack::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_login_verify_ack::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_login_verify_ack::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_login_verify_ack::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& role_login_verify_ack::token() const {
  return *token_;
}
inline void role_login_verify_ack::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void role_login_verify_ack::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void role_login_verify_ack::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_login_verify_ack::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* role_login_verify_ack::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_login_verify_ack::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isreconnect = 6;
inline bool role_login_verify_ack::has_isreconnect() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_login_verify_ack::set_has_isreconnect() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_login_verify_ack::clear_has_isreconnect() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_login_verify_ack::clear_isreconnect() {
  isreconnect_ = false;
  clear_has_isreconnect();
}
inline bool role_login_verify_ack::isreconnect() const {
  return isreconnect_;
}
inline void role_login_verify_ack::set_isreconnect(bool value) {
  set_has_isreconnect();
  isreconnect_ = value;
}

// optional uint32 areaid = 7;
inline bool role_login_verify_ack::has_areaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_login_verify_ack::set_has_areaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_login_verify_ack::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_login_verify_ack::clear_areaid() {
  areaid_ = 0u;
  clear_has_areaid();
}
inline ::google::protobuf::uint32 role_login_verify_ack::areaid() const {
  return areaid_;
}
inline void role_login_verify_ack::set_areaid(::google::protobuf::uint32 value) {
  set_has_areaid();
  areaid_ = value;
}

// -------------------------------------------------------------------

// kick_out_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = kick_out_req_id];
inline bool kick_out_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kick_out_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kick_out_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kick_out_req::clear_protoid() {
  protoid_ = 5;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID kick_out_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void kick_out_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool kick_out_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kick_out_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kick_out_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kick_out_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& kick_out_req::account() const {
  return *account_;
}
inline void kick_out_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void kick_out_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void kick_out_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kick_out_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* kick_out_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kick_out_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 newclientid = 3;
inline bool kick_out_req::has_newclientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void kick_out_req::set_has_newclientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void kick_out_req::clear_has_newclientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void kick_out_req::clear_newclientid() {
  newclientid_ = 0u;
  clear_has_newclientid();
}
inline ::google::protobuf::uint32 kick_out_req::newclientid() const {
  return newclientid_;
}
inline void kick_out_req::set_newclientid(::google::protobuf::uint32 value) {
  set_has_newclientid();
  newclientid_ = value;
}

// optional uint64 newgateid = 4;
inline bool kick_out_req::has_newgateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void kick_out_req::set_has_newgateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void kick_out_req::clear_has_newgateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void kick_out_req::clear_newgateid() {
  newgateid_ = GOOGLE_ULONGLONG(0);
  clear_has_newgateid();
}
inline ::google::protobuf::uint64 kick_out_req::newgateid() const {
  return newgateid_;
}
inline void kick_out_req::set_newgateid(::google::protobuf::uint64 value) {
  set_has_newgateid();
  newgateid_ = value;
}

// optional .SProtoSpace.eKickoutReason reason = 5;
inline bool kick_out_req::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void kick_out_req::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void kick_out_req::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void kick_out_req::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::SProtoSpace::eKickoutReason kick_out_req::reason() const {
  return static_cast< ::SProtoSpace::eKickoutReason >(reason_);
}
inline void kick_out_req::set_reason(::SProtoSpace::eKickoutReason value) {
  assert(::SProtoSpace::eKickoutReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// optional string token = 6;
inline bool kick_out_req::has_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void kick_out_req::set_has_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void kick_out_req::clear_has_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void kick_out_req::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& kick_out_req::token() const {
  return *token_;
}
inline void kick_out_req::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void kick_out_req::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void kick_out_req::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kick_out_req::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* kick_out_req::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kick_out_req::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 areaid = 7;
inline bool kick_out_req::has_areaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void kick_out_req::set_has_areaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void kick_out_req::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void kick_out_req::clear_areaid() {
  areaid_ = 0u;
  clear_has_areaid();
}
inline ::google::protobuf::uint32 kick_out_req::areaid() const {
  return areaid_;
}
inline void kick_out_req::set_areaid(::google::protobuf::uint32 value) {
  set_has_areaid();
  areaid_ = value;
}

// -------------------------------------------------------------------

// kick_out_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = kick_out_ack_id];
inline bool kick_out_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kick_out_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kick_out_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kick_out_ack::clear_protoid() {
  protoid_ = 6;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID kick_out_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void kick_out_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool kick_out_ack::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void kick_out_ack::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void kick_out_ack::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void kick_out_ack::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& kick_out_ack::account() const {
  return *account_;
}
inline void kick_out_ack::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void kick_out_ack::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void kick_out_ack::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kick_out_ack::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* kick_out_ack::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kick_out_ack::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 newclientid = 4;
inline bool kick_out_ack::has_newclientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void kick_out_ack::set_has_newclientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void kick_out_ack::clear_has_newclientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void kick_out_ack::clear_newclientid() {
  newclientid_ = 0u;
  clear_has_newclientid();
}
inline ::google::protobuf::uint32 kick_out_ack::newclientid() const {
  return newclientid_;
}
inline void kick_out_ack::set_newclientid(::google::protobuf::uint32 value) {
  set_has_newclientid();
  newclientid_ = value;
}

// optional uint64 newgateid = 5;
inline bool kick_out_ack::has_newgateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void kick_out_ack::set_has_newgateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void kick_out_ack::clear_has_newgateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void kick_out_ack::clear_newgateid() {
  newgateid_ = GOOGLE_ULONGLONG(0);
  clear_has_newgateid();
}
inline ::google::protobuf::uint64 kick_out_ack::newgateid() const {
  return newgateid_;
}
inline void kick_out_ack::set_newgateid(::google::protobuf::uint64 value) {
  set_has_newgateid();
  newgateid_ = value;
}

// optional string token = 6;
inline bool kick_out_ack::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void kick_out_ack::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void kick_out_ack::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void kick_out_ack::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& kick_out_ack::token() const {
  return *token_;
}
inline void kick_out_ack::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void kick_out_ack::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void kick_out_ack::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* kick_out_ack::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* kick_out_ack::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void kick_out_ack::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 areaid = 7;
inline bool kick_out_ack::has_areaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void kick_out_ack::set_has_areaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void kick_out_ack::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void kick_out_ack::clear_areaid() {
  areaid_ = 0u;
  clear_has_areaid();
}
inline ::google::protobuf::uint32 kick_out_ack::areaid() const {
  return areaid_;
}
inline void kick_out_ack::set_areaid(::google::protobuf::uint32 value) {
  set_has_areaid();
  areaid_ = value;
}

// -------------------------------------------------------------------

// gt_reconnect_check_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_reconnect_check_req_id];
inline bool gt_reconnect_check_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_reconnect_check_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_reconnect_check_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_reconnect_check_req::clear_protoid() {
  protoid_ = 7;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_reconnect_check_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_reconnect_check_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool gt_reconnect_check_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_reconnect_check_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_reconnect_check_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_reconnect_check_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& gt_reconnect_check_req::account() const {
  return *account_;
}
inline void gt_reconnect_check_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void gt_reconnect_check_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void gt_reconnect_check_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gt_reconnect_check_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* gt_reconnect_check_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gt_reconnect_check_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool gt_reconnect_check_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_reconnect_check_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_reconnect_check_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_reconnect_check_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 gt_reconnect_check_req::clientid() const {
  return clientid_;
}
inline void gt_reconnect_check_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 playerid = 4;
inline bool gt_reconnect_check_req::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gt_reconnect_check_req::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gt_reconnect_check_req::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gt_reconnect_check_req::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 gt_reconnect_check_req::playerid() const {
  return playerid_;
}
inline void gt_reconnect_check_req::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// ct_reconnect_check_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_reconnect_check_ack_id];
inline bool ct_reconnect_check_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_reconnect_check_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_reconnect_check_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_reconnect_check_ack::clear_protoid() {
  protoid_ = 8;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_reconnect_check_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_reconnect_check_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool ct_reconnect_check_ack::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_reconnect_check_ack::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_reconnect_check_ack::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_reconnect_check_ack::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ct_reconnect_check_ack::account() const {
  return *account_;
}
inline void ct_reconnect_check_ack::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ct_reconnect_check_ack::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ct_reconnect_check_ack::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ct_reconnect_check_ack::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ct_reconnect_check_ack::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ct_reconnect_check_ack::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool ct_reconnect_check_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ct_reconnect_check_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ct_reconnect_check_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ct_reconnect_check_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_reconnect_check_ack::clientid() const {
  return clientid_;
}
inline void ct_reconnect_check_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 playerid = 4;
inline bool ct_reconnect_check_ack::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ct_reconnect_check_ack::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ct_reconnect_check_ack::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ct_reconnect_check_ack::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 ct_reconnect_check_ack::playerid() const {
  return playerid_;
}
inline void ct_reconnect_check_ack::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// ct_reconnect_kick_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_reconnect_kick_req_id];
inline bool ct_reconnect_kick_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_reconnect_kick_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_reconnect_kick_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_reconnect_kick_req::clear_protoid() {
  protoid_ = 9;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_reconnect_kick_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_reconnect_kick_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool ct_reconnect_kick_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_reconnect_kick_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_reconnect_kick_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_reconnect_kick_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ct_reconnect_kick_req::account() const {
  return *account_;
}
inline void ct_reconnect_kick_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ct_reconnect_kick_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ct_reconnect_kick_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ct_reconnect_kick_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ct_reconnect_kick_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ct_reconnect_kick_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool ct_reconnect_kick_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ct_reconnect_kick_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ct_reconnect_kick_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ct_reconnect_kick_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_reconnect_kick_req::clientid() const {
  return clientid_;
}
inline void ct_reconnect_kick_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 playerid = 4;
inline bool ct_reconnect_kick_req::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ct_reconnect_kick_req::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ct_reconnect_kick_req::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ct_reconnect_kick_req::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 ct_reconnect_kick_req::playerid() const {
  return playerid_;
}
inline void ct_reconnect_kick_req::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional uint64 new_gate_id = 5;
inline bool ct_reconnect_kick_req::has_new_gate_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ct_reconnect_kick_req::set_has_new_gate_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ct_reconnect_kick_req::clear_has_new_gate_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ct_reconnect_kick_req::clear_new_gate_id() {
  new_gate_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_gate_id();
}
inline ::google::protobuf::uint64 ct_reconnect_kick_req::new_gate_id() const {
  return new_gate_id_;
}
inline void ct_reconnect_kick_req::set_new_gate_id(::google::protobuf::uint64 value) {
  set_has_new_gate_id();
  new_gate_id_ = value;
}

// -------------------------------------------------------------------

// gt_reconnect_kick_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_reconnect_kick_ack_id];
inline bool gt_reconnect_kick_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_reconnect_kick_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_reconnect_kick_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_reconnect_kick_ack::clear_protoid() {
  protoid_ = 10;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_reconnect_kick_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_reconnect_kick_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool gt_reconnect_kick_ack::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_reconnect_kick_ack::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_reconnect_kick_ack::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_reconnect_kick_ack::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& gt_reconnect_kick_ack::account() const {
  return *account_;
}
inline void gt_reconnect_kick_ack::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void gt_reconnect_kick_ack::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void gt_reconnect_kick_ack::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gt_reconnect_kick_ack::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* gt_reconnect_kick_ack::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gt_reconnect_kick_ack::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool gt_reconnect_kick_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_reconnect_kick_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_reconnect_kick_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_reconnect_kick_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 gt_reconnect_kick_ack::clientid() const {
  return clientid_;
}
inline void gt_reconnect_kick_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint64 playerid = 4;
inline bool gt_reconnect_kick_ack::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gt_reconnect_kick_ack::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gt_reconnect_kick_ack::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gt_reconnect_kick_ack::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 gt_reconnect_kick_ack::playerid() const {
  return playerid_;
}
inline void gt_reconnect_kick_ack::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional uint64 new_gate_id = 5;
inline bool gt_reconnect_kick_ack::has_new_gate_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gt_reconnect_kick_ack::set_has_new_gate_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gt_reconnect_kick_ack::clear_has_new_gate_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gt_reconnect_kick_ack::clear_new_gate_id() {
  new_gate_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_gate_id();
}
inline ::google::protobuf::uint64 gt_reconnect_kick_ack::new_gate_id() const {
  return new_gate_id_;
}
inline void gt_reconnect_kick_ack::set_new_gate_id(::google::protobuf::uint64 value) {
  set_has_new_gate_id();
  new_gate_id_ = value;
}

// -------------------------------------------------------------------

// gt_online_client_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_online_client_ntf_id];
inline bool gt_online_client_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_online_client_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_online_client_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_online_client_ntf::clear_protoid() {
  protoid_ = 11;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_online_client_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_online_client_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated uint32 accountid = 2;
inline int gt_online_client_ntf::accountid_size() const {
  return accountid_.size();
}
inline void gt_online_client_ntf::clear_accountid() {
  accountid_.Clear();
}
inline ::google::protobuf::uint32 gt_online_client_ntf::accountid(int index) const {
  return accountid_.Get(index);
}
inline void gt_online_client_ntf::set_accountid(int index, ::google::protobuf::uint32 value) {
  accountid_.Set(index, value);
}
inline void gt_online_client_ntf::add_accountid(::google::protobuf::uint32 value) {
  accountid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
gt_online_client_ntf::accountid() const {
  return accountid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
gt_online_client_ntf::mutable_accountid() {
  return &accountid_;
}

// -------------------------------------------------------------------

// gt_game_server_player_num_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_game_server_player_num_ntf_id];
inline bool gt_game_server_player_num_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_game_server_player_num_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_game_server_player_num_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_game_server_player_num_ntf::clear_protoid() {
  protoid_ = 12;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_game_server_player_num_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_game_server_player_num_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 game_server_id = 2;
inline bool gt_game_server_player_num_ntf::has_game_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_game_server_player_num_ntf::set_has_game_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_game_server_player_num_ntf::clear_has_game_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_game_server_player_num_ntf::clear_game_server_id() {
  game_server_id_ = 0u;
  clear_has_game_server_id();
}
inline ::google::protobuf::uint32 gt_game_server_player_num_ntf::game_server_id() const {
  return game_server_id_;
}
inline void gt_game_server_player_num_ntf::set_game_server_id(::google::protobuf::uint32 value) {
  set_has_game_server_id();
  game_server_id_ = value;
}

// optional uint32 player_num = 3;
inline bool gt_game_server_player_num_ntf::has_player_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_game_server_player_num_ntf::set_has_player_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_game_server_player_num_ntf::clear_has_player_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_game_server_player_num_ntf::clear_player_num() {
  player_num_ = 0u;
  clear_has_player_num();
}
inline ::google::protobuf::uint32 gt_game_server_player_num_ntf::player_num() const {
  return player_num_;
}
inline void gt_game_server_player_num_ntf::set_player_num(::google::protobuf::uint32 value) {
  set_has_player_num();
  player_num_ = value;
}

// -------------------------------------------------------------------

// ct_need_queued_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_need_queued_ntf_id];
inline bool ct_need_queued_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_need_queued_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_need_queued_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_need_queued_ntf::clear_protoid() {
  protoid_ = 13;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_need_queued_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_need_queued_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool ct_need_queued_ntf::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_need_queued_ntf::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_need_queued_ntf::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_need_queued_ntf::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_need_queued_ntf::clientid() const {
  return clientid_;
}
inline void ct_need_queued_ntf::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 pos = 3;
inline bool ct_need_queued_ntf::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ct_need_queued_ntf::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ct_need_queued_ntf::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ct_need_queued_ntf::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ct_need_queued_ntf::pos() const {
  return pos_;
}
inline void ct_need_queued_ntf::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ct_end_queued_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_end_queued_ntf_id];
inline bool ct_end_queued_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_end_queued_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_end_queued_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_end_queued_ntf::clear_protoid() {
  protoid_ = 14;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_end_queued_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_end_queued_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool ct_end_queued_ntf::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_end_queued_ntf::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_end_queued_ntf::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_end_queued_ntf::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_end_queued_ntf::clientid() const {
  return clientid_;
}
inline void ct_end_queued_ntf::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// gt_queued_state_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_queued_state_req_id];
inline bool gt_queued_state_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_queued_state_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_queued_state_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_queued_state_req::clear_protoid() {
  protoid_ = 15;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_queued_state_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_queued_state_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool gt_queued_state_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_queued_state_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_queued_state_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_queued_state_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 gt_queued_state_req::clientid() const {
  return clientid_;
}
inline void gt_queued_state_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 accountid = 3;
inline bool gt_queued_state_req::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_queued_state_req::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_queued_state_req::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_queued_state_req::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 gt_queued_state_req::accountid() const {
  return accountid_;
}
inline void gt_queued_state_req::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// -------------------------------------------------------------------

// ct_queued_state_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_queued_state_ack_id];
inline bool ct_queued_state_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_queued_state_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_queued_state_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_queued_state_ack::clear_protoid() {
  protoid_ = 16;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_queued_state_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_queued_state_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool ct_queued_state_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_queued_state_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_queued_state_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_queued_state_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_queued_state_ack::clientid() const {
  return clientid_;
}
inline void ct_queued_state_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 pos = 3;
inline bool ct_queued_state_ack::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ct_queued_state_ack::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ct_queued_state_ack::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ct_queued_state_ack::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 ct_queued_state_ack::pos() const {
  return pos_;
}
inline void ct_queued_state_ack::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// gt_cancel_queue_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gt_cancel_queue_req_id];
inline bool gt_cancel_queue_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gt_cancel_queue_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gt_cancel_queue_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gt_cancel_queue_req::clear_protoid() {
  protoid_ = 17;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gt_cancel_queue_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gt_cancel_queue_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool gt_cancel_queue_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gt_cancel_queue_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gt_cancel_queue_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gt_cancel_queue_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 gt_cancel_queue_req::clientid() const {
  return clientid_;
}
inline void gt_cancel_queue_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional uint32 accountid = 3;
inline bool gt_cancel_queue_req::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gt_cancel_queue_req::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gt_cancel_queue_req::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gt_cancel_queue_req::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 gt_cancel_queue_req::accountid() const {
  return accountid_;
}
inline void gt_cancel_queue_req::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// -------------------------------------------------------------------

// ct_cancel_queue_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = ct_cancel_queue_ack_id];
inline bool ct_cancel_queue_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ct_cancel_queue_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ct_cancel_queue_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ct_cancel_queue_ack::clear_protoid() {
  protoid_ = 18;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID ct_cancel_queue_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void ct_cancel_queue_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 clientid = 2;
inline bool ct_cancel_queue_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ct_cancel_queue_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ct_cancel_queue_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ct_cancel_queue_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 ct_cancel_queue_ack::clientid() const {
  return clientid_;
}
inline void ct_cancel_queue_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// account_login_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = account_login_ntf_id];
inline bool account_login_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void account_login_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void account_login_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void account_login_ntf::clear_protoid() {
  protoid_ = 31;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID account_login_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void account_login_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string accountid = 2;
inline bool account_login_ntf::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void account_login_ntf::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void account_login_ntf::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void account_login_ntf::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& account_login_ntf::accountid() const {
  return *accountid_;
}
inline void account_login_ntf::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void account_login_ntf::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void account_login_ntf::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* account_login_ntf::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* account_login_ntf::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void account_login_ntf::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool account_login_ntf::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void account_login_ntf::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void account_login_ntf::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void account_login_ntf::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& account_login_ntf::token() const {
  return *token_;
}
inline void account_login_ntf::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void account_login_ntf::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void account_login_ntf::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* account_login_ntf::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* account_login_ntf::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void account_login_ntf::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tempid = 4;
inline bool account_login_ntf::has_tempid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void account_login_ntf::set_has_tempid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void account_login_ntf::clear_has_tempid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void account_login_ntf::clear_tempid() {
  tempid_ = 0u;
  clear_has_tempid();
}
inline ::google::protobuf::uint32 account_login_ntf::tempid() const {
  return tempid_;
}
inline void account_login_ntf::set_tempid(::google::protobuf::uint32 value) {
  set_has_tempid();
  tempid_ = value;
}

// optional uint32 lastverifytime = 5;
inline bool account_login_ntf::has_lastverifytime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void account_login_ntf::set_has_lastverifytime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void account_login_ntf::clear_has_lastverifytime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void account_login_ntf::clear_lastverifytime() {
  lastverifytime_ = 0u;
  clear_has_lastverifytime();
}
inline ::google::protobuf::uint32 account_login_ntf::lastverifytime() const {
  return lastverifytime_;
}
inline void account_login_ntf::set_lastverifytime(::google::protobuf::uint32 value) {
  set_has_lastverifytime();
  lastverifytime_ = value;
}

// -------------------------------------------------------------------

// account_login_ntf_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = account_login_ntf_ack_id];
inline bool account_login_ntf_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void account_login_ntf_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void account_login_ntf_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void account_login_ntf_ack::clear_protoid() {
  protoid_ = 30;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID account_login_ntf_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void account_login_ntf_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string accountid = 2;
inline bool account_login_ntf_ack::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void account_login_ntf_ack::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void account_login_ntf_ack::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void account_login_ntf_ack::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& account_login_ntf_ack::accountid() const {
  return *accountid_;
}
inline void account_login_ntf_ack::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void account_login_ntf_ack::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void account_login_ntf_ack::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* account_login_ntf_ack::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* account_login_ntf_ack::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void account_login_ntf_ack::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_list_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_list_req_id];
inline bool area_list_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_list_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_list_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_list_req::clear_protoid() {
  protoid_ = 32;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_list_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_list_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool area_list_req::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_list_req::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_list_req::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_list_req::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& area_list_req::account() const {
  return *account_;
}
inline void area_list_req::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void area_list_req::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void area_list_req::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area_list_req::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* area_list_req::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area_list_req::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool area_list_req::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area_list_req::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area_list_req::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area_list_req::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 area_list_req::clientid() const {
  return clientid_;
}
inline void area_list_req::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// gate_net_info

// optional uint64 id = 1;
inline bool gate_net_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gate_net_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gate_net_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gate_net_info::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 gate_net_info::id() const {
  return id_;
}
inline void gate_net_info::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string ip = 2;
inline bool gate_net_info::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gate_net_info::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gate_net_info::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gate_net_info::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& gate_net_info::ip() const {
  return *ip_;
}
inline void gate_net_info::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void gate_net_info::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void gate_net_info::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gate_net_info::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* gate_net_info::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gate_net_info::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool gate_net_info::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gate_net_info::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gate_net_info::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gate_net_info::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 gate_net_info::port() const {
  return port_;
}
inline void gate_net_info::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional string group_name = 4;
inline bool gate_net_info::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gate_net_info::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gate_net_info::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gate_net_info::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& gate_net_info::group_name() const {
  return *group_name_;
}
inline void gate_net_info::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void gate_net_info::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void gate_net_info::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gate_net_info::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* gate_net_info::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gate_net_info::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool new = 5;
inline bool gate_net_info::has_new_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gate_net_info::set_has_new_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gate_net_info::clear_has_new_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gate_net_info::clear_new_() {
  new__ = false;
  clear_has_new_();
}
inline bool gate_net_info::new_() const {
  return new__;
}
inline void gate_net_info::set_new_(bool value) {
  set_has_new_();
  new__ = value;
}

// optional int32 state = 6;
inline bool gate_net_info::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void gate_net_info::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void gate_net_info::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void gate_net_info::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 gate_net_info::state() const {
  return state_;
}
inline void gate_net_info::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 groupindex = 7;
inline bool gate_net_info::has_groupindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void gate_net_info::set_has_groupindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void gate_net_info::clear_has_groupindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void gate_net_info::clear_groupindex() {
  groupindex_ = 0u;
  clear_has_groupindex();
}
inline ::google::protobuf::uint32 gate_net_info::groupindex() const {
  return groupindex_;
}
inline void gate_net_info::set_groupindex(::google::protobuf::uint32 value) {
  set_has_groupindex();
  groupindex_ = value;
}

// -------------------------------------------------------------------

// area_brief_info

// optional int32 area_id = 1;
inline bool area_brief_info::has_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_brief_info::set_has_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_brief_info::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_brief_info::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 area_brief_info::area_id() const {
  return area_id_;
}
inline void area_brief_info::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional string role_name = 2;
inline bool area_brief_info::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_brief_info::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_brief_info::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_brief_info::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& area_brief_info::role_name() const {
  return *role_name_;
}
inline void area_brief_info::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void area_brief_info::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void area_brief_info::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area_brief_info::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* area_brief_info::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area_brief_info::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_record

// optional uint32 last_area_id = 1;
inline bool area_record::has_last_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_record::set_has_last_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_record::clear_has_last_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_record::clear_last_area_id() {
  last_area_id_ = 0u;
  clear_has_last_area_id();
}
inline ::google::protobuf::uint32 area_record::last_area_id() const {
  return last_area_id_;
}
inline void area_record::set_last_area_id(::google::protobuf::uint32 value) {
  set_has_last_area_id();
  last_area_id_ = value;
}

// repeated .SProtoSpace.area_brief_info areas = 2;
inline int area_record::areas_size() const {
  return areas_.size();
}
inline void area_record::clear_areas() {
  areas_.Clear();
}
inline const ::SProtoSpace::area_brief_info& area_record::areas(int index) const {
  return areas_.Get(index);
}
inline ::SProtoSpace::area_brief_info* area_record::mutable_areas(int index) {
  return areas_.Mutable(index);
}
inline ::SProtoSpace::area_brief_info* area_record::add_areas() {
  return areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_brief_info >&
area_record::areas() const {
  return areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_brief_info >*
area_record::mutable_areas() {
  return &areas_;
}

// -------------------------------------------------------------------

// group_area_info

// repeated uint64 groupids = 1;
inline int group_area_info::groupids_size() const {
  return groupids_.size();
}
inline void group_area_info::clear_groupids() {
  groupids_.Clear();
}
inline ::google::protobuf::uint64 group_area_info::groupids(int index) const {
  return groupids_.Get(index);
}
inline void group_area_info::set_groupids(int index, ::google::protobuf::uint64 value) {
  groupids_.Set(index, value);
}
inline void group_area_info::add_groupids(::google::protobuf::uint64 value) {
  groupids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
group_area_info::groupids() const {
  return groupids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
group_area_info::mutable_groupids() {
  return &groupids_;
}

// optional string area_group_name = 2;
inline bool group_area_info::has_area_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void group_area_info::set_has_area_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void group_area_info::clear_has_area_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void group_area_info::clear_area_group_name() {
  if (area_group_name_ != &::google::protobuf::internal::kEmptyString) {
    area_group_name_->clear();
  }
  clear_has_area_group_name();
}
inline const ::std::string& group_area_info::area_group_name() const {
  return *area_group_name_;
}
inline void group_area_info::set_area_group_name(const ::std::string& value) {
  set_has_area_group_name();
  if (area_group_name_ == &::google::protobuf::internal::kEmptyString) {
    area_group_name_ = new ::std::string;
  }
  area_group_name_->assign(value);
}
inline void group_area_info::set_area_group_name(const char* value) {
  set_has_area_group_name();
  if (area_group_name_ == &::google::protobuf::internal::kEmptyString) {
    area_group_name_ = new ::std::string;
  }
  area_group_name_->assign(value);
}
inline void group_area_info::set_area_group_name(const char* value, size_t size) {
  set_has_area_group_name();
  if (area_group_name_ == &::google::protobuf::internal::kEmptyString) {
    area_group_name_ = new ::std::string;
  }
  area_group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* group_area_info::mutable_area_group_name() {
  set_has_area_group_name();
  if (area_group_name_ == &::google::protobuf::internal::kEmptyString) {
    area_group_name_ = new ::std::string;
  }
  return area_group_name_;
}
inline ::std::string* group_area_info::release_area_group_name() {
  clear_has_area_group_name();
  if (area_group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_group_name_;
    area_group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void group_area_info::set_allocated_area_group_name(::std::string* area_group_name) {
  if (area_group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete area_group_name_;
  }
  if (area_group_name) {
    set_has_area_group_name();
    area_group_name_ = area_group_name;
  } else {
    clear_has_area_group_name();
    area_group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// area_list_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_list_ack_id];
inline bool area_list_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_list_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_list_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_list_ack::clear_protoid() {
  protoid_ = 33;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_list_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_list_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool area_list_ack::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_list_ack::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_list_ack::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_list_ack::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& area_list_ack::account() const {
  return *account_;
}
inline void area_list_ack::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void area_list_ack::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void area_list_ack::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* area_list_ack::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* area_list_ack::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void area_list_ack::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientid = 3;
inline bool area_list_ack::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void area_list_ack::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void area_list_ack::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void area_list_ack::clear_clientid() {
  clientid_ = 0u;
  clear_has_clientid();
}
inline ::google::protobuf::uint32 area_list_ack::clientid() const {
  return clientid_;
}
inline void area_list_ack::set_clientid(::google::protobuf::uint32 value) {
  set_has_clientid();
  clientid_ = value;
}

// repeated .SProtoSpace.gate_net_info groups = 4;
inline int area_list_ack::groups_size() const {
  return groups_.size();
}
inline void area_list_ack::clear_groups() {
  groups_.Clear();
}
inline const ::SProtoSpace::gate_net_info& area_list_ack::groups(int index) const {
  return groups_.Get(index);
}
inline ::SProtoSpace::gate_net_info* area_list_ack::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::SProtoSpace::gate_net_info* area_list_ack::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gate_net_info >&
area_list_ack::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::gate_net_info >*
area_list_ack::mutable_groups() {
  return &groups_;
}

// optional uint64 centerid = 5;
inline bool area_list_ack::has_centerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void area_list_ack::set_has_centerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void area_list_ack::clear_has_centerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void area_list_ack::clear_centerid() {
  centerid_ = GOOGLE_ULONGLONG(0);
  clear_has_centerid();
}
inline ::google::protobuf::uint64 area_list_ack::centerid() const {
  return centerid_;
}
inline void area_list_ack::set_centerid(::google::protobuf::uint64 value) {
  set_has_centerid();
  centerid_ = value;
}

// repeated .SProtoSpace.group_area_info area_groups = 6;
inline int area_list_ack::area_groups_size() const {
  return area_groups_.size();
}
inline void area_list_ack::clear_area_groups() {
  area_groups_.Clear();
}
inline const ::SProtoSpace::group_area_info& area_list_ack::area_groups(int index) const {
  return area_groups_.Get(index);
}
inline ::SProtoSpace::group_area_info* area_list_ack::mutable_area_groups(int index) {
  return area_groups_.Mutable(index);
}
inline ::SProtoSpace::group_area_info* area_list_ack::add_area_groups() {
  return area_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >&
area_list_ack::area_groups() const {
  return area_groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >*
area_list_ack::mutable_area_groups() {
  return &area_groups_;
}

// repeated .SProtoSpace.group_area_info recommend_areas = 7;
inline int area_list_ack::recommend_areas_size() const {
  return recommend_areas_.size();
}
inline void area_list_ack::clear_recommend_areas() {
  recommend_areas_.Clear();
}
inline const ::SProtoSpace::group_area_info& area_list_ack::recommend_areas(int index) const {
  return recommend_areas_.Get(index);
}
inline ::SProtoSpace::group_area_info* area_list_ack::mutable_recommend_areas(int index) {
  return recommend_areas_.Mutable(index);
}
inline ::SProtoSpace::group_area_info* area_list_ack::add_recommend_areas() {
  return recommend_areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >&
area_list_ack::recommend_areas() const {
  return recommend_areas_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::group_area_info >*
area_list_ack::mutable_recommend_areas() {
  return &recommend_areas_;
}

// -------------------------------------------------------------------

// area_gateserver_info_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_req_id];
inline bool area_gateserver_info_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_gateserver_info_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_gateserver_info_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_gateserver_info_req::clear_protoid() {
  protoid_ = 34;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_gateserver_info_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_gateserver_info_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 time = 2;
inline bool area_gateserver_info_req::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_gateserver_info_req::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_gateserver_info_req::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_gateserver_info_req::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 area_gateserver_info_req::time() const {
  return time_;
}
inline void area_gateserver_info_req::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// area_gateserver_info_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_ack_id];
inline bool area_gateserver_info_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_gateserver_info_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_gateserver_info_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_gateserver_info_ack::clear_protoid() {
  protoid_ = 35;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_gateserver_info_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_gateserver_info_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// repeated .SProtoSpace.area_gateserver_info gs_info = 2;
inline int area_gateserver_info_ack::gs_info_size() const {
  return gs_info_.size();
}
inline void area_gateserver_info_ack::clear_gs_info() {
  gs_info_.Clear();
}
inline const ::SProtoSpace::area_gateserver_info& area_gateserver_info_ack::gs_info(int index) const {
  return gs_info_.Get(index);
}
inline ::SProtoSpace::area_gateserver_info* area_gateserver_info_ack::mutable_gs_info(int index) {
  return gs_info_.Mutable(index);
}
inline ::SProtoSpace::area_gateserver_info* area_gateserver_info_ack::add_gs_info() {
  return gs_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_gateserver_info >&
area_gateserver_info_ack::gs_info() const {
  return gs_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SProtoSpace::area_gateserver_info >*
area_gateserver_info_ack::mutable_gs_info() {
  return &gs_info_;
}

// -------------------------------------------------------------------

// area_gateserver_info_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = area_gateserver_info_ntf_id];
inline bool area_gateserver_info_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void area_gateserver_info_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void area_gateserver_info_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void area_gateserver_info_ntf::clear_protoid() {
  protoid_ = 36;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID area_gateserver_info_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void area_gateserver_info_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional .SProtoSpace.area_gateserver_info gs_info = 2;
inline bool area_gateserver_info_ntf::has_gs_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void area_gateserver_info_ntf::set_has_gs_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void area_gateserver_info_ntf::clear_has_gs_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void area_gateserver_info_ntf::clear_gs_info() {
  if (gs_info_ != NULL) gs_info_->::SProtoSpace::area_gateserver_info::Clear();
  clear_has_gs_info();
}
inline const ::SProtoSpace::area_gateserver_info& area_gateserver_info_ntf::gs_info() const {
  return gs_info_ != NULL ? *gs_info_ : *default_instance_->gs_info_;
}
inline ::SProtoSpace::area_gateserver_info* area_gateserver_info_ntf::mutable_gs_info() {
  set_has_gs_info();
  if (gs_info_ == NULL) gs_info_ = new ::SProtoSpace::area_gateserver_info;
  return gs_info_;
}
inline ::SProtoSpace::area_gateserver_info* area_gateserver_info_ntf::release_gs_info() {
  clear_has_gs_info();
  ::SProtoSpace::area_gateserver_info* temp = gs_info_;
  gs_info_ = NULL;
  return temp;
}
inline void area_gateserver_info_ntf::set_allocated_gs_info(::SProtoSpace::area_gateserver_info* gs_info) {
  delete gs_info_;
  gs_info_ = gs_info;
  if (gs_info) {
    set_has_gs_info();
  } else {
    clear_has_gs_info();
  }
}

// -------------------------------------------------------------------

// update_area_info_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = update_area_info_ntf_id];
inline bool update_area_info_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void update_area_info_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void update_area_info_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void update_area_info_ntf::clear_protoid() {
  protoid_ = 40;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID update_area_info_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void update_area_info_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional string account = 2;
inline bool update_area_info_ntf::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void update_area_info_ntf::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void update_area_info_ntf::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void update_area_info_ntf::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& update_area_info_ntf::account() const {
  return *account_;
}
inline void update_area_info_ntf::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void update_area_info_ntf::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void update_area_info_ntf::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* update_area_info_ntf::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* update_area_info_ntf::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void update_area_info_ntf::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SProtoSpace.area_brief_info data = 3;
inline bool update_area_info_ntf::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void update_area_info_ntf::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void update_area_info_ntf::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void update_area_info_ntf::clear_data() {
  if (data_ != NULL) data_->::SProtoSpace::area_brief_info::Clear();
  clear_has_data();
}
inline const ::SProtoSpace::area_brief_info& update_area_info_ntf::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::SProtoSpace::area_brief_info* update_area_info_ntf::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::SProtoSpace::area_brief_info;
  return data_;
}
inline ::SProtoSpace::area_brief_info* update_area_info_ntf::release_data() {
  clear_has_data();
  ::SProtoSpace::area_brief_info* temp = data_;
  data_ = NULL;
  return temp;
}
inline void update_area_info_ntf::set_allocated_data(::SProtoSpace::area_brief_info* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// lc_heartbeat_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = lc_heartbeat_req_id];
inline bool lc_heartbeat_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lc_heartbeat_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lc_heartbeat_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lc_heartbeat_req::clear_protoid() {
  protoid_ = 37;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID lc_heartbeat_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void lc_heartbeat_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 sid = 2;
inline bool lc_heartbeat_req::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lc_heartbeat_req::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lc_heartbeat_req::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lc_heartbeat_req::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 lc_heartbeat_req::sid() const {
  return sid_;
}
inline void lc_heartbeat_req::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
}

// optional uint32 tm = 3;
inline bool lc_heartbeat_req::has_tm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lc_heartbeat_req::set_has_tm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lc_heartbeat_req::clear_has_tm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lc_heartbeat_req::clear_tm() {
  tm_ = 0u;
  clear_has_tm();
}
inline ::google::protobuf::uint32 lc_heartbeat_req::tm() const {
  return tm_;
}
inline void lc_heartbeat_req::set_tm(::google::protobuf::uint32 value) {
  set_has_tm();
  tm_ = value;
}

// -------------------------------------------------------------------

// lc_heartbeat_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = lc_heartbeat_ack_id];
inline bool lc_heartbeat_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lc_heartbeat_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lc_heartbeat_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lc_heartbeat_ack::clear_protoid() {
  protoid_ = 38;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID lc_heartbeat_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void lc_heartbeat_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 region = 2;
inline bool lc_heartbeat_ack::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lc_heartbeat_ack::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lc_heartbeat_ack::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lc_heartbeat_ack::clear_region() {
  region_ = 0u;
  clear_has_region();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::region() const {
  return region_;
}
inline void lc_heartbeat_ack::set_region(::google::protobuf::uint32 value) {
  set_has_region();
  region_ = value;
}

// optional uint32 group = 3;
inline bool lc_heartbeat_ack::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lc_heartbeat_ack::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lc_heartbeat_ack::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lc_heartbeat_ack::clear_group() {
  group_ = 0u;
  clear_has_group();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::group() const {
  return group_;
}
inline void lc_heartbeat_ack::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// optional uint32 type = 4;
inline bool lc_heartbeat_ack::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lc_heartbeat_ack::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lc_heartbeat_ack::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lc_heartbeat_ack::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::type() const {
  return type_;
}
inline void lc_heartbeat_ack::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 index = 5;
inline bool lc_heartbeat_ack::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void lc_heartbeat_ack::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void lc_heartbeat_ack::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void lc_heartbeat_ack::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::index() const {
  return index_;
}
inline void lc_heartbeat_ack::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 sid = 6;
inline bool lc_heartbeat_ack::has_sid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void lc_heartbeat_ack::set_has_sid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void lc_heartbeat_ack::clear_has_sid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void lc_heartbeat_ack::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::sid() const {
  return sid_;
}
inline void lc_heartbeat_ack::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
}

// optional uint32 tm = 7;
inline bool lc_heartbeat_ack::has_tm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void lc_heartbeat_ack::set_has_tm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void lc_heartbeat_ack::clear_has_tm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void lc_heartbeat_ack::clear_tm() {
  tm_ = 0u;
  clear_has_tm();
}
inline ::google::protobuf::uint32 lc_heartbeat_ack::tm() const {
  return tm_;
}
inline void lc_heartbeat_ack::set_tm(::google::protobuf::uint32 value) {
  set_has_tm();
  tm_ = value;
}

// -------------------------------------------------------------------

// role_leave_game_ntf

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = role_leave_game_ntf_id];
inline bool role_leave_game_ntf::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_leave_game_ntf::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_leave_game_ntf::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_leave_game_ntf::clear_protoid() {
  protoid_ = 19;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID role_leave_game_ntf::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void role_leave_game_ntf::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 id = 2;
inline bool role_leave_game_ntf::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_leave_game_ntf::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_leave_game_ntf::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_leave_game_ntf::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 role_leave_game_ntf::id() const {
  return id_;
}
inline void role_leave_game_ntf::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 accountid = 3;
inline bool role_leave_game_ntf::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_leave_game_ntf::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_leave_game_ntf::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_leave_game_ntf::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 role_leave_game_ntf::accountid() const {
  return accountid_;
}
inline void role_leave_game_ntf::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint64 groupid = 4;
inline bool role_leave_game_ntf::has_groupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_leave_game_ntf::set_has_groupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_leave_game_ntf::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_leave_game_ntf::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 role_leave_game_ntf::groupid() const {
  return groupid_;
}
inline void role_leave_game_ntf::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional uint32 level = 5;
inline bool role_leave_game_ntf::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_leave_game_ntf::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_leave_game_ntf::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_leave_game_ntf::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 role_leave_game_ntf::level() const {
  return level_;
}
inline void role_leave_game_ntf::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 heroid = 6;
inline bool role_leave_game_ntf::has_heroid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_leave_game_ntf::set_has_heroid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_leave_game_ntf::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_leave_game_ntf::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 role_leave_game_ntf::heroid() const {
  return heroid_;
}
inline void role_leave_game_ntf::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// optional uint32 lastlogindate = 7;
inline bool role_leave_game_ntf::has_lastlogindate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_leave_game_ntf::set_has_lastlogindate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_leave_game_ntf::clear_has_lastlogindate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_leave_game_ntf::clear_lastlogindate() {
  lastlogindate_ = 0u;
  clear_has_lastlogindate();
}
inline ::google::protobuf::uint32 role_leave_game_ntf::lastlogindate() const {
  return lastlogindate_;
}
inline void role_leave_game_ntf::set_lastlogindate(::google::protobuf::uint32 value) {
  set_has_lastlogindate();
  lastlogindate_ = value;
}

// optional string account = 8;
inline bool role_leave_game_ntf::has_account() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_leave_game_ntf::set_has_account() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_leave_game_ntf::clear_has_account() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_leave_game_ntf::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& role_leave_game_ntf::account() const {
  return *account_;
}
inline void role_leave_game_ntf::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_leave_game_ntf::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void role_leave_game_ntf::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_leave_game_ntf::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* role_leave_game_ntf::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_leave_game_ntf::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gm2center_close_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_close_req_id];
inline bool gm2center_close_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm2center_close_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm2center_close_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm2center_close_req::clear_protoid() {
  protoid_ = 51;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm2center_close_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm2center_close_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// center2gm_close_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_close_ack_id];
inline bool center2gm_close_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void center2gm_close_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void center2gm_close_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void center2gm_close_ack::clear_protoid() {
  protoid_ = 52;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID center2gm_close_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void center2gm_close_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 retcode = 2;
inline bool center2gm_close_ack::has_retcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void center2gm_close_ack::set_has_retcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void center2gm_close_ack::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void center2gm_close_ack::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 center2gm_close_ack::retcode() const {
  return retcode_;
}
inline void center2gm_close_ack::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// -------------------------------------------------------------------

// gm2center_center_status_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_center_status_req_id];
inline bool gm2center_center_status_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm2center_center_status_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm2center_center_status_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm2center_center_status_req::clear_protoid() {
  protoid_ = 53;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm2center_center_status_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm2center_center_status_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint64 info_detail = 2;
inline bool gm2center_center_status_req::has_info_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gm2center_center_status_req::set_has_info_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gm2center_center_status_req::clear_has_info_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gm2center_center_status_req::clear_info_detail() {
  info_detail_ = GOOGLE_ULONGLONG(0);
  clear_has_info_detail();
}
inline ::google::protobuf::uint64 gm2center_center_status_req::info_detail() const {
  return info_detail_;
}
inline void gm2center_center_status_req::set_info_detail(::google::protobuf::uint64 value) {
  set_has_info_detail();
  info_detail_ = value;
}

// -------------------------------------------------------------------

// center2gm_center_status_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_center_status_ack_id];
inline bool center2gm_center_status_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void center2gm_center_status_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void center2gm_center_status_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void center2gm_center_status_ack::clear_protoid() {
  protoid_ = 54;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID center2gm_center_status_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void center2gm_center_status_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// optional uint32 server_status = 2;
inline bool center2gm_center_status_ack::has_server_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void center2gm_center_status_ack::set_has_server_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void center2gm_center_status_ack::clear_has_server_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void center2gm_center_status_ack::clear_server_status() {
  server_status_ = 0u;
  clear_has_server_status();
}
inline ::google::protobuf::uint32 center2gm_center_status_ack::server_status() const {
  return server_status_;
}
inline void center2gm_center_status_ack::set_server_status(::google::protobuf::uint32 value) {
  set_has_server_status();
  server_status_ = value;
}

// optional uint32 account_count = 3;
inline bool center2gm_center_status_ack::has_account_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void center2gm_center_status_ack::set_has_account_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void center2gm_center_status_ack::clear_has_account_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void center2gm_center_status_ack::clear_account_count() {
  account_count_ = 0u;
  clear_has_account_count();
}
inline ::google::protobuf::uint32 center2gm_center_status_ack::account_count() const {
  return account_count_;
}
inline void center2gm_center_status_ack::set_account_count(::google::protobuf::uint32 value) {
  set_has_account_count();
  account_count_ = value;
}

// optional uint64 server_id = 4;
inline bool center2gm_center_status_ack::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void center2gm_center_status_ack::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void center2gm_center_status_ack::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void center2gm_center_status_ack::clear_server_id() {
  server_id_ = GOOGLE_ULONGLONG(0);
  clear_has_server_id();
}
inline ::google::protobuf::uint64 center2gm_center_status_ack::server_id() const {
  return server_id_;
}
inline void center2gm_center_status_ack::set_server_id(::google::protobuf::uint64 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint64 server_port = 5;
inline bool center2gm_center_status_ack::has_server_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void center2gm_center_status_ack::set_has_server_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void center2gm_center_status_ack::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void center2gm_center_status_ack::clear_server_port() {
  server_port_ = GOOGLE_ULONGLONG(0);
  clear_has_server_port();
}
inline ::google::protobuf::uint64 center2gm_center_status_ack::server_port() const {
  return server_port_;
}
inline void center2gm_center_status_ack::set_server_port(::google::protobuf::uint64 value) {
  set_has_server_port();
  server_port_ = value;
}

// optional uint64 server_redis_ip = 16;
inline bool center2gm_center_status_ack::has_server_redis_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void center2gm_center_status_ack::set_has_server_redis_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void center2gm_center_status_ack::clear_has_server_redis_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void center2gm_center_status_ack::clear_server_redis_ip() {
  server_redis_ip_ = GOOGLE_ULONGLONG(0);
  clear_has_server_redis_ip();
}
inline ::google::protobuf::uint64 center2gm_center_status_ack::server_redis_ip() const {
  return server_redis_ip_;
}
inline void center2gm_center_status_ack::set_server_redis_ip(::google::protobuf::uint64 value) {
  set_has_server_redis_ip();
  server_redis_ip_ = value;
}

// optional uint64 server_redis_port = 17;
inline bool center2gm_center_status_ack::has_server_redis_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void center2gm_center_status_ack::set_has_server_redis_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void center2gm_center_status_ack::clear_has_server_redis_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void center2gm_center_status_ack::clear_server_redis_port() {
  server_redis_port_ = GOOGLE_ULONGLONG(0);
  clear_has_server_redis_port();
}
inline ::google::protobuf::uint64 center2gm_center_status_ack::server_redis_port() const {
  return server_redis_port_;
}
inline void center2gm_center_status_ack::set_server_redis_port(::google::protobuf::uint64 value) {
  set_has_server_redis_port();
  server_redis_port_ = value;
}

// optional uint32 gateserver_count = 18;
inline bool center2gm_center_status_ack::has_gateserver_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void center2gm_center_status_ack::set_has_gateserver_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void center2gm_center_status_ack::clear_has_gateserver_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void center2gm_center_status_ack::clear_gateserver_count() {
  gateserver_count_ = 0u;
  clear_has_gateserver_count();
}
inline ::google::protobuf::uint32 center2gm_center_status_ack::gateserver_count() const {
  return gateserver_count_;
}
inline void center2gm_center_status_ack::set_gateserver_count(::google::protobuf::uint32 value) {
  set_has_gateserver_count();
  gateserver_count_ = value;
}

// optional uint32 redis_statue = 19;
inline bool center2gm_center_status_ack::has_redis_statue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void center2gm_center_status_ack::set_has_redis_statue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void center2gm_center_status_ack::clear_has_redis_statue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void center2gm_center_status_ack::clear_redis_statue() {
  redis_statue_ = 0u;
  clear_has_redis_statue();
}
inline ::google::protobuf::uint32 center2gm_center_status_ack::redis_statue() const {
  return redis_statue_;
}
inline void center2gm_center_status_ack::set_redis_statue(::google::protobuf::uint32 value) {
  set_has_redis_statue();
  redis_statue_ = value;
}

// -------------------------------------------------------------------

// gm2center_center_reset_req

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = gm2center_center_reset_req_id];
inline bool gm2center_center_reset_req::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm2center_center_reset_req::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm2center_center_reset_req::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm2center_center_reset_req::clear_protoid() {
  protoid_ = 55;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID gm2center_center_reset_req::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void gm2center_center_reset_req::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}

// -------------------------------------------------------------------

// center2gm_center_reset_ack

// optional .SProtoSpace.ESSProtoID protoid = 1 [default = center2gm_center_reset_ack_id];
inline bool center2gm_center_reset_ack::has_protoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void center2gm_center_reset_ack::set_has_protoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void center2gm_center_reset_ack::clear_has_protoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void center2gm_center_reset_ack::clear_protoid() {
  protoid_ = 56;
  clear_has_protoid();
}
inline ::SProtoSpace::ESSProtoID center2gm_center_reset_ack::protoid() const {
  return static_cast< ::SProtoSpace::ESSProtoID >(protoid_);
}
inline void center2gm_center_reset_ack::set_protoid(::SProtoSpace::ESSProtoID value) {
  assert(::SProtoSpace::ESSProtoID_IsValid(value));
  set_has_protoid();
  protoid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SProtoSpace

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ss_5fcenter_2eproto__INCLUDED
